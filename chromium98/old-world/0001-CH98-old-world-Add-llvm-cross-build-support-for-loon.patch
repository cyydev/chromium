From 2db0832ace5524b3b95c842172f1b62b388f12dd Mon Sep 17 00:00:00 2001
From: Wang Qing <wangqing-hf@loongson.cn>
Date: Fri, 1 Dec 2023 17:59:23 +0800
Subject: [PATCH] [CH98-old-world] Add llvm cross build support for
 loongarch64.

---
 base/allocator/BUILD.gn                       |    2 +-
 .../page_allocator_constants.h                |    2 +-
 .../partition_alloc_constants.h               |    2 +-
 base/process/launch_posix.cc                  |    2 +-
 base/system/sys_info.cc                       |    2 +
 .../double-conversion/utils.h                 |    1 +
 build/build_config.h                          |    8 +-
 build/config/clang/clang.gni                  |    6 +-
 build/config/compiler/BUILD.gn                |    6 +
 build/config/posix/BUILD.gn                   |    2 +-
 build/config/sysroot.gni                      |    5 +-
 build/cross-build.sh                          |   45 +
 .../runtime/chrome_runtime_api_delegate.cc    |    2 +
 chrome/installer/linux/BUILD.gn               |   10 +-
 chrome/installer/linux/common/apt.include     |    2 +
 chrome/installer/linux/common/rpm.include     |    2 +-
 chrome/installer/linux/debian/build.sh        |    2 +-
 .../linux/debian/calculate_package_deps.py    |    3 +
 chrome/installer/linux/rpm/build.sh           |    2 +-
 .../update_client/update_query_params.cc      |    4 +
 components/variations/proto/study.proto       |    2 +
 .../service/variations_field_trial_creator.cc |    2 +
 extensions/common/api/runtime.json            |    4 +-
 sandbox/features.gni                          |    3 +-
 sandbox/linux/BUILD.gn                        |    1 +
 sandbox/linux/bpf_dsl/linux_syscall_ranges.h  |    7 +
 sandbox/linux/bpf_dsl/seccomp_macros.h        |   42 +
 .../bpf_dsl_seccomp_unittest.cc               |    5 +-
 .../seccomp-bpf-helpers/baseline_policy.cc    |    6 +-
 .../baseline_policy_unittest.cc               |    8 +-
 .../syscall_parameters_restrictions.cc        |    8 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.cc |   61 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.h  |   16 +-
 sandbox/linux/seccomp-bpf/syscall.cc          |   32 +-
 sandbox/linux/services/credentials.cc         |    2 +-
 sandbox/linux/services/syscall_wrappers.cc    |    2 +-
 .../linux/syscall_broker/broker_process.cc    |   18 +-
 .../syscall_broker/broker_process_unittest.cc |    2 +
 sandbox/linux/system_headers/linux_seccomp.h  |    9 +
 sandbox/linux/system_headers/linux_signal.h   |    6 +-
 sandbox/linux/system_headers/linux_stat.h     |    2 +-
 sandbox/linux/system_headers/linux_syscalls.h |    4 +
 .../system_headers/loong64_linux_syscalls.h   | 1221 ++++++
 .../linux/bpf_cros_amd_gpu_policy_linux.cc    |    2 +-
 sandbox/policy/linux/bpf_gpu_policy_linux.cc  |    2 +-
 skia/BUILD.gn                                 |    2 +
 .../absl/debugging/internal/examine_stack.cc  |    2 +
 third_party/angle/gni/angle.gni               |    2 +-
 .../boringssl/src/include/openssl/base.h      |    3 +
 third_party/breakpad/BUILD.gn                 |    2 +
 third_party/breakpad/breakpad/Makefile.am     |    9 +
 third_party/breakpad/breakpad/Makefile.in     |   17 +
 .../breakpad/breakpad/autotools/config.guess  |    3 +
 .../dump_writer_common/raw_context_cpu.h      |    2 +
 .../linux/dump_writer_common/thread_info.cc   |   32 +
 .../linux/dump_writer_common/thread_info.h    |    3 +
 .../dump_writer_common/ucontext_reader.cc     |   25 +
 .../client/linux/handler/exception_handler.cc |    7 +-
 .../client/linux/handler/exception_handler.h  |    2 +-
 .../handler/exception_handler_unittest.cc     |    5 +-
 .../microdump_writer/microdump_writer.cc      |    8 +-
 .../microdump_writer_unittest.cc              |   12 +-
 .../minidump_writer/linux_core_dumper.cc      |    8 +
 .../linux/minidump_writer/linux_dumper.h      |    2 +-
 .../linux_dumper_unittest_helper.cc           |    3 +
 .../minidump_writer/linux_ptrace_dumper.cc    |    8 +
 .../linux_ptrace_dumper_unittest.cc           |    5 +
 .../linux/minidump_writer/minidump_writer.cc  |   10 +-
 .../linux/minidump_writer/minidump_writer.h   |    2 +-
 .../minidump_writer_unittest.cc               |    3 +
 .../src/common/dwarf_cfi_to_module.cc         |   17 +
 .../breakpad/src/common/dwarf_cfi_to_module.h |    3 +
 .../src/common/linux/breakpad_getcontext.S    |   53 +
 .../linux/breakpad_getcontext_unittest.cc     |   10 +
 .../breakpad/src/common/linux/dump_symbols.cc |    9 +
 .../src/common/linux/memory_mapped_file.cc    |    2 +-
 .../linux/memory_mapped_file_unittest.cc      |    6 +-
 .../src/common/linux/ucontext_constants.h     |   10 +
 .../src/common/memory_allocator_unittest.cc   |    8 +-
 .../common/minidump_cpu_loong64.h             |  128 +
 .../google_breakpad/common/minidump_format.h  |    2 +
 .../google_breakpad/processor/dump_context.h  |    3 +
 .../src/google_breakpad/processor/microdump.h |    1 +
 .../processor/stack_frame_cpu.h               |   63 +
 .../breakpad/src/processor/dump_context.cc    |   47 +
 .../src/processor/exploitability_linux.cc     |    1 +
 .../src/processor/exploitability_unittest.cc  |    5 +
 .../breakpad/src/processor/microdump.cc       |   17 +
 .../breakpad/src/processor/minidump.cc        |   61 +
 .../src/processor/minidump_processor.cc       |    5 +
 .../breakpad/src/processor/stackwalker.cc     |    8 +
 .../src/processor/stackwalker_loong64.cc      |  237 +
 .../src/processor/stackwalker_loong64.h       |   86 +
 .../processor/stackwalker_loong64_unittest.cc |    1 +
 .../tools/linux/md2core/minidump-2-core.cc    |   33 +-
 .../crashpad/client/crashpad_client_linux.cc  |    4 +
 .../minidump/minidump_misc_info_writer.cc     |    2 +
 .../crashpad/snapshot/capture_memory.cc       |    2 +-
 .../crashpad/snapshot/cpu_architecture.h      |    5 +-
 .../crashpad/crashpad/snapshot/cpu_context.h  |   23 +
 .../snapshot/linux/cpu_context_linux.h        |   18 +-
 .../linux/exception_snapshot_linux.cc         |   56 +-
 .../snapshot/linux/exception_snapshot_linux.h |    2 +
 .../snapshot/linux/process_reader_linux.cc    |    3 +
 .../crashpad/snapshot/linux/signal_context.h  |   92 +
 .../snapshot/linux/system_snapshot_linux.cc   |    7 +
 .../snapshot/linux/thread_snapshot_linux.cc   |    2 +
 .../snapshot/linux/thread_snapshot_linux.h    |    2 +
 .../crashpad/crashpad/util/linux/ptracer.cc   |    9 +-
 .../crashpad/util/linux/thread_info.h         |   14 +-
 .../util/net/http_transport_libcurl.cc        |    2 +
 .../dav1d/config/linux/loong64/config.h       |   22 +
 third_party/dawn/src/common/Platform.h        |    2 +-
 .../ffmpeg/chromium/scripts/build_ffmpeg.py   |   34 +-
 .../ffmpeg/chromium/scripts/copy_config.sh    |    2 +-
 .../ffmpeg/chromium/scripts/generate_gn.py    |    2 +-
 third_party/libvpx/BUILD.gn                   |    2 +
 .../source/config/linux/loong64/vp8_rtcd.h    |  357 ++
 .../source/config/linux/loong64/vp9_rtcd.h    |  275 ++
 .../config/linux/loong64/vpx_config.asm       |   98 +
 .../source/config/linux/loong64/vpx_config.c  |   10 +
 .../source/config/linux/loong64/vpx_config.h  |  107 +
 .../config/linux/loong64/vpx_dsp_rtcd.h       | 3868 +++++++++++++++++
 .../config/linux/loong64/vpx_scale_rtcd.h     |   96 +
 third_party/lss/linux_syscall_support.h       |  167 +-
 .../page_allocator_constants.h                |    2 +-
 .../partition_alloc_constants.h               |    2 +-
 third_party/pffft/BUILD.gn                    |    2 +-
 .../third_party/llvm-10.0/BUILD.gn            |    2 +
 .../swiftshader/third_party/marl/BUILD.gn     |    6 +
 .../third_party/marl/CMakeLists.txt           |    2 +
 .../swiftshader/third_party/marl/README.md    |    2 +-
 .../third_party/marl/src/osfiber_asm.h        |    2 +
 .../marl/src/osfiber_asm_loong64.S            |   86 +
 .../marl/src/osfiber_asm_loong64.h            |  117 +
 .../third_party/marl/src/osfiber_loong64.c    |   39 +
 .../tcmalloc/chromium/src/base/basictypes.h   |    2 +
 .../chromium/src/base/linux_syscall_support.h |  151 +-
 .../tcmalloc/chromium/src/base/linuxthreads.h |    2 +-
 third_party/tcmalloc/chromium/src/common.h    |    2 +-
 .../chromium/src/malloc_hook_mmap_linux.h     |    2 +-
 third_party/tcmalloc/chromium/src/tcmalloc.cc |    3 +-
 .../vendor/src/malloc_hook_mmap_linux.h       |    2 +-
 .../modules/desktop_capture/differ_block.cc   |    4 +-
 third_party/webrtc/rtc_base/system/arch.h     |    4 +
 ui/gfx/linux/drm_util_linux.cc                |    7 +
 146 files changed, 8141 insertions(+), 155 deletions(-)
 create mode 100755 build/cross-build.sh
 create mode 100644 sandbox/linux/system_headers/loong64_linux_syscalls.h
 create mode 100644 third_party/breakpad/breakpad/src/google_breakpad/common/minidump_cpu_loong64.h
 create mode 100644 third_party/breakpad/breakpad/src/processor/stackwalker_loong64.cc
 create mode 100644 third_party/breakpad/breakpad/src/processor/stackwalker_loong64.h
 create mode 100644 third_party/breakpad/breakpad/src/processor/stackwalker_loong64_unittest.cc
 create mode 100644 third_party/dav1d/config/linux/loong64/config.h
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vp8_rtcd.h
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vp9_rtcd.h
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vpx_config.asm
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vpx_config.c
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vpx_config.h
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vpx_dsp_rtcd.h
 create mode 100644 third_party/libvpx/source/config/linux/loong64/vpx_scale_rtcd.h
 create mode 100644 third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.S
 create mode 100644 third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.h
 create mode 100644 third_party/swiftshader/third_party/marl/src/osfiber_loong64.c

diff --git a/base/allocator/BUILD.gn b/base/allocator/BUILD.gn
index 696c72aa80..0dc4b9ead7 100644
--- a/base/allocator/BUILD.gn
+++ b/base/allocator/BUILD.gn
@@ -190,7 +190,7 @@ if (use_allocator == "tcmalloc") {
     }
 
     # Not included on mips64el.
-    if (current_cpu == "mips64el") {
+    if (current_cpu == "mips64el" || current_cpu == "loong64") {
       sources -= [
         "$tcmalloc_dir/src/base/linuxthreads.cc",
         "$tcmalloc_dir/src/base/linuxthreads.h",
diff --git a/base/allocator/partition_allocator/page_allocator_constants.h b/base/allocator/partition_allocator/page_allocator_constants.h
index bfd5753a4e..c731c6cd32 100644
--- a/base/allocator/partition_allocator/page_allocator_constants.h
+++ b/base/allocator/partition_allocator/page_allocator_constants.h
@@ -46,7 +46,7 @@ PageAllocationGranularityShift() {
   // compiled for 64kB are likely to work on 4kB systems, 64kB is a good choice
   // here.
   return 16;  // 64kB
-#elif defined(_MIPS_ARCH_LOONGSON)
+#elif defined(_MIPS_ARCH_LOONGSON) || defined(ARCH_CPU_LOONG64)
   return 14;  // 16kB
 #elif defined(OS_APPLE) && defined(ARCH_CPU_64_BITS)
   return vm_page_shift;
diff --git a/base/allocator/partition_allocator/partition_alloc_constants.h b/base/allocator/partition_allocator/partition_alloc_constants.h
index 2cd2656412..144cc58e3d 100644
--- a/base/allocator/partition_allocator/partition_alloc_constants.h
+++ b/base/allocator/partition_allocator/partition_alloc_constants.h
@@ -49,7 +49,7 @@ constexpr size_t kPartitionCachelineSize = 64;
 // other constant values, we pack _all_ `PartitionRoot::Alloc` sizes perfectly
 // up against the end of a system page.
 
-#if defined(_MIPS_ARCH_LOONGSON)
+#if defined(_MIPS_ARCH_LOONGSON) || defined(ARCH_CPU_LOONG64)
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE size_t
 PartitionPageShift() {
   return 16;  // 64 KiB
diff --git a/base/process/launch_posix.cc b/base/process/launch_posix.cc
index 08f3004a30..66d581fcdf 100644
--- a/base/process/launch_posix.cc
+++ b/base/process/launch_posix.cc
@@ -707,7 +707,7 @@ NOINLINE pid_t CloneAndLongjmpInChild(unsigned long flags,
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) ||   \
     defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_S390_FAMILY) || \
-    defined(ARCH_CPU_PPC64_FAMILY)
+    defined(ARCH_CPU_PPC64_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff --git a/base/system/sys_info.cc b/base/system/sys_info.cc
index ece9da8eb8..b05c0d983e 100644
--- a/base/system/sys_info.cc
+++ b/base/system/sys_info.cc
@@ -130,6 +130,8 @@ std::string SysInfo::ProcessCPUArchitecture() {
   return "ARM";
 #elif defined(ARCH_CPU_ARM64)
   return "ARM_64";
+#elif defined(ARCH_CPU_LOONG64)
+  return "LOONGARCH_64";
 #else
   return std::string();
 #endif
diff --git a/base/third_party/double_conversion/double-conversion/utils.h b/base/third_party/double_conversion/double-conversion/utils.h
index 471c3da84c..81136b11b3 100644
--- a/base/third_party/double_conversion/double-conversion/utils.h
+++ b/base/third_party/double_conversion/double-conversion/utils.h
@@ -100,6 +100,7 @@ int main(int argc, char** argv) {
     defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || defined(_M_ARM64) || \
     defined(__hppa__) || defined(__ia64__) || \
     defined(__mips__) || \
+    defined(__loongarch__) || \
     defined(__nios2__) || \
     defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \
     defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \
diff --git a/build/build_config.h b/build/build_config.h
index a39aea5569..0854e46c14 100644
--- a/build/build_config.h
+++ b/build/build_config.h
@@ -22,13 +22,14 @@
 //  Processor:
 //    ARCH_CPU_ARM64 / ARCH_CPU_ARMEL / ARCH_CPU_MIPS / ARCH_CPU_MIPS64 /
 //    ARCH_CPU_MIPS64EL / ARCH_CPU_MIPSEL / ARCH_CPU_PPC64 / ARCH_CPU_S390 /
-//    ARCH_CPU_S390X / ARCH_CPU_X86 / ARCH_CPU_X86_64
+//    ARCH_CPU_S390X / ARCH_CPU_X86 / ARCH_CPU_X86_64 / ARCH_CPU_LOONG64
 //  Processor family:
 //    ARCH_CPU_ARM_FAMILY: ARMEL or ARM64
 //    ARCH_CPU_MIPS_FAMILY: MIPS64EL or MIPSEL or MIPS64 or MIPS
 //    ARCH_CPU_PPC64_FAMILY: PPC64
 //    ARCH_CPU_S390_FAMILY: S390 or S390X
 //    ARCH_CPU_X86_FAMILY: X86 or X86_64
+//    ARCH_CPU_LOONG64_FAMILY: LOONG64
 //  Processor features:
 //    ARCH_CPU_31_BITS / ARCH_CPU_32_BITS / ARCH_CPU_64_BITS
 //    ARCH_CPU_BIG_ENDIAN / ARCH_CPU_LITTLE_ENDIAN
@@ -192,6 +193,11 @@
 #define ARCH_CPU_32_BITS 1
 #define ARCH_CPU_BIG_ENDIAN 1
 #endif
+#elif defined(__loongarch64)
+#define ARCH_CPU_LOONG_FAMILY 1
+#define ARCH_CPU_LOONG64 1
+#define ARCH_CPU_64_BITS 1
+#define ARCH_CPU_LITTLE_ENDIAN 1
 #else
 #error Please add support for your architecture in build/build_config.h
 #endif
diff --git a/build/config/clang/clang.gni b/build/config/clang/clang.gni
index 1e66218487..576041f7d6 100644
--- a/build/config/clang/clang.gni
+++ b/build/config/clang/clang.gni
@@ -4,7 +4,11 @@
 
 import("//build/toolchain/toolchain.gni")
 
-default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+if (current_cpu == "loong64") {
+  default_clang_base_path = "/opt/llvm_chromium/llvm_install_15.0.7"
+} else {
+  default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+}
 
 declare_args() {
   # Indicates if the build should use the Chrome-specific plugins for enforcing
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index 8048ec5e84..bef49ee10f 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -925,6 +925,12 @@ config("compiler_cpu_abi") {
         # Outline atomics crash on Exynos 9810. http://crbug.com/1272795
         cflags += [ "-mno-outline-atomics" ]
       }
+    } else if (current_cpu == "loong64") {
+      cflags += [ "-mcmodel=large" ]
+      if (is_clang && !is_android && !is_nacl && !is_fuchsia) {
+        cflags += [ "--target=loongarch64-linux-gnu" ]
+        ldflags += [ "--target=loongarch64-linux-gnu" ]
+      }
     } else if (current_cpu == "mipsel" && !is_nacl) {
       ldflags += [ "-Wl,--hash-style=sysv" ]
       if (custom_toolchain == "") {
diff --git a/build/config/posix/BUILD.gn b/build/config/posix/BUILD.gn
index 5d15163875..4eb697b58c 100644
--- a/build/config/posix/BUILD.gn
+++ b/build/config/posix/BUILD.gn
@@ -28,7 +28,7 @@ config("runtime_library") {
   if (!is_apple && sysroot != "" && current_os != "zos") {
     # Pass the sysroot to all C compiler variants, the assembler, and linker.
     sysroot_flags = [ "--sysroot=" + rebase_path(sysroot, root_build_dir) ]
-    if (is_linux || is_chromeos) {
+    if ((is_linux && current_cpu != "loong64") || is_chromeos) {
       # This is here so that all files get recompiled after a sysroot roll and
       # when turning the sysroot on or off. (defines are passed via the command
       # line, and build system rebuilds things when their commandline
diff --git a/build/config/sysroot.gni b/build/config/sysroot.gni
index 18d2d57362..6c37b4050b 100644
--- a/build/config/sysroot.gni
+++ b/build/config/sysroot.gni
@@ -23,7 +23,8 @@ declare_args() {
   # is empty, default sysroot is calculated.
   use_sysroot = current_cpu == "x86" || current_cpu == "x64" ||
                 current_cpu == "arm" || current_cpu == "arm64" ||
-                current_cpu == "mipsel" || current_cpu == "mips64el"
+                current_cpu == "mipsel" || current_cpu == "mips64el" ||
+                current_cpu == "loong64"
 }
 
 if (sysroot == "") {
@@ -50,6 +51,8 @@ if (sysroot == "") {
       sysroot = "$target_sysroot_dir/debian_sid_arm-sysroot"
     } else if (current_cpu == "arm64") {
       sysroot = "$target_sysroot_dir/debian_sid_arm64-sysroot"
+    } else if (current_cpu == "loong64") {
+      sysroot = "$target_sysroot_dir/debian_sid_loong64-sysroot"
     } else {
       assert(false, "No linux sysroot for cpu: $target_cpu")
     }
diff --git a/build/cross-build.sh b/build/cross-build.sh
new file mode 100755
index 0000000000..ad4be84639
--- /dev/null
+++ b/build/cross-build.sh
@@ -0,0 +1,45 @@
+#! /bin/bash
+
+# Chromium build configuration description.
+# Author: Wang Qing <wangqing-hf@loongson.cn>
+
+# Set gn args to build.
+export GN_CONFIG=(
+'google_api_key="AIzaSyDxKL42zsPjbke5O8_rPVpVrLrJ8aeE9rQ"'
+'google_default_client_id="595013732528-llk8trb03f0ldpqq6nprjp1s79596646.apps.googleusercontent.com"'
+'google_default_client_secret="5ntt6GbbkjnTVXx-MSxbmx5e"'
+'enable_hangout_services_extension=true'
+'enable_nacl=false'
+'enable_swiftshader=false'
+'angle_enable_swiftshader=false'
+'enable_swiftshader_vulkan=false'
+'enable_widevine=false'
+'fatal_linker_warnings=false'
+'disable_fieldtrial_testing_config=true'
+'ffmpeg_branding="Chrome"'
+'is_debug=false'
+'use_gold=false'
+'is_clang=true'
+'clang_use_chrome_plugins=false'
+'link_pulseaudio=true'
+'proprietary_codecs=true'
+'symbol_level=0'
+'treat_warnings_as_errors=false'
+'use_allocator="partition"'
+'use_cups=true'
+'use_gnome_keyring=false'
+'use_kerberos=true'
+'use_pulseaudio=true'
+'use_sysroot=true'
+'rtc_include_dav1d_in_internal_decoder_factory=false'
+'host_cpu = "x64"'
+'target_cpu = "loong64"'
+'v8_target_cpu = "loong64"'
+'rtc_use_pipewire=false'
+'enable_libaom=false')
+
+# Set build directory.
+root_build_dir="out/la64_cross"
+
+# generate root_build_dir to build.
+./buildtools/linux64/gn gen $root_build_dir --args="${GN_CONFIG[*]}"
diff --git a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
index 474b16ede4..1143a9921e 100644
--- a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
+++ b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
@@ -305,6 +305,8 @@ bool ChromeRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->arch = extensions::api::runtime::PLATFORM_ARCH_MIPS;
   } else if (strcmp(arch, "mips64el") == 0) {
     info->arch = extensions::api::runtime::PLATFORM_ARCH_MIPS64;
+  } else if (strcmp(arch, "loong64") == 0) {
+    info->arch = extensions::api::runtime::PLATFORM_ARCH_LOONG64;
   } else {
     NOTREACHED();
     return false;
diff --git a/chrome/installer/linux/BUILD.gn b/chrome/installer/linux/BUILD.gn
index 4ab8f6b60d..d0e19f7fe6 100644
--- a/chrome/installer/linux/BUILD.gn
+++ b/chrome/installer/linux/BUILD.gn
@@ -96,13 +96,15 @@ copy("swiftshader_libs") {
 # TODO(mmoss) Any convenient way to get all the relevant build files?
 # (e.g. all locales, resources, etc.)
 packaging_files = packaging_files_binaries + [
-                    "$root_out_dir/vk_swiftshader_icd.json",
                     "$root_out_dir/xdg-mime",
                     "$root_out_dir/xdg-settings",
                     "$root_out_dir/locales/en-US.pak",
                     "$root_out_dir/MEIPreload/manifest.json",
                     "$root_out_dir/MEIPreload/preloaded_data.pb",
                   ]
+if (enable_swiftshader) {
+  packaging_files += [ "$root_out_dir/vk_swiftshader_icd.json" ]
+}
 
 action_foreach("calculate_deb_dependencies") {
   deps = [ ":installer_deps" ]
@@ -453,6 +455,8 @@ template("linux_package") {
       deb_arch = "mipsel"
     } else if (current_cpu == "mips64el") {
       deb_arch = "mips64el"
+    } else if (current_cpu == "loong64") {
+      deb_arch = "loongarch64"
     } else {
       assert(false, "Linux installer not configured for this architecture.")
     }
@@ -502,6 +506,8 @@ template("linux_package") {
         rpm_arch = "mipsel"
       } else if (current_cpu == "mips64el") {
         rpm_arch = "mips64el"
+      } else if (current_cpu == "loong64") {
+        rpm_arch = "loongarch64"
       } else {
         assert(false, "Linux installer not configured for this architecture.")
       }
@@ -555,6 +561,8 @@ template("linux_package") {
           snap_arch = "armhf"
         } else if (current_cpu == "arm64") {
           snap_arch = "arm64"
+        } else if (current_cpu == "loong64") {
+          snap_arch = "loongarch64"
         } else {
           assert(false, "Linux installer not configured for this architecture.")
         }
diff --git a/chrome/installer/linux/common/apt.include b/chrome/installer/linux/common/apt.include
index a9bfd7692b..5ddb943e4e 100644
--- a/chrome/installer/linux/common/apt.include
+++ b/chrome/installer/linux/common/apt.include
@@ -335,6 +335,8 @@ get_lib_dir() {
     LIBDIR=lib/mipsel-linux-gnu
   elif [ "$DEFAULT_ARCH" = "mips64el" ]; then
     LIBDIR=lib/mips64el-linux-gnuabi64
+  elif [ "$DEFAULT_ARCH" = "loongarch64" ]; then
+    LIBDIR=lib/loongarch64-linux-gnu
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
     exit 1
diff --git a/chrome/installer/linux/common/rpm.include b/chrome/installer/linux/common/rpm.include
index 4931afeaee..4ed941d1c2 100644
--- a/chrome/installer/linux/common/rpm.include
+++ b/chrome/installer/linux/common/rpm.include
@@ -439,7 +439,7 @@ get_lib_dir() {
       [ "$DEFAULT_ARCH" = "mipsel" ]; then
     LIBDIR=lib
   elif [ "$DEFAULT_ARCH" = "x86_64" ] || [ "$DEFAULT_ARCH" = "aarch64" ] || \
-        [ "$DEFAULT_ARCH" = "mips64el" ]; then
+        [ "$DEFAULT_ARCH" = "mips64el" ] || [ "$DEFAULT_ARCH" = "loongarch64" ]; then
     LIBDIR=lib64
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
diff --git a/chrome/installer/linux/debian/build.sh b/chrome/installer/linux/debian/build.sh
index 67c0de84ef..a47f847627 100755
--- a/chrome/installer/linux/debian/build.sh
+++ b/chrome/installer/linux/debian/build.sh
@@ -225,7 +225,7 @@ OUTPUTDIR="${PWD}"
 # call cleanup() on exit
 trap cleanup 0
 process_opts "$@"
-IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=0}
+IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=1}
 
 STAGEDIR="${OUTPUTDIR}/deb-staging-${CHANNEL}"
 mkdir -p "${STAGEDIR}"
diff --git a/chrome/installer/linux/debian/calculate_package_deps.py b/chrome/installer/linux/debian/calculate_package_deps.py
index eeedf457b9..3356afef5d 100755
--- a/chrome/installer/linux/debian/calculate_package_deps.py
+++ b/chrome/installer/linux/debian/calculate_package_deps.py
@@ -56,6 +56,9 @@ elif arch == 'mipsel':
 elif arch == 'mips64el':
   cmd.extend(['-l%s/usr/lib/mips64el-linux-gnuabi64' % sysroot,
               '-l%s/lib/mips64el-linux-gnuabi64' % sysroot])
+elif arch == 'loong64':
+  cmd.extend(['-l%s/usr/lib/loongarch64-linux-gnu' % sysroot,
+              '-l%s/lib/loongarch64-linux-gnu' % sysroot])
 else:
   print('Unsupported architecture ' + arch)
   sys.exit(1)
diff --git a/chrome/installer/linux/rpm/build.sh b/chrome/installer/linux/rpm/build.sh
index 2fddfa2605..08c7788df6 100755
--- a/chrome/installer/linux/rpm/build.sh
+++ b/chrome/installer/linux/rpm/build.sh
@@ -212,7 +212,7 @@ OUTPUTDIR="${PWD}"
 trap cleanup 0
 process_opts "$@"
 export ARCHITECTURE="${ARCHITECTURE}"
-IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=0}
+IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=1}
 
 STAGEDIR="${OUTPUTDIR}/rpm-staging-${CHANNEL}"
 mkdir -p "${STAGEDIR}"
diff --git a/components/update_client/update_query_params.cc b/components/update_client/update_query_params.cc
index 6b1d502f3d..4bcf7e6fae 100644
--- a/components/update_client/update_query_params.cc
+++ b/components/update_client/update_query_params.cc
@@ -59,6 +59,8 @@ const char kArch[] =
     "mipsel";
 #elif defined(__powerpc64__)
     "ppc64";
+#elif defined(__loongarch64)
+    "loong64";
 #else
 #error "unknown arch"
 #endif
@@ -130,6 +132,8 @@ const char* UpdateQueryParams::GetNaclArch() {
   return "mips64";
 #elif defined(ARCH_CPU_PPC64)
   return "ppc64";
+#elif defined(ARCH_CPU_LOONG64)
+  return "loong64";
 #else
 // NOTE: when adding new values here, please remember to update the
 // comment in the .h file about possible return values from this function.
diff --git a/components/variations/proto/study.proto b/components/variations/proto/study.proto
index b39cd71ce2..fe82a822c6 100644
--- a/components/variations/proto/study.proto
+++ b/components/variations/proto/study.proto
@@ -258,6 +258,8 @@ message Study {
     // A Mac-only value, indicating an x86-64 binary running on an arm64 host
     // via "Rosetta 2" binary translation.
     TRANSLATED_X86_64 = 4;
+
+    LOONGARCH64 = 5;
   }
 
   // Enum to pass as optional bool.
diff --git a/components/variations/service/variations_field_trial_creator.cc b/components/variations/service/variations_field_trial_creator.cc
index 86461fd574..3086bb7d60 100644
--- a/components/variations/service/variations_field_trial_creator.cc
+++ b/components/variations/service/variations_field_trial_creator.cc
@@ -124,6 +124,8 @@ RestrictionPolicy GetVariationPolicyRestriction(PrefService* local_state) {
 
 Study::CpuArchitecture GetCurrentCpuArchitecture() {
   std::string process_arch = base::SysInfo::ProcessCPUArchitecture();
+  if (process_arch == "LOONGARCH_64")
+    return Study::LOONGARCH64;
   if (process_arch == "ARM_64")
     return Study::ARM64;
   if (process_arch == "ARM")
diff --git a/extensions/common/api/runtime.json b/extensions/common/api/runtime.json
index f5902a2bb1..3fd9ad9ea8 100644
--- a/extensions/common/api/runtime.json
+++ b/extensions/common/api/runtime.json
@@ -82,14 +82,14 @@
       {
         "id": "PlatformArch",
         "type": "string",
-        "enum": ["arm", "arm64", "x86-32", "x86-64", "mips", "mips64"],
+        "enum": ["arm", "arm64", "x86-32", "x86-64", "mips", "mips64", "loong64"],
         "description": "The machine's processor architecture."
       },
       {
         "id": "PlatformNaclArch",
         "description": "The native client architecture. This may be different from arch on some platforms.",
         "type": "string",
-        "enum": ["arm", "x86-32", "x86-64", "mips", "mips64"]
+        "enum": ["arm", "x86-32", "x86-64", "mips", "mips64", "loong64"]
       },
       {
         "id": "PlatformInfo",
diff --git a/sandbox/features.gni b/sandbox/features.gni
index ad067ada52..bc0cc30525 100644
--- a/sandbox/features.gni
+++ b/sandbox/features.gni
@@ -9,7 +9,8 @@
 use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
-                   current_cpu == "mipsel" || current_cpu == "mips64el")
+                   current_cpu == "mipsel" || current_cpu == "mips64el" ||
+                   current_cpu == "loong64")
 
 # SSBD (Speculative Store Bypass Disable) is a mitigation of Spectre Variant 4.
 # As Spectre Variant 4 can be mitigated by site isolation, opt-out SSBD on site
diff --git a/sandbox/linux/BUILD.gn b/sandbox/linux/BUILD.gn
index abbcc50969..238117ff08 100644
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -386,6 +386,7 @@ source_set("sandbox_services_headers") {
     "system_headers/linux_stat.h",
     "system_headers/linux_syscalls.h",
     "system_headers/linux_time.h",
+    "system_headers/loong64_linux_syscalls.h",
     "system_headers/mips64_linux_syscalls.h",
     "system_headers/mips_linux_syscalls.h",
     "system_headers/x86_32_linux_syscalls.h",
diff --git a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
index 313511f22e..6323ff4cd1 100644
--- a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
+++ b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
@@ -56,6 +56,13 @@
 #define MAX_PUBLIC_SYSCALL __NR_syscalls
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__loongarch64)
+
+#include <asm-generic/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL __NR_syscalls
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff --git a/sandbox/linux/bpf_dsl/seccomp_macros.h b/sandbox/linux/bpf_dsl/seccomp_macros.h
index 961a8cf752..e0557d405c 100644
--- a/sandbox/linux/bpf_dsl/seccomp_macros.h
+++ b/sandbox/linux/bpf_dsl/seccomp_macros.h
@@ -343,6 +343,48 @@ struct regs_struct {
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+
+#elif defined(__loongarch64)
+struct regs_struct {
+  uint64_t regs[32];
+  uint64_t pc;
+};
+
+#define SECCOMP_ARCH AUDIT_ARCH_LOONGARCH64
+
+#define SECCOMP_REG(_ctx, _reg) ((_ctx)->uc_mcontext.__gregs[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 11)
+#define SECCOMP_IP(_ctx) (_ctx)->uc_mcontext.__pc
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 8)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 9)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).regs[4]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).regs[11]
+#define SECCOMP_PT_IP(_regs) (_regs).pc
+#define SECCOMP_PT_PARM1(_regs) (_regs).regs[4]
+#define SECCOMP_PT_PARM2(_regs) (_regs).regs[5]
+#define SECCOMP_PT_PARM3(_regs) (_regs).regs[6]
+#define SECCOMP_PT_PARM4(_regs) (_regs).regs[7]
+#define SECCOMP_PT_PARM5(_regs) (_regs).regs[8]
+#define SECCOMP_PT_PARM6(_regs) (_regs).regs[9]
+
 #else
 #error Unsupported target platform
 
diff --git a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
index 61298af943..303aa79cbb 100644
--- a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
+++ b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
@@ -1960,7 +1960,8 @@ BPF_TEST_C(SandboxBPF, PthreadBitMask, PthreadPolicyBitMask) {
 //
 // Depending on the architecture, this may modify regs, so the caller is
 // responsible for committing these changes using PTRACE_SETREGS.
-#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__) && \
+    !defined(__loongarch__)
 long SetSyscall(pid_t pid, regs_struct* regs, int syscall_number) {
 #if defined(__arm__)
   // On ARM, the syscall is changed using PTRACE_SET_SYSCALL.  We cannot use the
@@ -2000,7 +2001,7 @@ SANDBOX_TEST(SandboxBPF, DISABLE_ON_TSAN(SeccompRetTrace)) {
 // See https://code.google.com/p/chromium/issues/detail?id=383977
 #if defined(__arm__) || defined(__aarch64__)
   printf("This test is currently disabled on ARM32/64 due to a kernel bug.");
-#elif defined(__mips__)
+#elif defined(__mips__) || defined(__loongarch__)
   // TODO: Figure out how to support specificity of handling indirect syscalls
   //        in this test and enable it.
   printf("This test is currently disabled on MIPS.");
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
index f9eea2783e..65dc3f58c7 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
@@ -191,7 +191,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictFcntlCommands();
 #endif
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
   // fork() is never used as a system call (clone() is used instead), but we
   // have seen it in fallback code on Android.
   if (sysno == __NR_fork) {
@@ -246,7 +246,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch64)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -267,7 +267,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch64)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
index 2f53b8f458..6019cef077 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
@@ -246,7 +246,8 @@ BPF_TEST_C(BaselinePolicy, GetRandom, BaselinePolicy) {
 }
 
 // Not all architectures can restrict the domain for socketpair().
-#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
+    defined(__loongarch64)
 BPF_DEATH_TEST_C(BaselinePolicy,
                  SocketpairWrongDomain,
                  DEATH_SEGV_MESSAGE(GetErrorMessageContentForTests()),
@@ -255,7 +256,8 @@ BPF_DEATH_TEST_C(BaselinePolicy,
   ignore_result(socketpair(AF_INET, SOCK_STREAM, 0, sv));
   _exit(1);
 }
-#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) ||
+        // defined(__loongarch64)
 
 BPF_TEST_C(BaselinePolicy, EPERM_open, BaselinePolicy) {
   errno = 0;
@@ -319,7 +321,7 @@ TEST_BASELINE_SIGSYS(__NR_sysinfo)
 TEST_BASELINE_SIGSYS(__NR_syslog)
 TEST_BASELINE_SIGSYS(__NR_timer_create)
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
 TEST_BASELINE_SIGSYS(__NR_inotify_init)
 TEST_BASELINE_SIGSYS(__NR_vserver)
 #endif
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
index 36221d24bd..89a028e262 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
@@ -37,7 +37,7 @@
 
 #if (defined(OS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) && \
     !defined(__arm__) && !defined(__aarch64__) &&           \
-    !defined(PTRACE_GET_THREAD_AREA)
+    !defined(PTRACE_GET_THREAD_AREA) && !defined(__loongarch__)
 // Also include asm/ptrace-abi.h since ptrace.h in older libc (for instance
 // the one in Ubuntu 16.04 LTS) is missing PTRACE_GET_THREAD_AREA.
 // asm/ptrace-abi.h doesn't exist on arm32 and PTRACE_GET_THREAD_AREA isn't
@@ -437,8 +437,10 @@ ResultExpr RestrictPtrace() {
   return Switch(request)
       .CASES((
 #if !defined(__aarch64__)
-                 PTRACE_GETREGS, PTRACE_GETFPREGS, PTRACE_GET_THREAD_AREA,
-                 PTRACE_GETREGSET,
+                 PTRACE_GETREGS, PTRACE_GETFPREGS, PTRACE_GETREGSET,
+#if !defined(__loongarch64)
+                 PTRACE_GET_THREAD_AREA,
+#endif
 #endif
 #if defined(__arm__)
                  PTRACE_GETVFPREGS,
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
index b3cf6fc7e8..dc7a7f427d 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
@@ -103,7 +103,7 @@ bool SyscallSets::IsUmask(int sysno) {
 // Both EPERM and ENOENT are valid errno unless otherwise noted in comment.
 bool SyscallSets::IsFileSystem(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_access:  // EPERM not a valid errno.
     case __NR_chmod:
     case __NR_chown:
@@ -136,7 +136,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_faccessat2:
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch64)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -226,7 +226,7 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
@@ -245,7 +245,7 @@ bool SyscallSets::IsDeniedFileSystemAccessViaFd(int sysno) {
 #if defined(__i386__) || defined(__arm__)
     case __NR_fchown32:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getdents:    // EPERM not a valid errno.
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
@@ -324,7 +324,7 @@ bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
 bool SyscallSets::IsProcessGroupOrSession(int sysno) {
   switch (sysno) {
     case __NR_setpgid:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getpgrp:
 #endif
     case __NR_setsid:
@@ -358,7 +358,7 @@ bool SyscallSets::IsAllowedSignalHandling(int sysno) {
     case __NR_rt_sigqueueinfo:
     case __NR_rt_sigsuspend:
     case __NR_rt_tgsigqueueinfo:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_signalfd:
 #endif
     case __NR_signalfd4:
@@ -382,12 +382,12 @@ bool SyscallSets::IsAllowedOperationOnFd(int sysno) {
   switch (sysno) {
     case __NR_close:
     case __NR_dup:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_dup2:
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_shutdown:
 #endif
       return true;
@@ -426,7 +426,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
       return true;
     case __NR_clone:  // Should be parameter-restricted.
     case __NR_setns:  // Privileged.
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_fork:
 #endif
 #if defined(__i386__) || defined(__x86_64__)
@@ -437,7 +437,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
 #endif
     case __NR_set_tid_address:
     case __NR_unshare:
-#if !defined(__mips__) && !defined(__aarch64__)
+#if !defined(__mips__) && !defined(__aarch64__) && !defined(__loongarch__)
     case __NR_vfork:
 #endif
     default:
@@ -462,7 +462,7 @@ bool SyscallSets::IsAllowedFutex(int sysno) {
 
 bool SyscallSets::IsAllowedEpoll(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_epoll_create:
     case __NR_epoll_wait:
 #endif
@@ -483,14 +483,14 @@ bool SyscallSets::IsAllowedEpoll(int sysno) {
 
 bool SyscallSets::IsAllowedGetOrModifySocket(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_pipe:
 #endif
     case __NR_pipe2:
       return true;
     default:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_socketpair:  // We will want to inspect its argument.
 #endif
       return false;
@@ -500,7 +500,7 @@ bool SyscallSets::IsAllowedGetOrModifySocket(int sysno) {
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -554,7 +554,7 @@ bool SyscallSets::IsAllowedAddressSpaceAccess(int sysno) {
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || \
@@ -587,7 +587,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR__llseek:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_poll:
 #endif
     case __NR_ppoll:
@@ -608,7 +608,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
@@ -623,7 +623,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -672,7 +672,7 @@ bool SyscallSets::IsSeccomp(int sysno) {
 bool SyscallSets::IsAllowedBasicScheduler(int sysno) {
   switch (sysno) {
     case __NR_sched_yield:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_pause:
 #endif
     case __NR_nanosleep:
@@ -756,7 +756,7 @@ bool SyscallSets::IsNuma(int sysno) {
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -791,7 +791,7 @@ bool SyscallSets::IsGlobalProcessEnvironment(int sysno) {
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_getrlimit:
 #endif
 #if defined(__i386__) || defined(__arm__)
@@ -826,7 +826,7 @@ bool SyscallSets::IsDebug(int sysno) {
 
 bool SyscallSets::IsGlobalSystemStatus(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR__sysctl:
     case __NR_sysfs:
 #endif
@@ -844,7 +844,7 @@ bool SyscallSets::IsGlobalSystemStatus(int sysno) {
 
 bool SyscallSets::IsEventFd(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_eventfd:
 #endif
     case __NR_eventfd2:
@@ -896,7 +896,8 @@ bool SyscallSets::IsKeyManagement(int sysno) {
 }
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
 bool SyscallSets::IsSystemVSemaphores(int sysno) {
   switch (sysno) {
     case __NR_semctl:
@@ -915,7 +916,7 @@ bool SyscallSets::IsSystemVSemaphores(int sysno) {
 #endif
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__) ||                                         \
+    defined(__aarch64__) || defined(__loongarch64) ||               \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
 // These give a lot of ambient authority and bypass the setuid sandbox.
 bool SyscallSets::IsSystemVSharedMemory(int sysno) {
@@ -932,7 +933,8 @@ bool SyscallSets::IsSystemVSharedMemory(int sysno) {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
 bool SyscallSets::IsSystemVMessageQueue(int sysno) {
   switch (sysno) {
     case __NR_msgctl:
@@ -963,7 +965,8 @@ bool SyscallSets::IsSystemVIpc(int sysno) {
 
 bool SyscallSets::IsAnySystemV(int sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
 #elif defined(__i386__) || \
@@ -1000,7 +1003,7 @@ bool SyscallSets::IsAdvancedScheduler(int sysno) {
 bool SyscallSets::IsInotify(int sysno) {
   switch (sysno) {
     case __NR_inotify_add_watch:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_inotify_init:
 #endif
     case __NR_inotify_init1:
@@ -1138,7 +1141,7 @@ bool SyscallSets::IsMisc(int sysno) {
 #if defined(__x86_64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_vserver:
 #endif
       return true;
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
index 6403f45dc2..6e055e75f8 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
@@ -52,7 +52,7 @@ class SANDBOX_EXPORT SyscallSets {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -79,23 +79,27 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsAsyncIo(int sysno);
   static bool IsKeyManagement(int sysno);
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVSemaphores(int sysno);
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
     defined(__aarch64__) ||                                         \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) || \
+    defined(__loongarch__)
   // These give a lot of ambient authority and bypass the setuid sandbox.
   static bool IsSystemVSharedMemory(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVMessageQueue(int sysno);
 #endif
 
-#if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+#if defined(__i386__) ||                                            \
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__looongarch__)
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
 #endif
diff --git a/sandbox/linux/seccomp-bpf/syscall.cc b/sandbox/linux/seccomp-bpf/syscall.cc
index 2e0e810383..dcfcce72d3 100644
--- a/sandbox/linux/seccomp-bpf/syscall.cc
+++ b/sandbox/linux/seccomp-bpf/syscall.cc
@@ -18,7 +18,7 @@ namespace sandbox {
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -308,6 +308,25 @@ asm(// We need to be able to tell the kernel exactly where we made a
     "2:ret\n"
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__loongarch64)
+    ".text\n"
+    ".global SyscallAsm\n"
+    ".type SyscallAsm, %function\n"
+    "SyscallAsm:\n"
+    "bge $a0, $zero, 1f\n"
+    "la $a0, 2f\n"
+    "b 2f\n"
+    "1:ld.d $a5, $a6, 40\n"
+    "ld.d $a4, $a6, 32\n"
+    "ld.d $a3, $a6, 24\n"
+    "ld.d $a2, $a6, 16\n"
+    "ld.d $a1, $a6, 8\n"
+    "move $a7, $a0\n"
+    "ld.d $a0, $a6, 0\n"
+    // Enter the kernel
+    "syscall 0\n"
+    "2:jirl $zero, $ra, 0\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
@@ -425,6 +444,17 @@ intptr_t Syscall::Call(int nr,
     ret = inout;
   }
 
+#elif defined(__loongarch64)
+  intptr_t ret;
+  {
+    register intptr_t inout __asm__("$r4") = nr;
+    register const intptr_t* data __asm__("$r10") = args;
+    asm volatile("bl SyscallAsm\n"
+                 : "=r"(inout)
+                 : "0"(inout), "r"(data)
+                 : "memory", "$r5", "$r6", "$r7", "$r8", "$r9", "$r11", "$r1");
+    ret = inout;
+  }
 #else
 #error "Unimplemented architecture"
 #endif
diff --git a/sandbox/linux/services/credentials.cc b/sandbox/linux/services/credentials.cc
index ca6b595479..a4bea7179a 100644
--- a/sandbox/linux/services/credentials.cc
+++ b/sandbox/linux/services/credentials.cc
@@ -81,7 +81,7 @@ bool ChrootToSafeEmptyDir() {
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff --git a/sandbox/linux/services/syscall_wrappers.cc b/sandbox/linux/services/syscall_wrappers.cc
index f863cd0051..621bcb468a 100644
--- a/sandbox/linux/services/syscall_wrappers.cc
+++ b/sandbox/linux/services/syscall_wrappers.cc
@@ -61,7 +61,7 @@ long sys_clone(unsigned long flags,
 #if defined(ARCH_CPU_X86_64)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
diff --git a/sandbox/linux/syscall_broker/broker_process.cc b/sandbox/linux/syscall_broker/broker_process.cc
index 51e1e9d59c..c492280b18 100644
--- a/sandbox/linux/syscall_broker/broker_process.cc
+++ b/sandbox/linux/syscall_broker/broker_process.cc
@@ -117,44 +117,44 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
   // and are default disabled in Android. So, we should refuse to broker them
   // to be consistent with the platform's restrictions.
   switch (sysno) {
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_access:
 #endif
     case __NR_faccessat:
     case __NR_faccessat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_ACCESS);
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_mkdir:
 #endif
     case __NR_mkdirat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_MKDIR);
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_open:
 #endif
     case __NR_openat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_OPEN);
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_readlink:
 #endif
     case __NR_readlinkat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_READLINK);
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_rename:
 #endif
     case __NR_renameat:
     case __NR_renameat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RENAME);
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_rmdir:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RMDIR);
 #endif
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_stat:
     case __NR_lstat:
 #endif
@@ -164,7 +164,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
 #if defined(__NR_fstatat64)
     case __NR_fstatat64:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch64)
     case __NR_newfstatat:
 #endif
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
@@ -179,7 +179,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
 #endif
 
-#if !defined(__aarch64__) && !defined(OS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_unlink:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_UNLINK);
 #endif
diff --git a/sandbox/linux/syscall_broker/broker_process_unittest.cc b/sandbox/linux/syscall_broker/broker_process_unittest.cc
index 310d705fa2..6e4ed306a3 100644
--- a/sandbox/linux/syscall_broker/broker_process_unittest.cc
+++ b/sandbox/linux/syscall_broker/broker_process_unittest.cc
@@ -1776,12 +1776,14 @@ TEST(BrokerProcess, IsSyscallAllowed) {
         __NR_readlink
 #endif
        }},
+#if !defined(__loongarch64)
       {COMMAND_RENAME,
        {__NR_renameat,
 #if defined(__NR_rename) && !defined(OS_ANDROID)
         __NR_rename
 #endif
        }},
+#endif
       {COMMAND_UNLINK,
        {__NR_unlinkat,
 #if defined(__NR_unlink) && !defined(OS_ANDROID)
diff --git a/sandbox/linux/system_headers/linux_seccomp.h b/sandbox/linux/system_headers/linux_seccomp.h
index 7d898d8463..3b83abb4d9 100644
--- a/sandbox/linux/system_headers/linux_seccomp.h
+++ b/sandbox/linux/system_headers/linux_seccomp.h
@@ -39,6 +39,10 @@
 #define EM_AARCH64 183
 #endif
 
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH 258
+#endif
+
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
 #endif
@@ -71,6 +75,11 @@
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
 
+#ifndef AUDIT_ARCH_LOONGARCH64
+#define AUDIT_ARCH_LOONGARCH64 \
+  (EM_LOONGARCH | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
+
 // For prctl.h
 #ifndef PR_SET_SECCOMP
 #define PR_SET_SECCOMP               22
diff --git a/sandbox/linux/system_headers/linux_signal.h b/sandbox/linux/system_headers/linux_signal.h
index 74bbb8ef8c..bb2812bdda 100644
--- a/sandbox/linux/system_headers/linux_signal.h
+++ b/sandbox/linux/system_headers/linux_signal.h
@@ -13,7 +13,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
@@ -97,7 +97,9 @@ typedef siginfo_t LinuxSigInfo;
 struct LinuxSigSet {
   unsigned long sig[_NSIG_WORDS];
 };
-#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)
+// TODO:LA64 Check this _NSIG_WORDS and LinuxSigAction
+#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS) || \
+    defined(ARCH_CPU_LOONG_FAMILY)
 #if !defined(_NSIG_WORDS)
 #define _NSIG_WORDS 2
 #endif
diff --git a/sandbox/linux/system_headers/linux_stat.h b/sandbox/linux/system_headers/linux_stat.h
index 5f49a95849..e47b667c17 100644
--- a/sandbox/linux/system_headers/linux_stat.h
+++ b/sandbox/linux/system_headers/linux_stat.h
@@ -150,7 +150,7 @@ struct kernel_stat {
   int st_blocks;
   int st_pad4[14];
 };
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
 struct kernel_stat {
   unsigned long st_dev;
   unsigned long st_ino;
diff --git a/sandbox/linux/system_headers/linux_syscalls.h b/sandbox/linux/system_headers/linux_syscalls.h
index 2b78a0cc3b..d9077851f3 100644
--- a/sandbox/linux/system_headers/linux_syscalls.h
+++ b/sandbox/linux/system_headers/linux_syscalls.h
@@ -35,5 +35,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__loongarch__)
+#include "sandbox/linux/system_headers/loong64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff --git a/sandbox/linux/system_headers/loong64_linux_syscalls.h b/sandbox/linux/system_headers/loong64_linux_syscalls.h
new file mode 100644
index 0000000000..e2153fd70e
--- /dev/null
+++ b/sandbox/linux/system_headers/loong64_linux_syscalls.h
@@ -0,0 +1,1221 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
+
+#if !defined(__loongarch__)
+#error "Including header on wrong architecture"
+#endif
+#include <asm/unistd.h>
+
+#if !defined(__NR_io_setup)
+#define __NR_io_setup 0
+#endif
+
+#if !defined(__NR_io_destroy)
+#define __NR_io_destroy 1
+#endif
+
+#if !defined(__NR_io_submit)
+#define __NR_io_submit 2
+#endif
+
+#if !defined(__NR_io_cancel)
+#define __NR_io_cancel 3
+#endif
+
+#if !defined(__NR_io_getevents)
+#define __NR_io_getevents 4
+#endif
+
+#if !defined(__NR_setxattr)
+#define __NR_setxattr 5
+#endif
+
+#if !defined(__NR_lsetxattr)
+#define __NR_lsetxattr 6
+#endif
+
+#if !defined(__NR_fsetxattr)
+#define __NR_fsetxattr 7
+#endif
+
+#if !defined(__NR_getxattr)
+#define __NR_getxattr 8
+#endif
+
+#if !defined(__NR_lgetxattr)
+#define __NR_lgetxattr 9
+#endif
+
+#if !defined(__NR_fgetxattr)
+#define __NR_fgetxattr 10
+#endif
+
+#if !defined(__NR_listxattr)
+#define __NR_listxattr 11
+#endif
+
+#if !defined(__NR_llistxattr)
+#define __NR_llistxattr 12
+#endif
+
+#if !defined(__NR_flistxattr)
+#define __NR_flistxattr 13
+#endif
+
+#if !defined(__NR_removexattr)
+#define __NR_removexattr 14
+#endif
+
+#if !defined(__NR_lremovexattr)
+#define __NR_lremovexattr 15
+#endif
+
+#if !defined(__NR_fremovexattr)
+#define __NR_fremovexattr 16
+#endif
+
+#if !defined(__NR_getcwd)
+#define __NR_getcwd 17
+#endif
+
+#if !defined(__NR_lookup_dcookie)
+#define __NR_lookup_dcookie 18
+#endif
+
+#if !defined(__NR_eventfd2)
+#define __NR_eventfd2 19
+#endif
+
+#if !defined(__NR_epoll_create1)
+#define __NR_epoll_create1 20
+#endif
+
+#if !defined(__NR_epoll_ctl)
+#define __NR_epoll_ctl 21
+#endif
+
+#if !defined(__NR_epoll_pwait)
+#define __NR_epoll_pwait 22
+#endif
+
+#if !defined(__NR_dup)
+#define __NR_dup 23
+#endif
+
+#if !defined(__NR_dup3)
+#define __NR_dup3 24
+#endif
+
+#if !defined(__NR_fcntl)
+#define __NR_fcntl 25
+#endif
+
+#if !defined(__NR_inotify_init1)
+#define __NR_inotify_init1 26
+#endif
+
+#if !defined(__NR_inotify_add_watch)
+#define __NR_inotify_add_watch 27
+#endif
+
+#if !defined(__NR_inotify_rm_watch)
+#define __NR_inotify_rm_watch 28
+#endif
+
+#if !defined(__NR_ioctl)
+#define __NR_ioctl 29
+#endif
+
+#if !defined(__NR_ioprio_set)
+#define __NR_ioprio_set 30
+#endif
+
+#if !defined(__NR_ioprio_get)
+#define __NR_ioprio_get 31
+#endif
+
+#if !defined(__NR_flock)
+#define __NR_flock 32
+#endif
+
+#if !defined(__NR_mknodat)
+#define __NR_mknodat 33
+#endif
+
+#if !defined(__NR_mkdirat)
+#define __NR_mkdirat 34
+#endif
+
+#if !defined(__NR_unlinkat)
+#define __NR_unlinkat 35
+#endif
+
+#if !defined(__NR_symlinkat)
+#define __NR_symlinkat 36
+#endif
+
+#if !defined(__NR_linkat)
+#define __NR_linkat 37
+#endif
+
+#if !defined(__NR_renameat)
+#define __NR_renameat 38
+#endif
+
+#if !defined(__NR_umount2)
+#define __NR_umount2 39
+#endif
+
+#if !defined(__NR_mount)
+#define __NR_mount 40
+#endif
+
+#if !defined(__NR_pivot_root)
+#define __NR_pivot_root 41
+#endif
+
+#if !defined(__NR_nfsservctl)
+#define __NR_nfsservctl 42
+#endif
+
+#if !defined(__NR_statfs)
+#define __NR_statfs 43
+#endif
+
+#if !defined(__NR_fstatfs)
+#define __NR_fstatfs 44
+#endif
+
+#if !defined(__NR_truncate)
+#define __NR_truncate 45
+#endif
+
+#if !defined(__NR_ftruncate)
+#define __NR_ftruncate 46
+#endif
+
+#if !defined(__NR_fallocate)
+#define __NR_fallocate 47
+#endif
+
+#if !defined(__NR_faccessat)
+#define __NR_faccessat 48
+#endif
+
+#if !defined(__NR_chdir)
+#define __NR_chdir 49
+#endif
+
+#if !defined(__NR_fchdir)
+#define __NR_fchdir 50
+#endif
+
+#if !defined(__NR_chroot)
+#define __NR_chroot 51
+#endif
+
+#if !defined(__NR_fchmod)
+#define __NR_fchmod 52
+#endif
+
+#if !defined(__NR_fchmodat)
+#define __NR_fchmodat 53
+#endif
+
+#if !defined(__NR_fchownat)
+#define __NR_fchownat 54
+#endif
+
+#if !defined(__NR_fchown)
+#define __NR_fchown 55
+#endif
+
+#if !defined(__NR_openat)
+#define __NR_openat 56
+#endif
+
+#if !defined(__NR_close)
+#define __NR_close 57
+#endif
+
+#if !defined(__NR_vhangup)
+#define __NR_vhangup 58
+#endif
+
+#if !defined(__NR_pipe2)
+#define __NR_pipe2 59
+#endif
+
+#if !defined(__NR_quotactl)
+#define __NR_quotactl 60
+#endif
+
+#if !defined(__NR_getdents64)
+#define __NR_getdents64 61
+#endif
+
+#if !defined(__NR_lseek)
+#define __NR_lseek 62
+#endif
+
+#if !defined(__NR_read)
+#define __NR_read 63
+#endif
+
+#if !defined(__NR_write)
+#define __NR_write 64
+#endif
+
+#if !defined(__NR_readv)
+#define __NR_readv 65
+#endif
+
+#if !defined(__NR_writev)
+#define __NR_writev 66
+#endif
+
+#if !defined(__NR_pread64)
+#define __NR_pread64 67
+#endif
+
+#if !defined(__NR_pwrite64)
+#define __NR_pwrite64 68
+#endif
+
+#if !defined(__NR_preadv)
+#define __NR_preadv 69
+#endif
+
+#if !defined(__NR_pwritev)
+#define __NR_pwritev 70
+#endif
+
+#if !defined(__NR_sendfile)
+#define __NR_sendfile 71
+#endif
+
+#if !defined(__NR_pselect6)
+#define __NR_pselect6 72
+#endif
+
+#if !defined(__NR_ppoll)
+#define __NR_ppoll 73
+#endif
+
+#if !defined(__NR_signalfd4)
+#define __NR_signalfd4 74
+#endif
+
+#if !defined(__NR_vmsplice)
+#define __NR_vmsplice 75
+#endif
+
+#if !defined(__NR_splice)
+#define __NR_splice 76
+#endif
+
+#if !defined(__NR_tee)
+#define __NR_tee 77
+#endif
+
+#if !defined(__NR_readlinkat)
+#define __NR_readlinkat 78
+#endif
+
+#if !defined(__NR_newfstatat)
+#define __NR_newfstatat 79
+#endif
+
+#if !defined(__NR_fstat)
+#define __NR_fstat 80
+#endif
+
+#if !defined(__NR_sync)
+#define __NR_sync 81
+#endif
+
+#if !defined(__NR_fsync)
+#define __NR_fsync 82
+#endif
+
+#if !defined(__NR_fdatasync)
+#define __NR_fdatasync 83
+#endif
+
+#if !defined(__NR_sync_file_range)
+#define __NR_sync_file_range 84
+#endif
+
+#if !defined(__NR_timerfd_create)
+#define __NR_timerfd_create 85
+#endif
+
+#if !defined(__NR_timerfd_settime)
+#define __NR_timerfd_settime 86
+#endif
+
+#if !defined(__NR_timerfd_gettime)
+#define __NR_timerfd_gettime 87
+#endif
+
+#if !defined(__NR_utimensat)
+#define __NR_utimensat 88
+#endif
+
+#if !defined(__NR_acct)
+#define __NR_acct 89
+#endif
+
+#if !defined(__NR_capget)
+#define __NR_capget 90
+#endif
+
+#if !defined(__NR_capset)
+#define __NR_capset 91
+#endif
+
+#if !defined(__NR_personality)
+#define __NR_personality 92
+#endif
+
+#if !defined(__NR_exit)
+#define __NR_exit 93
+#endif
+
+#if !defined(__NR_exit_group)
+#define __NR_exit_group 94
+#endif
+
+#if !defined(__NR_waitid)
+#define __NR_waitid 95
+#endif
+
+#if !defined(__NR_set_tid_address)
+#define __NR_set_tid_address 96
+#endif
+
+#if !defined(__NR_unshare)
+#define __NR_unshare 97
+#endif
+
+#if !defined(__NR_futex)
+#define __NR_futex 98
+#endif
+
+#if !defined(__NR_set_robust_list)
+#define __NR_set_robust_list 99
+#endif
+
+#if !defined(__NR_get_robust_list)
+#define __NR_get_robust_list 100
+#endif
+
+#if !defined(__NR_nanosleep)
+#define __NR_nanosleep 101
+#endif
+
+#if !defined(__NR_getitimer)
+#define __NR_getitimer 102
+#endif
+
+#if !defined(__NR_setitimer)
+#define __NR_setitimer 103
+#endif
+
+#if !defined(__NR_kexec_load)
+#define __NR_kexec_load 104
+#endif
+
+#if !defined(__NR_init_module)
+#define __NR_init_module 105
+#endif
+
+#if !defined(__NR_delete_module)
+#define __NR_delete_module 106
+#endif
+
+#if !defined(__NR_timer_create)
+#define __NR_timer_create 107
+#endif
+
+#if !defined(__NR_timer_gettime)
+#define __NR_timer_gettime 108
+#endif
+
+#if !defined(__NR_timer_getoverrun)
+#define __NR_timer_getoverrun 109
+#endif
+
+#if !defined(__NR_timer_settime)
+#define __NR_timer_settime 110
+#endif
+
+#if !defined(__NR_timer_delete)
+#define __NR_timer_delete 111
+#endif
+
+#if !defined(__NR_clock_settime)
+#define __NR_clock_settime 112
+#endif
+
+#if !defined(__NR_clock_gettime)
+#define __NR_clock_gettime 113
+#endif
+
+#if !defined(__NR_clock_getres)
+#define __NR_clock_getres 114
+#endif
+
+#if !defined(__NR_clock_nanosleep)
+#define __NR_clock_nanosleep 115
+#endif
+
+#if !defined(__NR_syslog)
+#define __NR_syslog 116
+#endif
+
+#if !defined(__NR_ptrace)
+#define __NR_ptrace 117
+#endif
+
+#if !defined(__NR_sched_setparam)
+#define __NR_sched_setparam 118
+#endif
+
+#if !defined(__NR_sched_setscheduler)
+#define __NR_sched_setscheduler 119
+#endif
+
+#if !defined(__NR_sched_getscheduler)
+#define __NR_sched_getscheduler 120
+#endif
+
+#if !defined(__NR_sched_getparam)
+#define __NR_sched_getparam 121
+#endif
+
+#if !defined(__NR_sched_setaffinity)
+#define __NR_sched_setaffinity 122
+#endif
+
+#if !defined(__NR_sched_getaffinity)
+#define __NR_sched_getaffinity 123
+#endif
+
+#if !defined(__NR_sched_yield)
+#define __NR_sched_yield 124
+#endif
+
+#if !defined(__NR_sched_get_priority_max)
+#define __NR_sched_get_priority_max 125
+#endif
+
+#if !defined(__NR_sched_get_priority_min)
+#define __NR_sched_get_priority_min 126
+#endif
+
+#if !defined(__NR_sched_rr_get_interval)
+#define __NR_sched_rr_get_interval 127
+#endif
+
+#if !defined(__NR_restart_syscall)
+#define __NR_restart_syscall 128
+#endif
+
+#if !defined(__NR_kill)
+#define __NR_kill 129
+#endif
+
+#if !defined(__NR_tkill)
+#define __NR_tkill 130
+#endif
+
+#if !defined(__NR_tgkill)
+#define __NR_tgkill 131
+#endif
+
+#if !defined(__NR_sigaltstack)
+#define __NR_sigaltstack 132
+#endif
+
+#if !defined(__NR_rt_sigsuspend)
+#define __NR_rt_sigsuspend 133
+#endif
+
+#if !defined(__NR_rt_sigaction)
+#define __NR_rt_sigaction 134
+#endif
+
+#if !defined(__NR_rt_sigprocmask)
+#define __NR_rt_sigprocmask 135
+#endif
+
+#if !defined(__NR_rt_sigpending)
+#define __NR_rt_sigpending 136
+#endif
+
+#if !defined(__NR_rt_sigtimedwait)
+#define __NR_rt_sigtimedwait 137
+#endif
+
+#if !defined(__NR_rt_sigqueueinfo)
+#define __NR_rt_sigqueueinfo 138
+#endif
+
+#if !defined(__NR_rt_sigreturn)
+#define __NR_rt_sigreturn 139
+#endif
+
+#if !defined(__NR_setpriority)
+#define __NR_setpriority 140
+#endif
+
+#if !defined(__NR_getpriority)
+#define __NR_getpriority 141
+#endif
+
+#if !defined(__NR_reboot)
+#define __NR_reboot 142
+#endif
+
+#if !defined(__NR_setregid)
+#define __NR_setregid 143
+#endif
+
+#if !defined(__NR_setgid)
+#define __NR_setgid 144
+#endif
+
+#if !defined(__NR_setreuid)
+#define __NR_setreuid 145
+#endif
+
+#if !defined(__NR_setuid)
+#define __NR_setuid 146
+#endif
+
+#if !defined(__NR_setresuid)
+#define __NR_setresuid 147
+#endif
+
+#if !defined(__NR_getresuid)
+#define __NR_getresuid 148
+#endif
+
+#if !defined(__NR_setresgid)
+#define __NR_setresgid 149
+#endif
+
+#if !defined(__NR_getresgid)
+#define __NR_getresgid 150
+#endif
+
+#if !defined(__NR_setfsuid)
+#define __NR_setfsuid 151
+#endif
+
+#if !defined(__NR_setfsgid)
+#define __NR_setfsgid 152
+#endif
+
+#if !defined(__NR_times)
+#define __NR_times 153
+#endif
+
+#if !defined(__NR_setpgid)
+#define __NR_setpgid 154
+#endif
+
+#if !defined(__NR_getpgid)
+#define __NR_getpgid 155
+#endif
+
+#if !defined(__NR_getsid)
+#define __NR_getsid 156
+#endif
+
+#if !defined(__NR_setsid)
+#define __NR_setsid 157
+#endif
+
+#if !defined(__NR_getgroups)
+#define __NR_getgroups 158
+#endif
+
+#if !defined(__NR_setgroups)
+#define __NR_setgroups 159
+#endif
+
+#if !defined(__NR_uname)
+#define __NR_uname 160
+#endif
+
+#if !defined(__NR_sethostname)
+#define __NR_sethostname 161
+#endif
+
+#if !defined(__NR_setdomainname)
+#define __NR_setdomainname 162
+#endif
+
+#if !defined(__NR_getrlimit)
+#define __NR_getrlimit 163
+#endif
+
+#if !defined(__NR_setrlimit)
+#define __NR_setrlimit 164
+#endif
+
+#if !defined(__NR_getrusage)
+#define __NR_getrusage 165
+#endif
+
+#if !defined(__NR_umask)
+#define __NR_umask 166
+#endif
+
+#if !defined(__NR_prctl)
+#define __NR_prctl 167
+#endif
+
+#if !defined(__NR_getcpu)
+#define __NR_getcpu 168
+#endif
+
+#if !defined(__NR_gettimeofday)
+#define __NR_gettimeofday 169
+#endif
+
+#if !defined(__NR_settimeofday)
+#define __NR_settimeofday 170
+#endif
+
+#if !defined(__NR_adjtimex)
+#define __NR_adjtimex 171
+#endif
+
+#if !defined(__NR_getpid)
+#define __NR_getpid 172
+#endif
+
+#if !defined(__NR_getppid)
+#define __NR_getppid 173
+#endif
+
+#if !defined(__NR_getuid)
+#define __NR_getuid 174
+#endif
+
+#if !defined(__NR_geteuid)
+#define __NR_geteuid 175
+#endif
+
+#if !defined(__NR_getgid)
+#define __NR_getgid 176
+#endif
+
+#if !defined(__NR_getegid)
+#define __NR_getegid 177
+#endif
+
+#if !defined(__NR_gettid)
+#define __NR_gettid 178
+#endif
+
+#if !defined(__NR_sysinfo)
+#define __NR_sysinfo 179
+#endif
+
+#if !defined(__NR_mq_open)
+#define __NR_mq_open 180
+#endif
+
+#if !defined(__NR_mq_unlink)
+#define __NR_mq_unlink 181
+#endif
+
+#if !defined(__NR_mq_timedsend)
+#define __NR_mq_timedsend 182
+#endif
+
+#if !defined(__NR_mq_timedreceive)
+#define __NR_mq_timedreceive 183
+#endif
+
+#if !defined(__NR_mq_notify)
+#define __NR_mq_notify 184
+#endif
+
+#if !defined(__NR_mq_getsetattr)
+#define __NR_mq_getsetattr 185
+#endif
+
+#if !defined(__NR_msgget)
+#define __NR_msgget 186
+#endif
+
+#if !defined(__NR_msgctl)
+#define __NR_msgctl 187
+#endif
+
+#if !defined(__NR_msgrcv)
+#define __NR_msgrcv 188
+#endif
+
+#if !defined(__NR_msgsnd)
+#define __NR_msgsnd 189
+#endif
+
+#if !defined(__NR_semget)
+#define __NR_semget 190
+#endif
+
+#if !defined(__NR_semctl)
+#define __NR_semctl 191
+#endif
+
+#if !defined(__NR_semtimedop)
+#define __NR_semtimedop 192
+#endif
+
+#if !defined(__NR_semop)
+#define __NR_semop 193
+#endif
+
+#if !defined(__NR_shmget)
+#define __NR_shmget 194
+#endif
+
+#if !defined(__NR_shmctl)
+#define __NR_shmctl 195
+#endif
+
+#if !defined(__NR_shmat)
+#define __NR_shmat 196
+#endif
+
+#if !defined(__NR_shmdt)
+#define __NR_shmdt 197
+#endif
+
+#if !defined(__NR_socket)
+#define __NR_socket 198
+#endif
+
+#if !defined(__NR_socketpair)
+#define __NR_socketpair 199
+#endif
+
+#if !defined(__NR_bind)
+#define __NR_bind 200
+#endif
+
+#if !defined(__NR_listen)
+#define __NR_listen 201
+#endif
+
+#if !defined(__NR_accept)
+#define __NR_accept 202
+#endif
+
+#if !defined(__NR_connect)
+#define __NR_connect 203
+#endif
+
+#if !defined(__NR_getsockname)
+#define __NR_getsockname 204
+#endif
+
+#if !defined(__NR_getpeername)
+#define __NR_getpeername 205
+#endif
+
+#if !defined(__NR_sendto)
+#define __NR_sendto 206
+#endif
+
+#if !defined(__NR_recvfrom)
+#define __NR_recvfrom 207
+#endif
+
+#if !defined(__NR_setsockopt)
+#define __NR_setsockopt 208
+#endif
+
+#if !defined(__NR_getsockopt)
+#define __NR_getsockopt 209
+#endif
+
+#if !defined(__NR_shutdown)
+#define __NR_shutdown 210
+#endif
+
+#if !defined(__NR_sendmsg)
+#define __NR_sendmsg 211
+#endif
+
+#if !defined(__NR_recvmsg)
+#define __NR_recvmsg 212
+#endif
+
+#if !defined(__NR_readahead)
+#define __NR_readahead 213
+#endif
+
+#if !defined(__NR_brk)
+#define __NR_brk 214
+#endif
+
+#if !defined(__NR_munmap)
+#define __NR_munmap 215
+#endif
+
+#if !defined(__NR_mremap)
+#define __NR_mremap 216
+#endif
+
+#if !defined(__NR_add_key)
+#define __NR_add_key 217
+#endif
+
+#if !defined(__NR_request_key)
+#define __NR_request_key 218
+#endif
+
+#if !defined(__NR_keyctl)
+#define __NR_keyctl 219
+#endif
+
+#if !defined(__NR_clone)
+#define __NR_clone 220
+#endif
+
+#if !defined(__NR_execve)
+#define __NR_execve 221
+#endif
+
+#if !defined(__NR_mmap)
+#define __NR_mmap 222
+#endif
+
+#if !defined(__NR_fadvise64)
+#define __NR_fadvise64 223
+#endif
+
+#if !defined(__NR_swapon)
+#define __NR_swapon 224
+#endif
+
+#if !defined(__NR_swapoff)
+#define __NR_swapoff 225
+#endif
+
+#if !defined(__NR_mprotect)
+#define __NR_mprotect 226
+#endif
+
+#if !defined(__NR_msync)
+#define __NR_msync 227
+#endif
+
+#if !defined(__NR_mlock)
+#define __NR_mlock 228
+#endif
+
+#if !defined(__NR_munlock)
+#define __NR_munlock 229
+#endif
+
+#if !defined(__NR_mlockall)
+#define __NR_mlockall 230
+#endif
+
+#if !defined(__NR_munlockall)
+#define __NR_munlockall 231
+#endif
+
+#if !defined(__NR_mincore)
+#define __NR_mincore 232
+#endif
+
+#if !defined(__NR_madvise)
+#define __NR_madvise 233
+#endif
+
+#if !defined(__NR_remap_file_pages)
+#define __NR_remap_file_pages 234
+#endif
+
+#if !defined(__NR_mbind)
+#define __NR_mbind 235
+#endif
+
+#if !defined(__NR_get_mempolicy)
+#define __NR_get_mempolicy 236
+#endif
+
+#if !defined(__NR_set_mempolicy)
+#define __NR_set_mempolicy 237
+#endif
+
+#if !defined(__NR_migrate_pages)
+#define __NR_migrate_pages 238
+#endif
+
+#if !defined(__NR_move_pages)
+#define __NR_move_pages 239
+#endif
+
+#if !defined(__NR_rt_tgsigqueueinfo)
+#define __NR_rt_tgsigqueueinfo 240
+#endif
+
+#if !defined(__NR_perf_event_open)
+#define __NR_perf_event_open 241
+#endif
+
+#if !defined(__NR_accept4)
+#define __NR_accept4 242
+#endif
+
+#if !defined(__NR_recvmmsg)
+#define __NR_recvmmsg 243
+#endif
+
+#if !defined(__NR_wait4)
+#define __NR_wait4 260
+#endif
+
+#if !defined(__NR_prlimit64)
+#define __NR_prlimit64 261
+#endif
+
+#if !defined(__NR_fanotify_init)
+#define __NR_fanotify_init 262
+#endif
+
+#if !defined(__NR_fanotify_mark)
+#define __NR_fanotify_mark 263
+#endif
+
+#if !defined(__NR_name_to_handle_at)
+#define __NR_name_to_handle_at 264
+#endif
+
+#if !defined(__NR_open_by_handle_at)
+#define __NR_open_by_handle_at 265
+#endif
+
+#if !defined(__NR_clock_adjtime)
+#define __NR_clock_adjtime 266
+#endif
+
+#if !defined(__NR_syncfs)
+#define __NR_syncfs 267
+#endif
+
+#if !defined(__NR_setns)
+#define __NR_setns 268
+#endif
+
+#if !defined(__NR_sendmmsg)
+#define __NR_sendmmsg 269
+#endif
+
+#if !defined(__NR_process_vm_readv)
+#define __NR_process_vm_readv 270
+#endif
+
+#if !defined(__NR_process_vm_writev)
+#define __NR_process_vm_writev 271
+#endif
+
+#if !defined(__NR_kcmp)
+#define __NR_kcmp 272
+#endif
+
+#if !defined(__NR_finit_module)
+#define __NR_finit_module 273
+#endif
+
+#if !defined(__NR_sched_setattr)
+#define __NR_sched_setattr 274
+#endif
+
+#if !defined(__NR_sched_getattr)
+#define __NR_sched_getattr 275
+#endif
+
+#if !defined(__NR_renameat2)
+#define __NR_renameat2 276
+#endif
+
+#if !defined(__NR_seccomp)
+#define __NR_seccomp 277
+#endif
+
+#if !defined(__NR_getrandom)
+#define __NR_getrandom 278
+#endif
+
+#if !defined(__NR_memfd_create)
+#define __NR_memfd_create 279
+#endif
+
+#if !defined(__NR_bfp)
+#define __NR_bfp 280
+#endif
+
+#if !defined(__NR_execveat)
+#define __NR_execveat 281
+#endif
+
+#if !defined(__NR_userfaultfd)
+#define __NR_userfaultfd 282
+#endif
+
+#if !defined(__NR_membarrier)
+#define __NR_membarrier 283
+#endif
+
+#if !defined(__NR_memlock2)
+#define __NR_memlock2 284
+#endif
+
+#if !defined(__NR_copy_file_range)
+#define __NR_copy_file_range 285
+#endif
+
+#if !defined(__NR_preadv2)
+#define __NR_preadv2 286
+#endif
+
+#if !defined(__NR_pwritev2)
+#define __NR_pwritev2 287
+#endif
+
+#if !defined(__NR_pkey_mprotect)
+#define __NR_pkey_mprotect 288
+#endif
+
+#if !defined(__NR_pkey_alloc)
+#define __NR_pkey_alloc 289
+#endif
+
+#if !defined(__NR_pkey_free)
+#define __NR_pkey_free 290
+#endif
+
+#if !defined(__NR_statx)
+#define __NR_statx 291
+#endif
+
+#if !defined(__NR_io_pgetevents)
+#define __NR_io_pgetevents 292
+#endif
+
+#if !defined(__NR_rseq)
+#define __NR_rseq 293
+#endif
+
+#if !defined(__NR_kexec_file_load)
+#define __NR_kexec_file_load 294
+#endif
+
+#if !defined(__NR_pidfd_send_signal)
+#define __NR_pidfd_send_signal 424
+#endif
+
+#if !defined(__NR_io_uring_setup)
+#define __NR_io_uring_setup 425
+#endif
+
+#if !defined(__NR_io_uring_enter)
+#define __NR_io_uring_enter 426
+#endif
+
+#if !defined(__NR_io_uring_register)
+#define __NR_io_uring_register 427
+#endif
+
+#if !defined(__NR_open_tree)
+#define __NR_open_tree 428
+#endif
+
+#if !defined(__NR_move_mount)
+#define __NR_move_mount 429
+#endif
+
+#if !defined(__NR_fsopen)
+#define __NR_fsopen 430
+#endif
+
+#if !defined(__NR_fsconfig)
+#define __NR_fsconfig 431
+#endif
+
+#if !defined(__NR_fsmount)
+#define __NR_fsmount 432
+#endif
+
+#if !defined(__NR_fspick)
+#define __NR_fspick 433
+#endif
+
+#if !defined(__NR_pidfd_open)
+#define __NR_pidfd_open 434
+#endif
+
+#if !defined(__NR_clone3)
+#define __NR_clone3 435
+#endif
+
+#if !defined(__NR_close_range)
+#define __NR_close_range 436
+#endif
+
+#if !defined(__NR_openat2)
+#define __NR_openat2 437
+#endif
+
+#if !defined(__NR_pidfd_getfd)
+#define __NR_pidfd_getfd 438
+#endif
+
+#if !defined(__NR_faccessat2)
+#define __NR_faccessat2 439
+#endif
+
+#if !defined(__NR_process_madvise)
+#define __NR_process_madvise 440
+#endif
+
+#if !defined(__NR_epoll_pwait2)
+#define __NR_epoll_pwait2 441
+#endif
+
+#if !defined(__NR_mount_setattr)
+#define __NR_mount_setattr 442
+#endif
+
+#if !defined(__NR_quotactl_path)
+#define __NR_quotactl_path 443
+#endif
+
+#if !defined(__NR_landlock_create_ruleset)
+#define __NR_landlock_create_ruleset 444
+#endif
+
+#if !defined(__NR_landlock_add_rule)
+#define __NR_landlock_add_rule 445
+#endif
+
+#if !defined(__NR_landlock_restrict_self)
+#define __NR_landlock_restrict_self 446
+#endif
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
diff --git a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
index cd64d06ae3..f6ba853051 100644
--- a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
@@ -38,7 +38,7 @@ ResultExpr CrosAmdGpuProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_sched_setscheduler:
     case __NR_sysinfo:
     case __NR_uname:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_readlink:
     case __NR_stat:
 #endif
diff --git a/sandbox/policy/linux/bpf_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
index 48b16aba59..e03a09533a 100644
--- a/sandbox/policy/linux/bpf_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
@@ -73,7 +73,7 @@ ResultExpr GpuProcessPolicy::EvaluateSyscall(int sysno) const {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_ftruncate64:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getdents:
 #endif
     case __NR_getdents64:
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index e7ad2b9286..0815f8c7b1 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -814,6 +814,8 @@ skia_source_set("skia_opts") {
     sources = skia_opts.none_sources
   } else if (current_cpu == "s390x") {
     sources = skia_opts.none_sources
+  } else if (current_cpu == "loong64") {
+    sources = skia_opts.none_sources
   } else {
     assert(false, "Need to port cpu specific stuff from skia_library_opts.gyp")
   }
diff --git a/third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc b/third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc
index 589a3ef367..2fbfea8e53 100644
--- a/third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc
+++ b/third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc
@@ -82,6 +82,8 @@ void* GetProgramCounter(void* vuc) {
       return reinterpret_cast<void*>(context->uc_mcontext.gregs[16]);
 #elif defined(__e2k__)
     return reinterpret_cast<void*>(context->uc_mcontext.cr0_hi);
+#elif defined(__loongarch__)
+    return reinterpret_cast<void*>(context->uc_mcontext.__pc);
 #else
 #error "Undefined Architecture."
 #endif
diff --git a/third_party/angle/gni/angle.gni b/third_party/angle/gni/angle.gni
index ca1c4598c3..813b47ee42 100644
--- a/third_party/angle/gni/angle.gni
+++ b/third_party/angle/gni/angle.gni
@@ -71,7 +71,7 @@ declare_args() {
 
   if (current_cpu == "arm64" || current_cpu == "x64" ||
       current_cpu == "mips64el" || current_cpu == "s390x" ||
-      current_cpu == "ppc64") {
+      current_cpu == "ppc64" || current_cpu == "loong64") {
     angle_64bit_current_cpu = true
   } else if (current_cpu == "arm" || current_cpu == "x86" ||
              current_cpu == "mipsel" || current_cpu == "s390" ||
diff --git a/third_party/boringssl/src/include/openssl/base.h b/third_party/boringssl/src/include/openssl/base.h
index 983eadc5d3..c73276d349 100644
--- a/third_party/boringssl/src/include/openssl/base.h
+++ b/third_party/boringssl/src/include/openssl/base.h
@@ -109,6 +109,9 @@ extern "C" {
 #define OPENSSL_64_BIT
 #elif defined(__riscv) && __SIZEOF_POINTER__ == 4
 #define OPENSSL_32_BIT
+#elif defined(__loongarch64)
+#define OPENSSL_64_BIT
+#define OPENSSL_LOONG64
 #elif defined(__pnacl__)
 #define OPENSSL_32_BIT
 #define OPENSSL_PNACL
diff --git a/third_party/breakpad/BUILD.gn b/third_party/breakpad/BUILD.gn
index da663f2dd9..fd106505f5 100644
--- a/third_party/breakpad/BUILD.gn
+++ b/third_party/breakpad/BUILD.gn
@@ -118,6 +118,8 @@ if (!is_win) {
         "breakpad/src/processor/stackwalker_arm.h",
         "breakpad/src/processor/stackwalker_arm64.cc",
         "breakpad/src/processor/stackwalker_arm64.h",
+        "breakpad/src/processor/stackwalker_loong64.cc",
+        "breakpad/src/processor/stackwalker_loong64.h",
         "breakpad/src/processor/stackwalker_mips.cc",
         "breakpad/src/processor/stackwalker_mips.h",
         "breakpad/src/processor/stackwalker_ppc.cc",
diff --git a/third_party/breakpad/breakpad/Makefile.am b/third_party/breakpad/breakpad/Makefile.am
index e7dc06ac71..a82a2fa1ab 100644
--- a/third_party/breakpad/breakpad/Makefile.am
+++ b/third_party/breakpad/breakpad/Makefile.am
@@ -289,6 +289,8 @@ src_libbreakpad_a_SOURCES = \
 	src/processor/stackwalker_arm64.h \
 	src/processor/stackwalker_address_list.cc \
 	src/processor/stackwalker_address_list.h \
+	src/processor/stackwalker_loong64.cc \
+	src/processor/stackwalker_loong64.h \
 	src/processor/stackwalker_mips.cc \
 	src/processor/stackwalker_mips.h \
 	src/processor/stackwalker_ppc.cc \
@@ -879,6 +881,7 @@ src_processor_exploitability_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -952,6 +955,7 @@ src_processor_microdump_processor_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -991,6 +995,7 @@ src_processor_minidump_processor_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1134,6 +1139,7 @@ src_processor_stackwalker_selftest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1302,6 +1308,7 @@ src_processor_microdump_stackwalk_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1341,6 +1348,7 @@ src_processor_minidump_stackwalk_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1465,6 +1473,7 @@ EXTRA_DIST = \
 	src/processor/testdata/linux_write_to_under_4k.dmp \
 	src/processor/testdata/microdump-arm64.dmp \
 	src/processor/testdata/microdump-arm.dmp \
+	src/processor/testdata/microdump-loong64.dmp \
 	src/processor/testdata/microdump-mips32.dmp \
 	src/processor/testdata/microdump-mips64.dmp \
 	src/processor/testdata/microdump-multiple.dmp \
diff --git a/third_party/breakpad/breakpad/Makefile.in b/third_party/breakpad/breakpad/Makefile.in
index 87377f3ac9..96c5dec77e 100644
--- a/third_party/breakpad/breakpad/Makefile.in
+++ b/third_party/breakpad/breakpad/Makefile.in
@@ -488,6 +488,8 @@ am__src_libbreakpad_a_SOURCES_DIST =  \
 	src/processor/stackwalker_arm64.h \
 	src/processor/stackwalker_address_list.cc \
 	src/processor/stackwalker_address_list.h \
+	src/processor/stackwalker_loong64.cc \
+	src/processor/stackwalker_loong64.h \
 	src/processor/stackwalker_mips.cc \
 	src/processor/stackwalker_mips.h \
 	src/processor/stackwalker_ppc.cc \
@@ -542,6 +544,7 @@ am__src_libbreakpad_a_SOURCES_DIST =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.$(OBJEXT) \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.$(OBJEXT) \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_address_list.$(OBJEXT) \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.$(OBJEXT) \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.$(OBJEXT) \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.$(OBJEXT) \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.$(OBJEXT) \
@@ -978,6 +981,7 @@ src_processor_exploitability_unittest_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -1042,6 +1046,7 @@ src_processor_microdump_processor_unittest_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -1081,6 +1086,7 @@ src_processor_microdump_stackwalk_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -1134,6 +1140,7 @@ src_processor_minidump_processor_unittest_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -1179,6 +1186,7 @@ src_processor_minidump_stackwalk_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -1370,6 +1378,7 @@ src_processor_stackwalker_selftest_OBJECTS =  \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -2627,6 +2636,8 @@ CLEANFILES = $(am__append_12)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.h \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_address_list.cc \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_address_list.h \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.cc \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.h \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.cc \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.h \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.cc \
@@ -3104,6 +3115,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -3185,6 +3197,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -3226,6 +3239,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -3389,6 +3403,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -3578,6 +3593,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
@@ -3618,6 +3634,7 @@ TESTS = $(check_PROGRAMS) $(check_SCRIPTS)
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_amd64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_arm64.o \
+@DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_loong64.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_mips.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc.o \
 @DISABLE_PROCESSOR_FALSE@	src/processor/stackwalker_ppc64.o \
diff --git a/third_party/breakpad/breakpad/autotools/config.guess b/third_party/breakpad/breakpad/autotools/config.guess
index 1000e2bd92..49521774ab 100755
--- a/third_party/breakpad/breakpad/autotools/config.guess
+++ b/third_party/breakpad/breakpad/autotools/config.guess
@@ -1003,6 +1003,9 @@ EOF
     mips64el:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
+    loongarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     openrisc*:Linux:*:*)
 	echo or1k-unknown-linux-${LIBC}
 	exit ;;
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
index 07d9171a0a..cbbccdeaf2 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
@@ -44,6 +44,8 @@ typedef MDRawContextARM RawContextCPU;
 typedef MDRawContextARM64_Old RawContextCPU;
 #elif defined(__mips__)
 typedef MDRawContextMIPS RawContextCPU;
+#elif defined(__loongarch64)
+typedef MDRawContextLOONG64 RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
index aae1dc13b2..5f8c36a353 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
@@ -228,6 +228,28 @@ void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
       MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
 }
 
+#elif defined(__loongarch64)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return mcontext.__pc;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+
+  out->pc = mcontext.__pc;
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = mcontext.__gregs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = mcontext.__fpregs[i].__val64[0];
+
+  out->float_save.fcsr = mcontext.__fcsr;
+  out->float_save.vcsr = mcontext.__vcsr;
+  out->float_save.fcc = mcontext.__fcc;
+}
+
 #elif defined(__mips__)
 
 uintptr_t ThreadInfo::GetInstructionPointer() const {
@@ -279,6 +301,11 @@ void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
     *gp_regs = mcontext.gregs;
   if (size)
     *size = sizeof(mcontext.gregs);
+#elif defined(__loongarch__)
+  if (gp_regs)
+    *gp_regs = mcontext.__gregs;
+  if (size)
+    *size = sizeof(mcontext.__gregs);
 #else
   if (gp_regs)
     *gp_regs = &regs;
@@ -294,6 +321,11 @@ void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
     *fp_regs = &mcontext.fpregs;
   if (size)
     *size = sizeof(mcontext.fpregs);
+#elif defined(__loongarch__)
+  if (fp_regs)
+    *fp_regs = &mcontext.__fpregs;
+  if (size)
+    *size = sizeof(mcontext.__fpregs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
index fb216fa6d7..c58ec4cfb3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
@@ -71,6 +71,9 @@ struct ThreadInfo {
 #elif defined(__mips__)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
+#elif defined(__loongarch__)
+  // Use the structure defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
 #endif
 
   // Returns the instruction pointer (platform-dependent impl.).
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
index 6eec1be246..459ce26e3c 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
@@ -208,6 +208,31 @@ void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
       MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
 }
 
+#elif defined(__loongarch__)
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__pc;
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+  out->pc = uc->uc_mcontext.__pc;
+
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = uc->uc_mcontext.__gregs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = uc->uc_mcontext.__fpregs[i].__val64[0];
+
+  out->float_save.fcsr = uc->uc_mcontext.__fcsr;
+  out->float_save.vcsr = uc->uc_mcontext.__vcsr;
+  out->float_save.fcc = uc->uc_mcontext.__fcc;
+}
+
 #elif defined(__mips__)
 
 uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
index ca353c4099..c292a8175b 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
@@ -461,7 +461,7 @@ bool ExceptionHandler::HandleSignal(int /*sig*/, siginfo_t* info, void* uc) {
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
-#elif !defined(__ARM_EABI__) && !defined(__mips__)
+#elif !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
   // FP state is not part of user ABI on ARM Linux.
   // In case of MIPS Linux FP state is already part of ucontext_t
   // and 'float_state' is not a member of CrashContext.
@@ -701,7 +701,7 @@ bool ExceptionHandler::WriteMinidump() {
   }
 #endif
 
-#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__) && !defined(__loongarch__)
   // FPU state is not part of ARM EABI ucontext_t.
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
@@ -726,6 +726,9 @@ bool ExceptionHandler::WriteMinidump() {
 #elif defined(__mips__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.pc);
+#elif defined(__loongarch__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.__pc);
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
index f80843ea72..03a02ac469 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
@@ -192,7 +192,7 @@ class ExceptionHandler {
     siginfo_t siginfo;
     pid_t tid;  // the crashing thread.
     ucontext_t context;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
     // #ifdef this out because FP state is not part of user ABI for Linux ARM.
     // In case of MIPS Linux FP state is already part of ucontext_t so
     // 'float_state' is not required.
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
index 35dcbfd4d8..be59b33670 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
@@ -59,6 +59,7 @@ namespace {
 
 // Flush the instruction cache for a given memory range.
 // Only required on ARM and mips.
+// TODO:LOONG64 Does loongarch need flush icache?
 void FlushInstructionCache(const char* memory, uint32_t memory_size) {
 #if defined(__arm__)
   long begin = reinterpret_cast<long>(memory);
@@ -754,10 +755,10 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryMaxBound) {
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  // Use 4k here because the OS will hand out a single page even
+  // Use page size here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff --git a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
index fa3c1713a5..3594a56d81 100644
--- a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
@@ -138,7 +138,7 @@ class MicrodumpWriter {
                   const MicrodumpExtraInfo& microdump_extra_info,
                   LinuxDumper* dumper)
       : ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -337,6 +337,8 @@ class MicrodumpWriter {
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__loongarch64)
+    const char kArch[] = "loongarch64";
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -409,7 +411,7 @@ class MicrodumpWriter {
   void DumpCPUState() {
     RawContextCPU cpu;
     my_memset(&cpu, 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
     UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
 #else
     UContextReader::FillCPUContext(&cpu, ucontext_);
@@ -605,7 +607,7 @@ class MicrodumpWriter {
   void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
 
   const ucontext_t* const ucontext_;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
   const google_breakpad::fpstate_t* const float_state_;
 #endif
   LinuxDumper* dumper_;
diff --git a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
index 6339ac0cd8..034f13ceff 100644
--- a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
@@ -280,9 +280,15 @@ TEST(MicrodumpWriterTest, BasicWithMappings) {
   ASSERT_TRUE(ContainsMicrodump(buf));
 
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  if (memory_size == 4096) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else if(memory_size == 16384) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000004000 000000000000002A 0000000000004000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
index 92e3a8444e..bc42eb9053 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
@@ -109,6 +109,9 @@ bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
   memcpy(&stack_pointer, &info->regs.ARM_sp, sizeof(info->regs.ARM_sp));
 #elif defined(__aarch64__)
   memcpy(&stack_pointer, &info->regs.sp, sizeof(info->regs.sp));
+#elif defined(__loongarch__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP]);
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
@@ -218,6 +221,11 @@ bool LinuxCoreDumper::EnumerateThreads() {
         info.mcontext.mdlo = status->pr_reg[EF_LO];
         info.mcontext.mdhi = status->pr_reg[EF_HI];
         info.mcontext.pc = status->pr_reg[EF_CP0_EPC];
+#elif defined(__loongarch__)
+	for (int i = 0; i <= 31; i++)
+          info.mcontext.__gregs[i] = status->pr_reg[i];
+        // TODO:LOONG64 Check this magic number
+        info.mcontext.__pc = status->pr_reg[32];
 #else  // __mips__
         memcpy(&info.regs, status->pr_reg, sizeof(info.regs));
 #endif  // __mips__
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
index 7bee160f1a..fb85cb0634 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
@@ -62,7 +62,7 @@ namespace google_breakpad {
 #if defined(__i386) || defined(__ARM_EABI__) || \
  (defined(__mips__) && _MIPS_SIM == _ABIO32)
 typedef Elf32_auxv_t elf_aux_entry;
-#elif defined(__x86_64) || defined(__aarch64__) || \
+#elif defined(__x86_64) || defined(__aarch64__) || defined(__loongarch64) || \
      (defined(__mips__) && _MIPS_SIM != _ABIO32)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
index 331f4bb346..18fb5cf7db 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
@@ -51,6 +51,9 @@
 #define TID_PTR_REGISTER "rcx"
 #elif defined(__mips__)
 #define TID_PTR_REGISTER "$1"
+#elif defined(__loongarch__)
+// TODO:LOONG64 Check TID_PTR_REGISTER value
+#define TID_PTR_REGISTER "$7"
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
index e3ddb81a65..05c1f423d0 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
@@ -286,6 +286,11 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
              reinterpret_cast<void*>(DSP_CONTROL), &info->mcontext.dsp);
 #endif
 
+#if defined(__loongarch__)
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(PC), &info->mcontext.__pc);
+#endif
+
   const uint8_t* stack_pointer;
 #if defined(__i386)
   my_memcpy(&stack_pointer, &info->regs.esp, sizeof(info->regs.esp));
@@ -295,6 +300,9 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
   my_memcpy(&stack_pointer, &info->regs.ARM_sp, sizeof(info->regs.ARM_sp));
 #elif defined(__aarch64__)
   my_memcpy(&stack_pointer, &info->regs.sp, sizeof(info->regs.sp));
+#elif defined(__loongarch64)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP]);
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
index da71e15dc0..eb83d6ccfe 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
@@ -462,6 +462,9 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
 #elif defined(__mips__)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.gregs[1]);
+#elif defined(__loongarch__)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.mcontext.__gregs[7]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -559,6 +562,8 @@ TEST_F(LinuxPtraceDumperTest, SanitizeStackCopy) {
   uintptr_t heap_addr = thread_info.regs.rcx;
 #elif defined(__mips__)
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
+#elif defined(__loongarch__)
+  uintptr_t heap_addr = thread_info.mcontext.__gregs[7];
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
index 32634ef002..5f5ee40e33 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
@@ -136,7 +136,7 @@ class MinidumpWriter {
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -468,7 +468,7 @@ class MinidumpWriter {
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
 #else
         UContextReader::FillCPUContext(cpu.get(), ucontext_);
@@ -897,7 +897,7 @@ class MinidumpWriter {
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__loongarch__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -925,6 +925,8 @@ class MinidumpWriter {
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__loongarch64)
+        MD_CPU_ARCHITECTURE_LOONG64;
 #elif defined(__i386__)
         MD_CPU_ARCHITECTURE_X86;
 #else
@@ -1333,7 +1335,7 @@ class MinidumpWriter {
   const char* path_;  // Path to the file where the minidum should be written.
 
   const ucontext_t* const ucontext_;  // also from the signal handler
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
   const google_breakpad::fpstate_t* const float_state_;  // ditto
 #endif
   LinuxDumper* dumper_;
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
index e3b0b16dae..121ca58c2f 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
@@ -48,7 +48,7 @@ class ExceptionHandler;
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
-#elif !defined(__ARM_EABI__) && !defined(__mips__)
+#elif !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__loongarch__)
 typedef std::remove_pointer<fpregset_t>::type fpstate_t;
 #endif
 
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
index d192e5cbb7..451bbc8fbb 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -715,6 +715,9 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 #elif defined(__mips__)
   context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__loongarch64)
+  context.context.uc_mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
index d7d19834b5..3b61446e1a 100644
--- a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
+++ b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
@@ -142,6 +142,23 @@ vector<string> DwarfCFIToModule::RegisterNames::MIPS() {
                     sizeof(kRegisterNames) / sizeof(kRegisterNames[0]));
 }
 
+vector<string> DwarfCFIToModule::RegisterNames::LOONG64() {
+  static const char* const kRegisterNames[] = {
+    "r0",   "r1",   "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",   "r9",   "r10", "r11", "r12", "r13", "r14", "r15",
+    "r16",  "r17",  "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24",  "r25",  "r26", "r27", "r28", "r29", "r30", "r31",
+    "f0",   "f1",   "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
+    "f8",   "f9",   "f10", "f11", "f12", "f13", "f14", "f15",
+    "f16",  "f17",  "f18", "f19", "f20", "f21", "f22", "f23",
+    "f24",  "f25",  "f26", "f27", "f28", "f29", "f30", "f31",
+    "fcc0", "fcc1", "fcc2", "fcc3", "fcc4", "fcc5", "fcc6", "fcc7"
+  };
+
+  return MakeVector(kRegisterNames,
+                    sizeof(kRegisterNames) / sizeof(kRegisterNames[0]));
+}
+
 bool DwarfCFIToModule::Entry(size_t offset, uint64_t address, uint64_t length,
                              uint8_t version, const string& augmentation,
                              unsigned return_address) {
diff --git a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
index 3e2e6ffece..2f09d26783 100644
--- a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
+++ b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
@@ -114,6 +114,9 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
     // MIPS.
     static vector<string> MIPS();
 
+    // LoongArch64.
+    static vector<string> LOONG64();
+
    private:
     // Given STRINGS, an array of C strings with SIZE elements, return an
     // equivalent vector<string>.
diff --git a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
index 2ebcf31910..b5622acfc4 100644
--- a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
+++ b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
@@ -445,6 +445,59 @@ NESTED (breakpad_getcontext, FRAME_SIZE, ra)
 END (breakpad_getcontext)
 #endif // _MIPS_SIM == _ABIO32
 
+#elif defined(__loongarch64)
+
+// TODO:LOONG64 Recheck, NSIG may change
+#define  _NSIG                       128
+#define  __NR_rt_sigprocmask         135
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .type breakpad_getcontext, @function
+  .align 4
+
+breakpad_getcontext:
+  st.d $zero, $a0, MCONTEXT_GREGS_OFFSET + 4 * REGISTER_SIZE  /* zero */
+  st.d $fp, $a0, MCONTEXT_GREGS_OFFSET + 22 * REGISTER_SIZE
+  st.d $s0, $a0, MCONTEXT_GREGS_OFFSET + 23 * REGISTER_SIZE
+  st.d $s1, $a0, MCONTEXT_GREGS_OFFSET + 24 * REGISTER_SIZE
+  st.d $s2, $a0, MCONTEXT_GREGS_OFFSET + 25 * REGISTER_SIZE
+  st.d $s3, $a0, MCONTEXT_GREGS_OFFSET + 26 * REGISTER_SIZE
+  st.d $s4, $a0, MCONTEXT_GREGS_OFFSET + 27 * REGISTER_SIZE
+  st.d $s5, $a0, MCONTEXT_GREGS_OFFSET + 28 * REGISTER_SIZE
+  st.d $s6, $a0, MCONTEXT_GREGS_OFFSET + 29 * REGISTER_SIZE
+  st.d $s7, $a0, MCONTEXT_GREGS_OFFSET + 30 * REGISTER_SIZE
+  st.d $s8, $a0, MCONTEXT_GREGS_OFFSET + 31 * REGISTER_SIZE
+  st.d $sp, $a0, MCONTEXT_GREGS_OFFSET + 3 * REGISTER_SIZE
+  st.d $ra, $a0, MCONTEXT_GREGS_OFFSET + 1 * REGISTER_SIZE
+  st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+  fst.d $fs0, $a0, MCONTEXT_GREGS_OFFSET + 24 * REGISTER_SIZE
+  fst.d $fs1, $a0, MCONTEXT_GREGS_OFFSET + 25 * REGISTER_SIZE
+  fst.d $fs2, $a0, MCONTEXT_GREGS_OFFSET + 26 * REGISTER_SIZE
+  fst.d $fs3, $a0, MCONTEXT_GREGS_OFFSET + 27 * REGISTER_SIZE
+  fst.d $fs4, $a0, MCONTEXT_GREGS_OFFSET + 28 * REGISTER_SIZE
+  fst.d $fs5, $a0, MCONTEXT_GREGS_OFFSET + 29 * REGISTER_SIZE
+  fst.d $fs6, $a0, MCONTEXT_GREGS_OFFSET + 30 * REGISTER_SIZE
+  fst.d $fs7, $a0, MCONTEXT_GREGS_OFFSET + 31 * REGISTER_SIZE
+
+  // TODO:LOONG64 Handle fcsr/vcsr/fcc
+
+  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+  addi.d $a2, $a0, UCONTEXT_SIGMASK_OFFSET
+  move  $a1, $zero
+  li.d  $a0, 0
+  li.d  $a3, _NSIG / 8
+  li.d  $a7, __NR_rt_sigprocmask
+  syscall 0
+
+  /* Return zero for success */
+  move $a0, $zero
+  jirl $zero, $ra, 0
+
+  .size breakpad_getcontext, . - breakpad_getcontext
+
 #elif defined(__x86_64__)
 /* The x64 implementation of breakpad_getcontext was derived in part
    from the implementation of libunwind which requires the following
diff --git a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
index a57bfedf9b..6eab14857d 100644
--- a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
@@ -114,6 +114,16 @@ TEST(AndroidUContext, GRegsOffset) {
 
   ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPC_CSR),
             offsetof(ucontext_t,uc_mcontext.fpc_csr));
+#elif defined(__loongarch__)
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__gregs));
+
+  // PC for loongarch is not part of gregs.
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__pc));
+
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPREGS_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__fpregs));
 #elif defined(__x86_64__)
 
   COMPILE_ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
diff --git a/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc b/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
index ac53ea286e..a0f353abc8 100644
--- a/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
@@ -105,6 +105,11 @@ using google_breakpad::wasteful_vector;
 #define EM_AARCH64      183
 #endif
 
+// Define LOONGARCH ELF architecture if host machine does not include this define.
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH      258
+#endif
+
 //
 // FDWrapper
 //
@@ -373,6 +378,9 @@ bool DwarfCFIRegisterNames(const typename ElfClass::Ehdr* elf_header,
     case EM_X86_64:
       *register_names = DwarfCFIToModule::RegisterNames::X86_64();
       return true;
+    case EM_LOONGARCH:
+      *register_names = DwarfCFIToModule::RegisterNames::LOONG64();
+      return true;
     default:
       return false;
   }
@@ -913,6 +921,7 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
     case EM_SPARC:      return "sparc";
     case EM_SPARCV9:    return "sparcv9";
     case EM_X86_64:     return "x86_64";
+    case EM_LOONGARCH:  return "loongarch";
     default: return NULL;
   }
 }
diff --git a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
index 99362945ca..85d57889cb 100644
--- a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
@@ -64,7 +64,7 @@ bool MemoryMappedFile::Map(const char* path, size_t offset) {
     return false;
   }
 
-#if defined(__x86_64__) || defined(__aarch64__) || \
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch64) || \
    (defined(__mips__) && _MIPS_SIM == _ABI64)
 
   struct kernel_stat st;
diff --git a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
index fad59f40cd..a963862d5c 100644
--- a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
@@ -176,9 +176,9 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = sysconf(_SC_PAGESIZE);
+  char data1[8 * 4096];
+  size_t data1_size = page_size * 2;
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
diff --git a/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h b/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
index c390508a1a..3d586a0288 100644
--- a/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
+++ b/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
@@ -116,6 +116,16 @@
 #define  UCONTEXT_SIGMASK_OFFSET   640
 #endif
 
+#elif defined(__loongarch64)
+// The uc_mcontext is 256-bit aligned
+#define  MCONTEXT_PC_OFFSET        64
+#define  MCONTEXT_GREGS_OFFSET     72
+#define  MCONTEXT_FPREGS_OFFSET    352
+// TODO:LOONG64 Check SIGMASK_OFFSET
+#define  UCONTEXT_SIGMASK_OFFSET   1408
+
+#define  REGISTER_SIZE               8
+
 #elif defined(__x86_64__)
 
 #define MCONTEXT_GREGS_OFFSET     40
diff --git a/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc b/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
index 5803b90d50..44b67a9431 100644
--- a/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
@@ -54,9 +54,15 @@ TEST(PageAllocatorTest, SmallObjects) {
 
 TEST(PageAllocatorTest, LargeObject) {
   PageAllocator allocator;
+  uint8_t* p = NULL;
 
   EXPECT_EQ(0U, allocator.pages_allocated());
-  uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  if (sysconf(_SC_PAGESIZE) == 16384) {
+    p = reinterpret_cast<uint8_t*>(allocator.Alloc(40000));
+  } else {
+    EXPECT_EQ(4096U, sysconf(_SC_PAGESIZE));
+    p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  }
   ASSERT_FALSE(p == NULL);
   EXPECT_EQ(3U, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_cpu_loong64.h b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_cpu_loong64.h
new file mode 100644
index 0000000000..32340a19ed
--- /dev/null
+++ b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_cpu_loong64.h
@@ -0,0 +1,128 @@
+/* Copyright (c) 2021, Google Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+/* minidump_format.h: A cross-platform reimplementation of minidump-related
+ * portions of DbgHelp.h from the Windows Platform SDK.
+ *
+ * (This is C99 source, please don't corrupt it with C++.)
+ *
+ * This file contains the necessary definitions to read minidump files
+ * produced on LOONG64.  These files may be read on any platform provided
+ * that the alignments of these structures on the processing system are
+ * identical to the alignments of these structures on the producing system.
+ * For this reason, precise-sized types are used.  The structures defined
+ * by this file have been laid out to minimize alignment problems by
+ * ensuring that all members are aligned on their natural boundaries.
+ * In some cases, tail-padding may be significant when different ABIs specify
+ * different tail-padding behaviors.  To avoid problems when reading or
+ * writing affected structures, MD_*_SIZE macros are provided where needed,
+ * containing the useful size of the structures without padding.
+ *
+ * Structures that are defined by Microsoft to contain a zero-length array
+ * are instead defined here to contain an array with one element, as
+ * zero-length arrays are forbidden by standard C and C++.  In these cases,
+ * *_minsize constants are provided to be used in place of sizeof.  For a
+ * cleaner interface to these sizes when using C++, see minidump_size.h.
+ *
+ * These structures are also sufficient to populate minidump files.
+ *
+ * Because precise data type sizes are crucial for this implementation to
+ * function properly and portably, a set of primitive types with known sizes
+ * are used as the basis of each structure defined by this file.
+ *
+ * Author: Zhao Jiazhong
+ */
+
+/*
+ * LOONG64 support
+ */
+
+#ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONG64_H__
+#define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONG64_H__
+
+#define MD_CONTEXT_LOONG64_GPR_COUNT 32
+#define MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT 32
+
+typedef struct {
+  // TODO:LOONG64 Support vector FPU
+  /* 32 64-bit floating point registers, f0..f31 */
+  uint64_t regs[MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT];
+
+  uint32_t fcsr; /* FPU control register */
+  uint32_t vcsr; /* Vector control register */
+  uint64_t fcc;  /* FPU status register */
+} MDFloatingSaveAreaLOONG64;
+
+typedef struct {
+  /* The next field determines the layout of the structure, and which parts
+   * of it are populated.
+   */
+  uint32_t context_flags;
+  uint32_t _pad0;
+
+  /* 32 64-bit integer registers, r0..r31.
+   * Note the following fixed uses:
+   *   r1 is the return address.
+   *   r3 is the stack pointer.
+   *   r22 is the frame pointer.
+   */
+  uint64_t iregs[MD_CONTEXT_LOONG64_GPR_COUNT];
+
+  uint64_t pc;
+
+  /* The next field is included with MD_CONTEXT_LOONG64_FLOATING_POINT. */
+  MDFloatingSaveAreaLOONG64 float_save;
+
+} MDRawContextLOONG64;
+
+/* Indices into iregs for registers with a dedicated or conventional
+ * purpose.
+ */
+enum MDLOONG64RegisterNumbers {
+  MD_CONTEXT_LOONG64_REG_RA     = 1,
+  MD_CONTEXT_LOONG64_REG_SP     = 3,
+  MD_CONTEXT_LOONG64_REG_FP     = 22
+};
+
+
+ /* For (MDRawContextPPC).context_flags.  These values indicate the type of
+  * context stored in the structure.  MD_CONTEXT_PPC is Breakpad-defined.  Its
+  * value was chosen to avoid likely conflicts with MD_CONTEXT_* for other
+  * CPUs. */
+#define MD_CONTEXT_LOONG64                    0x08000000
+#define MD_CONTEXT_LOONG64_INTEGER           (MD_CONTEXT_LOONG64 | 0x00000002)
+#define MD_CONTEXT_LOONG64_FLOATING_POINT    (MD_CONTEXT_LOONG64 | 0x00000004)
+
+#define MD_CONTEXT_LOONG64_FULL              (MD_CONTEXT_LOONG64_INTEGER | \
+                                           MD_CONTEXT_LOONG64_FLOATING_POINT)
+
+#define MD_CONTEXT_LOONG64_ALL               (MD_CONTEXT_LOONG64_INTEGER | \
+                                           MD_CONTEXT_LOONG64_FLOATING_POINT)
+
+#endif  // GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_LOONG64_H__
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
index 7b36d1127d..686335e5c5 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
@@ -115,6 +115,7 @@ typedef struct {
 #include "minidump_cpu_amd64.h"
 #include "minidump_cpu_arm.h"
 #include "minidump_cpu_arm64.h"
+#include "minidump_cpu_loong64.h"
 #include "minidump_cpu_mips.h"
 #include "minidump_cpu_ppc.h"
 #include "minidump_cpu_ppc64.h"
@@ -660,6 +661,7 @@ typedef enum {
   MD_CPU_ARCHITECTURE_PPC64     = 0x8002, /* Breakpad-defined value for PPC64 */
   MD_CPU_ARCHITECTURE_ARM64_OLD = 0x8003, /* Breakpad-defined value for ARM64 */
   MD_CPU_ARCHITECTURE_MIPS64    = 0x8004, /* Breakpad-defined value for MIPS64 */
+  MD_CPU_ARCHITECTURE_LOONG64      = 0x8005, /* Breakpad-defined value for LOONG64 */
   MD_CPU_ARCHITECTURE_UNKNOWN   = 0xffff  /* PROCESSOR_ARCHITECTURE_UNKNOWN */
 } MDCPUArchitecture;
 
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
index df80bf7ef7..83297f025a 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
@@ -62,6 +62,7 @@ class DumpContext : public DumpObject {
   const MDRawContextPPC64* GetContextPPC64() const;
   const MDRawContextSPARC* GetContextSPARC() const;
   const MDRawContextX86*   GetContextX86() const;
+  const MDRawContextLOONG64*  GetContextLOONG64() const;
 
   // A convenience method to get the instruction pointer out of the
   // MDRawContext, since it varies per-CPU architecture.
@@ -87,6 +88,7 @@ class DumpContext : public DumpObject {
   void SetContextARM(MDRawContextARM* arm);
   void SetContextARM64(MDRawContextARM64* arm64);
   void SetContextMIPS(MDRawContextMIPS* ctx_mips);
+  void SetContextLOONG64(MDRawContextLOONG64* ctx_loong64);
 
   // Free the CPU-specific context structure.
   void FreeContext();
@@ -105,6 +107,7 @@ class DumpContext : public DumpObject {
     MDRawContextARM*   arm;
     MDRawContextARM64* arm64;
     MDRawContextMIPS*  ctx_mips;
+    MDRawContextLOONG64*  ctx_loong64;
   } context_;
 
   // Store this separately because of the weirdo AMD64 context
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
index 02ebdcd79b..cebb00c414 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
@@ -72,6 +72,7 @@ class MicrodumpContext : public DumpContext {
   virtual void SetContextX86(MDRawContextX86* x86);
   virtual void SetContextMIPS(MDRawContextMIPS* mips32);
   virtual void SetContextMIPS64(MDRawContextMIPS* mips64);
+  virtual void SetContextLOONG64(MDRawContextLOONG64* loong64);
 };
 
 // This class provides access to microdump memory regions.
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
index dc5d8ae673..92301c5c4f 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
@@ -400,6 +400,69 @@ struct StackFrameMIPS : public StackFrame {
   int context_validity;
 };
 
+struct StackFrameLOONG64 : public StackFrame {
+  // A flag for each register we might know. Note that we can't use an enum
+  // here as there are 33 values to represent.
+  static const uint64_t CONTEXT_VALID_NONE = 0;
+  static const uint64_t CONTEXT_VALID_R0   = 1ULL << 0;
+  static const uint64_t CONTEXT_VALID_R1   = 1ULL << 1;
+  static const uint64_t CONTEXT_VALID_R2   = 1ULL << 2;
+  static const uint64_t CONTEXT_VALID_R3   = 1ULL << 3;
+  static const uint64_t CONTEXT_VALID_R4   = 1ULL << 4;
+  static const uint64_t CONTEXT_VALID_R5   = 1ULL << 5;
+  static const uint64_t CONTEXT_VALID_R6   = 1ULL << 6;
+  static const uint64_t CONTEXT_VALID_R7   = 1ULL << 7;
+  static const uint64_t CONTEXT_VALID_R8   = 1ULL << 8;
+  static const uint64_t CONTEXT_VALID_R9   = 1ULL << 9;
+  static const uint64_t CONTEXT_VALID_R10  = 1ULL << 10;
+  static const uint64_t CONTEXT_VALID_R11  = 1ULL << 11;
+  static const uint64_t CONTEXT_VALID_R12  = 1ULL << 12;
+  static const uint64_t CONTEXT_VALID_R13  = 1ULL << 13;
+  static const uint64_t CONTEXT_VALID_R14  = 1ULL << 14;
+  static const uint64_t CONTEXT_VALID_R15  = 1ULL << 15;
+  static const uint64_t CONTEXT_VALID_R16  = 1ULL << 16;
+  static const uint64_t CONTEXT_VALID_R17  = 1ULL << 17;
+  static const uint64_t CONTEXT_VALID_R18  = 1ULL << 18;
+  static const uint64_t CONTEXT_VALID_R19  = 1ULL << 19;
+  static const uint64_t CONTEXT_VALID_R20  = 1ULL << 20;
+  static const uint64_t CONTEXT_VALID_R21  = 1ULL << 21;
+  static const uint64_t CONTEXT_VALID_R22  = 1ULL << 22;
+  static const uint64_t CONTEXT_VALID_R23  = 1ULL << 23;
+  static const uint64_t CONTEXT_VALID_R24  = 1ULL << 24;
+  static const uint64_t CONTEXT_VALID_R25  = 1ULL << 25;
+  static const uint64_t CONTEXT_VALID_R26  = 1ULL << 26;
+  static const uint64_t CONTEXT_VALID_R27  = 1ULL << 27;
+  static const uint64_t CONTEXT_VALID_R28  = 1ULL << 28;
+  static const uint64_t CONTEXT_VALID_R29  = 1ULL << 29;
+  static const uint64_t CONTEXT_VALID_R30  = 1ULL << 30;
+  static const uint64_t CONTEXT_VALID_R31  = 1ULL << 31;
+  static const uint64_t CONTEXT_VALID_PC  = 1ULL << 32;
+  static const uint64_t CONTEXT_VALID_ALL  = ~CONTEXT_VALID_NONE;
+
+  // Aliases for registers with dedicated or conventional roles.
+  static const uint64_t CONTEXT_VALID_RA   = CONTEXT_VALID_R1;
+  static const uint64_t CONTEXT_VALID_SP   = CONTEXT_VALID_R3;
+  static const uint64_t CONTEXT_VALID_FP   = CONTEXT_VALID_R22;
+
+  StackFrameLOONG64() : context(),
+                     context_validity(CONTEXT_VALID_NONE) {}
+
+  // Return the validity flag for register xN.
+  static uint64_t RegisterValidFlag(int n) {
+    return 1ULL << n;
+  }
+
+  // Register state. This is only fully valid for the topmost frame in a
+  // stack. In other frames, the values of nonvolatile registers may be
+  // present, given sufficient debugging information. Refer to
+  // context_validity.
+  MDRawContextLOONG64 context;
+
+  // For each register in context whose value has been recovered, we set
+  // the corresponding CONTEXT_VALID_ bit in context_validity.
+  uint64_t context_validity;
+};
+
 }  // namespace google_breakpad
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
diff --git a/third_party/breakpad/breakpad/src/processor/dump_context.cc b/third_party/breakpad/breakpad/src/processor/dump_context.cc
index da531b74d0..73591e5260 100644
--- a/third_party/breakpad/breakpad/src/processor/dump_context.cc
+++ b/third_party/breakpad/breakpad/src/processor/dump_context.cc
@@ -140,6 +140,15 @@ const MDRawContextMIPS* DumpContext::GetContextMIPS() const {
   return context_.ctx_mips;
 }
 
+const MDRawContextLOONG64* DumpContext::GetContextLOONG64() const {
+  if (GetContextCPU() != MD_CONTEXT_LOONG64) {
+    BPLOG(ERROR) << "DumpContext cannot get loongarch64 context";
+    return NULL;
+  }
+
+  return context_.ctx_loong64;
+}
+
 bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   BPLOG_IF(ERROR, !ip) << "DumpContext::GetInstructionPointer requires |ip|";
   assert(ip);
@@ -176,6 +185,9 @@ bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   case MD_CONTEXT_MIPS64:
     *ip = GetContextMIPS()->epc;
     break;
+  case MD_CONTEXT_LOONG64:
+    *ip = GetContextLOONG64()->pc;
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetInstructionPointer";
@@ -220,6 +232,9 @@ bool DumpContext::GetStackPointer(uint64_t* sp) const {
   case MD_CONTEXT_MIPS64:
     *sp = GetContextMIPS()->iregs[MD_CONTEXT_MIPS_REG_SP];
     break;
+  case MD_CONTEXT_LOONG64:
+    *sp = GetContextLOONG64()->iregs[MD_CONTEXT_LOONG64_REG_SP];
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetStackPointer";
@@ -264,6 +279,10 @@ void DumpContext::SetContextMIPS(MDRawContextMIPS* ctx_mips) {
   context_.ctx_mips = ctx_mips;
 }
 
+void DumpContext::SetContextLOONG64(MDRawContextLOONG64* ctx_loong64) {
+  context_.ctx_loong64 = ctx_loong64;
+}
+
 void DumpContext::FreeContext() {
   switch (GetContextCPU()) {
     case MD_CONTEXT_X86:
@@ -299,6 +318,10 @@ void DumpContext::FreeContext() {
       delete context_.ctx_mips;
       break;
 
+    case MD_CONTEXT_LOONG64:
+      delete context_.ctx_loong64;
+      break;
+
     default:
       // There is no context record (valid_ is false) or there's a
       // context record for an unknown CPU (shouldn't happen, only known
@@ -655,6 +678,30 @@ void DumpContext::Print() {
       break;
     }
 
+    case MD_CONTEXT_LOONG64: {
+      const MDRawContextLOONG64* context_loong64 = GetContextLOONG64();
+      printf("MDRawContextLOONG64\n");
+      printf("  context_flags       = 0x%x\n", context_loong64->context_flags);
+      for (unsigned int ireg_index = 0; ireg_index < MD_CONTEXT_LOONG64_GPR_COUNT;
+           ++ireg_index) {
+        printf("  iregs[%2d]            = 0x%" PRIx64 "\n", ireg_index,
+               context_loong64->iregs[ireg_index]);
+      }
+      printf("  pc                  = 0x%lx\n", context_loong64->pc);
+      printf("  float_save.fcsr     = 0x%x\n", context_loong64->float_save.fcsr);
+      printf("  float_save.vcsr     = 0x%x\n", context_loong64->float_save.vcsr);
+
+      for (unsigned int freg_index = 0;
+           freg_index < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++freg_index) {
+        // TODO:LOONG64 Support vector FPU
+        uint64_t fp_value = context_loong64->float_save.regs[freg_index];
+        printf("  float_save.regs[%2d]            = 0x%" PRIx64 "\n",
+               freg_index, fp_value);
+      }
+
+      break;
+    }
+
     default: {
       break;
     }
diff --git a/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc b/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc
index 3ec39dd0aa..a088a465fb 100644
--- a/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc
+++ b/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc
@@ -201,6 +201,7 @@ bool ExploitabilityLinux::EndedOnIllegalWrite(uint64_t instruction_ptr) {
   }
   // Check architecture and set architecture variable to corresponding flag
   // in objdump.
+  // TODO:LOONG64 Support check architecture and set architecture variable
   switch (context->GetContextCPU()) {
     case MD_CONTEXT_X86:
       architecture = "i386";
diff --git a/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc b/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
index 528ee5f213..300b2d623d 100644
--- a/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
+++ b/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
@@ -42,6 +42,9 @@
 #endif  // _WIN32
 #include "processor/simple_symbol_supplier.h"
 
+// The tests are designd for x86 processors.
+#if defined(__i386__) || defined(__x86_64__)
+
 #ifndef _WIN32
 namespace google_breakpad {
 
@@ -304,3 +307,5 @@ TEST(ExploitabilityLinuxUtilsTest, CalculateAddressTest) {
 #endif  // _WIN32
 
 }  // namespace
+
+#endif // defined(__i386__) || defined(__x86_64__)
diff --git a/third_party/breakpad/breakpad/src/processor/microdump.cc b/third_party/breakpad/breakpad/src/processor/microdump.cc
index d8141a2a8f..442a408870 100644
--- a/third_party/breakpad/breakpad/src/processor/microdump.cc
+++ b/third_party/breakpad/breakpad/src/processor/microdump.cc
@@ -65,6 +65,7 @@ static const char kArm64Architecture[] = "arm64";
 static const char kX86Architecture[] = "x86";
 static const char kMipsArchitecture[] = "mips";
 static const char kMips64Architecture[] = "mips64";
+static const char kLoong64Architecture[] = "loongarch64";
 static const char kGpuUnknown[] = "UNKNOWN";
 
 template<typename T>
@@ -151,6 +152,12 @@ void MicrodumpContext::SetContextMIPS64(MDRawContextMIPS* mips64) {
   valid_ = true;
 }
 
+void MicrodumpContext::SetContextLOONG64(MDRawContextLOONG64* loong64) {
+  DumpContext::SetContextFlags(MD_CONTEXT_LOONG64);
+  DumpContext::SetContextLOONG64(loong64);
+  valid_ = true;
+}
+
 
 //
 // MicrodumpMemoryRegion
@@ -359,6 +366,16 @@ Microdump::Microdump(const string& contents)
         MDRawContextMIPS* mips64 = new MDRawContextMIPS();
         memcpy(mips64, &cpu_state_raw[0], cpu_state_raw.size());
         context_->SetContextMIPS64(mips64);
+      } else if (strcmp(arch.c_str(), kLoong64Architecture) == 0) {
+        if (cpu_state_raw.size() != sizeof(MDRawContextLOONG64)) {
+          std::cerr << "Malformed CPU context. Got " << cpu_state_raw.size()
+                    << " bytes instead of " << sizeof(MDRawContextLOONG64)
+                    << std::endl;
+          continue;
+        }
+        MDRawContextLOONG64* loong64 = new MDRawContextLOONG64();
+        memcpy(loong64, &cpu_state_raw[0], cpu_state_raw.size());
+        context_->SetContextLOONG64(loong64);
       } else {
         std::cerr << "Unsupported architecture: " << arch << std::endl;
       }
diff --git a/third_party/breakpad/breakpad/src/processor/minidump.cc b/third_party/breakpad/breakpad/src/processor/minidump.cc
index 572c717cd5..bee7fbeb41 100644
--- a/third_party/breakpad/breakpad/src/processor/minidump.cc
+++ b/third_party/breakpad/breakpad/src/processor/minidump.cc
@@ -96,6 +96,8 @@ bool IsContextSizeUnique(uint32_t context_size) {
     num_matching_contexts++;
   if (context_size == sizeof(MDRawContextMIPS))
     num_matching_contexts++;
+  if (context_size == sizeof(MDRawContextLOONG64))
+    num_matching_contexts++;
   return num_matching_contexts == 1;
 }
 
@@ -1170,6 +1172,60 @@ bool MinidumpContext::Read(uint32_t expected_size) {
         break;
       }
 
+      case MD_CONTEXT_LOONG64: {
+        if (expected_size != sizeof(MDRawContextLOONG64)) {
+          BPLOG(ERROR) << "MinidumpContext loongarch64 size mismatch, " <<
+                       expected_size << " != " << sizeof(MDRawContextLOONG64);
+          return false;
+        }
+
+        scoped_ptr<MDRawContextLOONG64> context_loong64(new MDRawContextLOONG64());
+
+        // Set the context_flags member, which has already been read, and
+        // read the rest of the structure beginning with the first member
+        // after context_flags.
+        context_loong64->context_flags = context_flags;
+
+        size_t flags_size = sizeof(context_loong64->context_flags);
+        uint8_t* context_after_flags =
+            reinterpret_cast<uint8_t*>(context_loong64.get()) + flags_size;
+        if (!minidump_->ReadBytes(context_after_flags,
+                                  sizeof(*context_loong64) - flags_size)) {
+          BPLOG(ERROR) << "MinidumpContext could not read loongarch64 context";
+          return false;
+        }
+
+        // Do this after reading the entire MDRawContext structure because
+        // GetSystemInfo may seek minidump to a new position.
+        if (!CheckAgainstSystemInfo(cpu_type)) {
+          BPLOG(ERROR) << "MinidumpContext loongarch64 does not match system info";
+          return false;
+        }
+
+        if (minidump_->swap()) {
+          // context_loong64->context_flags was already swapped.
+          for (unsigned int ireg_index = 0;
+               ireg_index < MD_CONTEXT_LOONG64_GPR_COUNT;
+               ++ireg_index) {
+            Swap(&context_loong64->iregs[ireg_index]);
+          }
+          Swap(&context_loong64->pc);
+          Swap(&context_loong64->float_save.fcsr);
+          Swap(&context_loong64->float_save.vcsr);
+          Swap(&context_loong64->float_save.fcc);
+          for (unsigned int fpr_index = 0;
+               fpr_index < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT;
+               ++fpr_index) {
+            // TODO:LOONG64 Support vector FPU
+            // Normalize128(&context_loong64->float_save.regs[fpr_index],
+            //              minidump_->is_big_endian());
+            Swap(&context_loong64->float_save.regs[fpr_index]);
+          }
+        }
+        SetContextLOONG64(context_loong64.release());
+        break;
+      }
+
       default: {
         // Unknown context type - Don't log as an error yet. Let the
         // caller work that out.
@@ -1262,6 +1318,11 @@ bool MinidumpContext::CheckAgainstSystemInfo(uint32_t context_cpu_type) {
       if (system_info_cpu_type == MD_CPU_ARCHITECTURE_MIPS64)
         return_value = true;
       break;
+
+    case MD_CONTEXT_LOONG64:
+      if (system_info_cpu_type == MD_CPU_ARCHITECTURE_LOONG64)
+        return_value = true;
+      break;
   }
 
   BPLOG_IF(ERROR, !return_value) << "MinidumpContext CPU " <<
diff --git a/third_party/breakpad/breakpad/src/processor/minidump_processor.cc b/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
index ac86fbd39f..6c345f4b01 100644
--- a/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
+++ b/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
@@ -592,6 +592,11 @@ bool MinidumpProcessor::GetCPUInfo(Minidump* dump, SystemInfo* info) {
       break;
     }
 
+    case MD_CPU_ARCHITECTURE_LOONG64: {
+      info->cpu = "loongarch64";
+      break;
+    }
+
     default: {
       // Assign the numeric architecture ID into the CPU string.
       char cpu_string[7];
diff --git a/third_party/breakpad/breakpad/src/processor/stackwalker.cc b/third_party/breakpad/breakpad/src/processor/stackwalker.cc
index e123b02776..dcea36b4ec 100644
--- a/third_party/breakpad/breakpad/src/processor/stackwalker.cc
+++ b/third_party/breakpad/breakpad/src/processor/stackwalker.cc
@@ -55,6 +55,7 @@
 #include "processor/stackwalker_arm.h"
 #include "processor/stackwalker_arm64.h"
 #include "processor/stackwalker_mips.h"
+#include "processor/stackwalker_loong64.h"
 
 namespace google_breakpad {
 
@@ -271,6 +272,13 @@ Stackwalker* Stackwalker::StackwalkerForCPU(
                                              memory, modules,
                                              frame_symbolizer);
       break;
+
+    case MD_CONTEXT_LOONG64:
+      cpu_stackwalker = new StackwalkerLOONG64(system_info,
+                                            context->GetContextLOONG64(),
+                                            memory, modules,
+                                            frame_symbolizer);
+      break;
   }
 
   BPLOG_IF(ERROR, !cpu_stackwalker) << "Unknown CPU type " << HexString(cpu) <<
diff --git a/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.cc b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.cc
new file mode 100644
index 0000000000..f5d84fd4f7
--- /dev/null
+++ b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.cc
@@ -0,0 +1,237 @@
+// Copyright (c) 2021 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_loong64.cc: loong64-specific stackwalker.
+//
+// See stackwalker_loong64.h for documentation.
+//
+// Author: Zhao Jiazhong
+
+#include <vector>
+
+#include "common/scoped_ptr.h"
+#include "google_breakpad/processor/call_stack.h"
+#include "google_breakpad/processor/memory_region.h"
+#include "google_breakpad/processor/source_line_resolver_interface.h"
+#include "google_breakpad/processor/stack_frame_cpu.h"
+#include "processor/cfi_frame_info.h"
+#include "processor/logging.h"
+#include "processor/stackwalker_loong64.h"
+
+namespace google_breakpad {
+
+StackwalkerLOONG64::StackwalkerLOONG64(const SystemInfo* system_info,
+                                 const MDRawContextLOONG64* context,
+                                 MemoryRegion* memory,
+                                 const CodeModules* modules,
+                                 StackFrameSymbolizer* resolver_helper)
+    : Stackwalker(system_info, memory, modules, resolver_helper),
+      context_(context) {
+  if (memory_) {
+    if (0xffffffffffffffff - memory_->GetBase() < memory_->GetSize() - 1) {
+      BPLOG(ERROR) << "Memory out of range for stackwalking loongarch64: "
+          << HexString(memory_->GetBase())
+          << "+"
+          << HexString(memory_->GetSize());
+      memory_ = NULL;
+    }
+  }
+}
+
+StackFrame* StackwalkerLOONG64::GetContextFrame() {
+  if (!context_) {
+    BPLOG(ERROR) << "Can't get context frame without context";
+    return NULL;
+  }
+
+  StackFrameLOONG64* frame = new StackFrameLOONG64();
+
+  // The instruction pointer is stored directly in a register, so pull it
+  // straight out of the CPU context structure.
+  frame->context = *context_;
+  frame->context_validity = StackFrameMIPS::CONTEXT_VALID_ALL;
+  frame->trust = StackFrame::FRAME_TRUST_CONTEXT;
+  frame->instruction = frame->context.pc;
+
+  return frame;
+}
+
+StackFrameLOONG64* StackwalkerLOONG64::GetCallerByCFIFrameInfo(
+    const vector<StackFrame*>& frames,
+    CFIFrameInfo* cfi_frame_info) {
+  StackFrameLOONG64* last_frame = static_cast<StackFrameLOONG64*>(frames.back());
+
+  static const char* register_names[] = {
+    "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
+    NULL
+  };
+
+  // Populate a dictionary with the valid register values in last_frame.
+  CFIFrameInfo::RegisterValueMap<uint64_t> callee_registers;
+  for (int i = 0; register_names[i]; i++) {
+    if (last_frame->context_validity & StackFrameLOONG64::RegisterValidFlag(i))
+      callee_registers[register_names[i]] = last_frame->context.iregs[i];
+  }
+
+  // Use the STACK CFI data to recover the caller's register values.
+  CFIFrameInfo::RegisterValueMap<uint64_t> caller_registers;
+  if (!cfi_frame_info->FindCallerRegs(callee_registers, *memory_,
+                                      &caller_registers)) {
+    return NULL;
+  }
+  // Construct a new stack frame given the values the CFI recovered.
+  scoped_ptr<StackFrameLOONG64> frame(new StackFrameLOONG64());
+  for (int i = 0; register_names[i]; i++) {
+    CFIFrameInfo::RegisterValueMap<uint64_t>::iterator entry =
+      caller_registers.find(register_names[i]);
+    if (entry != caller_registers.end()) {
+      // We recovered the value of this register; fill the context with the
+      // value from caller_registers.
+      frame->context_validity |= StackFrameLOONG64::RegisterValidFlag(i);
+      frame->context.iregs[i] = entry->second;
+    } else if (22 <= i && i <= 31 && (last_frame->context_validity &
+                                      StackFrameLOONG64::RegisterValidFlag(i))) {
+      // If the STACK CFI data doesn't mention some callee-saves register, and
+      // it is valid in the callee, assume the callee has not yet changed it.
+      // Registers r22 through r31 are callee-saves, according to the Procedure
+      // Call Standard for the LoongArch64 Architecture, which the Linux ABI
+      // follows.
+      frame->context_validity |= StackFrameLOONG64::RegisterValidFlag(i);
+      frame->context.iregs[i] = last_frame->context.iregs[i];
+    }
+  }
+  // If the CFI doesn't recover the PC explicitly, then use .ra.
+  if (!(frame->context_validity & StackFrameLOONG64::CONTEXT_VALID_PC)) {
+    CFIFrameInfo::RegisterValueMap<uint64_t>::iterator entry =
+      caller_registers.find(".ra");
+    if (entry != caller_registers.end()) {
+      frame->context_validity |= StackFrameLOONG64::CONTEXT_VALID_PC;
+      frame->context.pc = entry->second;
+    }
+  }
+  // If the CFI doesn't recover the SP explicitly, then use .cfa.
+  if (!(frame->context_validity & StackFrameLOONG64::CONTEXT_VALID_SP)) {
+    CFIFrameInfo::RegisterValueMap<uint64_t>::iterator entry =
+      caller_registers.find(".cfa");
+    if (entry != caller_registers.end()) {
+      frame->context_validity |= StackFrameLOONG64::CONTEXT_VALID_SP;
+      frame->context.iregs[MD_CONTEXT_LOONG64_REG_SP] = entry->second;
+    }
+  }
+
+  // If we didn't recover the PC and the SP, then the frame isn't very useful.
+  static const uint64_t essentials = (StackFrameLOONG64::CONTEXT_VALID_SP
+                                     | StackFrameLOONG64::CONTEXT_VALID_PC);
+  if ((frame->context_validity & essentials) != essentials)
+    return NULL;
+
+  frame->trust = StackFrame::FRAME_TRUST_CFI;
+  return frame.release();
+}
+
+StackFrameLOONG64* StackwalkerLOONG64::GetCallerByStackScan(
+    const vector<StackFrame*>& frames) {
+  StackFrameLOONG64* last_frame = static_cast<StackFrameLOONG64*>(frames.back());
+  uint64_t last_sp = last_frame->context.iregs[MD_CONTEXT_LOONG64_REG_SP];
+  uint64_t caller_sp, caller_pc;
+
+  if (!ScanForReturnAddress(last_sp, &caller_sp, &caller_pc,
+                            frames.size() == 1 /* is_context_frame */)) {
+    // No plausible return address was found.
+    return NULL;
+  }
+
+  // ScanForReturnAddress found a reasonable return address. Advance
+  // %sp to the location above the one where the return address was
+  // found.
+  caller_sp += 8;
+
+  // Create a new stack frame (ownership will be transferred to the caller)
+  // and fill it in.
+  StackFrameLOONG64* frame = new StackFrameLOONG64();
+
+  frame->trust = StackFrame::FRAME_TRUST_SCAN;
+  frame->context = last_frame->context;
+  frame->context.pc = caller_pc;
+  frame->context.iregs[MD_CONTEXT_LOONG64_REG_SP] = caller_sp;
+  frame->context_validity = StackFrameLOONG64::CONTEXT_VALID_PC |
+                            StackFrameLOONG64::CONTEXT_VALID_SP;
+
+  return frame;
+}
+
+StackFrame* StackwalkerLOONG64::GetCallerFrame(const CallStack* stack,
+                                            bool stack_scan_allowed) {
+  if (!memory_ || !stack) {
+    BPLOG(ERROR) << "Can't get caller frame without memory or stack";
+    return NULL;
+  }
+
+  const vector<StackFrame*>& frames = *stack->frames();
+  StackFrameLOONG64* last_frame = static_cast<StackFrameLOONG64*>(frames.back());
+  scoped_ptr<StackFrameLOONG64> frame;
+
+  // See if there is DWARF call frame information covering this address.
+  scoped_ptr<CFIFrameInfo> cfi_frame_info(
+      frame_symbolizer_->FindCFIFrameInfo(last_frame));
+  if (cfi_frame_info.get())
+    frame.reset(GetCallerByCFIFrameInfo(frames, cfi_frame_info.get()));
+
+  // If everything failed, fall back to stack scanning.
+  if (stack_scan_allowed && !frame.get())
+    frame.reset(GetCallerByStackScan(frames));
+
+  // If nothing worked, tell the caller.
+  if (!frame.get())
+    return NULL;
+
+  // Should we terminate the stack walk? (end-of-stack or broken invariant)
+  if (TerminateWalk(frame->context.pc,
+                    frame->context.iregs[MD_CONTEXT_LOONG64_REG_SP],
+                    last_frame->context.iregs[MD_CONTEXT_LOONG64_REG_SP],
+                    frames.size() == 1)) {
+    return NULL;
+  }
+
+  // The new frame's context's PC is the return address, which is one
+  // instruction past the instruction that caused us to arrive at the callee.
+  // LOONG64 instructions have a uniform 4-byte encoding, so subtracting 4 off
+  // the return address gets back to the beginning of the call instruction.
+  // Callers that require the exact return address value may access
+  // frame->context.pc.
+  frame->instruction = frame->context.pc - 4;
+
+  return frame.release();
+}
+
+
+}  // namespace google_breakpad
diff --git a/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.h b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.h
new file mode 100644
index 0000000000..dbcfd014af
--- /dev/null
+++ b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64.h
@@ -0,0 +1,86 @@
+// -*- mode: C++ -*-
+
+// Copyright (c) 2021 Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// stackwalker_loong64.h: loong64-specific stackwalker.
+//
+// Provides stack frames given loong64 register context and a memory region
+// corresponding to an loong64 stack.
+//
+// Author: Zhao Jiazhong
+
+
+#ifndef PROCESSOR_STACKWALKER_LOONG64_H__
+#define PROCESSOR_STACKWALKER_LOONG64_H__
+
+#include "google_breakpad/common/breakpad_types.h"
+#include "google_breakpad/common/minidump_format.h"
+#include "google_breakpad/processor/stackwalker.h"
+
+namespace google_breakpad {
+
+class CodeModules;
+
+class StackwalkerLOONG64 : public Stackwalker {
+ public:
+  // context is an loong64 context object that gives access to loong64-specific
+  // register state corresponding to the innermost called frame to be
+  // included in the stack.  The other arguments are passed directly through
+  // to the base Stackwalker constructor.
+  StackwalkerLOONG64(const SystemInfo* system_info,
+                  const MDRawContextLOONG64* context,
+                  MemoryRegion* memory,
+                  const CodeModules* modules,
+                  StackFrameSymbolizer* frame_symbolizer);
+
+ private:
+  // Implementation of Stackwalker, using loong64 context and stack conventions.
+  virtual StackFrame* GetContextFrame();
+  virtual StackFrame* GetCallerFrame(const CallStack* stack,
+                                     bool stack_scan_allowed);
+
+  // Use cfi_frame_info (derived from STACK CFI records) to construct
+  // the frame that called frames.back(). The caller takes ownership
+  // of the returned frame. Return NULL on failure.
+  StackFrameLOONG64* GetCallerByCFIFrameInfo(const vector<StackFrame*>& frames,
+                                           CFIFrameInfo* cfi_frame_info);
+
+  // Scan the stack for plausible return addresses and frame pointer pair.
+  // The caller takes ownership of the returned frame. Return NULL on failure.
+  StackFrameLOONG64* GetCallerByStackScan(const vector<StackFrame*>& frames);
+
+  // Stores the CPU context corresponding to the innermost stack frame to
+  // be returned by GetContextFrame.
+  const MDRawContextLOONG64* context_;
+};
+
+}  // namespace google_breakpad
+
+#endif  // PROCESSOR_STACKWALKER_LOONG64_H__
diff --git a/third_party/breakpad/breakpad/src/processor/stackwalker_loong64_unittest.cc b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64_unittest.cc
new file mode 100644
index 0000000000..332e05471b
--- /dev/null
+++ b/third_party/breakpad/breakpad/src/processor/stackwalker_loong64_unittest.cc
@@ -0,0 +1 @@
+// TODO:LOONG64 Implement stackwalker_loong64_unittest
diff --git a/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc b/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
index 7e351d16f8..ec3f2f511b 100644
--- a/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
+++ b/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
@@ -77,6 +77,8 @@
   #define ELF_ARCH  EM_MIPS
 #elif defined(__aarch64__)
   #define ELF_ARCH  EM_AARCH64
+#elif defined(__loongarch__)
+  #define ELF_ARCH  EM_LOONGARCH
 #endif
 
 #if defined(__arm__)
@@ -306,7 +308,7 @@ struct CrashedProcess {
 
   struct Thread {
     pid_t tid;
-#if defined(__mips__)
+#if defined(__mips__) || defined(__loongarch__)
     mcontext_t mcontext;
 #else
     user_regs_struct regs;
@@ -533,6 +535,27 @@ ParseThreadRegisters(CrashedProcess::Thread* thread,
   thread->mcontext.fpc_eir = rawregs->float_save.fir;
 #endif
 }
+#elif defined(__loongarch64)
+static void
+ ParseThreadRegisters(CrashedProcess::Thread* thread,
+                      const MinidumpMemoryRange& range) {
+  const MDRawContextLOONG64* rawregs = range.GetData<MDRawContextLOONG64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    thread->mcontext.__gregs[i] = rawregs->iregs[i];
+
+  thread->mcontext.__pc = rawregs->pc;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i) {
+    // TODO:LOONG64 Support vector FPU
+    thread->mcontext.__fpregs[i].__val64[0] =
+        rawregs->float_save.regs[i];
+  }
+
+  thread->mcontext.__fcsr = rawregs->float_save.fcsr;
+  thread->mcontext.__vcsr = rawregs->float_save.fcsr;
+  thread->mcontext.__fcc = rawregs->float_save.fcc;
+ }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -622,6 +645,12 @@ ParseSystemInfo(const Options& options, CrashedProcess* crashinfo,
 # else
 #  error "This mips ABI is currently not supported (n32)"
 # endif
+#elif defined(__loongarch64)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_LOONG64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports LoongArch (64bit).\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -926,6 +955,8 @@ WriteThread(const Options& options, const CrashedProcess::Thread& thread,
   pr.pr_pid = thread.tid;
 #if defined(__mips__)
   memcpy(&pr.pr_reg, &thread.mcontext.gregs, sizeof(user_regs_struct));
+#elif defined(__loongarch__)
+  memcpy(&pr.pr_reg, &thread.mcontext.__gregs, sizeof(user_regs_struct));
 #else
   memcpy(&pr.pr_reg, &thread.regs, sizeof(user_regs_struct));
 #endif
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
index eccf204ca1..9e24ebaff5 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
@@ -164,7 +164,9 @@ class SignalHandler {
     exception_information_.context_address =
         FromPointerCast<decltype(exception_information_.context_address)>(
             context);
+#if !defined(__loongarch__)
     exception_information_.thread_id = sys_gettid();
+#endif
 
     ScopedPrSetDumpable set_dumpable(false);
     HandleCrashImpl();
@@ -245,7 +247,9 @@ class LaunchAtCrashHandler : public SignalHandler {
   }
 
   void HandleCrashImpl() override {
+#if !defined(__loongarch__)
     ScopedPrSetPtracer set_ptracer(sys_getpid(), /* may_log= */ false);
+#endif
 
     pid_t pid = fork();
     if (pid < 0) {
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 64c3c2371b..3c80d79226 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -135,6 +135,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(__loongarch__)
+  static constexpr char kCPU[] = "loong64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index 5c7ded46b1..010400a4a1 100644
--- a/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -108,7 +108,7 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
       MaybeCaptureMemoryAround(delegate, context.arm->regs[i]);
     }
   }
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
   for (size_t i = 0; i < base::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 811a720958..19183a3f9d 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -43,7 +43,10 @@ enum CPUArchitecture {
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit LoongArch.
+  kCPUArchitectureLOONG64
 };
 
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.h b/third_party/crashpad/crashpad/snapshot/cpu_context.h
index fb23c4679f..ad56b3bbe0 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -352,6 +352,28 @@ struct CPUContextMIPS64 {
   uint64_t fir;
 };
 
+struct CPUContextLOONG64 {
+  uint64_t regs[32];
+  uint64_t mdlo;
+  uint64_t mdhi;
+  uint64_t cp0_epc;
+  uint64_t cp0_badvaddr;
+  uint64_t cp0_status;
+  uint64_t cp0_cause;
+  uint64_t hi[3];
+  uint64_t lo[3];
+  uint64_t dsp_control;
+  union {
+    double dregs[32];
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+  } fpregs;
+  uint64_t fpcsr;
+  uint64_t fir;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -382,6 +404,7 @@ struct CPUContext {
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextLOONG64* loong64;
   };
 };
 
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 9f46a48977..ee9167509d 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -171,7 +171,23 @@ void InitializeCPUContextMIPS(
   context->fpcsr = float_context.fpcsr;
   context->fir = float_context.fpu_id;
 }
-
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+//! \brief Initializes a CPUContextMIPS structure from native context
+//!     structures on Linux.
+//!
+//! This function has template specializations for MIPSEL and MIPS64EL
+//! architecture contexts, using ContextTraits32 or ContextTraits64 as template
+//! parameter, respectively.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextMIPS structure to initialize.
+template <typename Traits>
+void InitializeCPUContextLOONG64(
+    const typename Traits::SignalThreadContext& thread_context,
+    const typename Traits::SignalFloatContext& float_context,
+    typename Traits::CPUContext* context) {
+}
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
 }  // namespace internal
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 42d0eb0b29..064690e0cb 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -42,7 +42,6 @@ ExceptionSnapshotLinux::ExceptionSnapshotLinux()
 ExceptionSnapshotLinux::~ExceptionSnapshotLinux() {}
 
 #if defined(ARCH_CPU_X86_FAMILY)
-
 template <>
 bool ExceptionSnapshotLinux::ReadContext<ContextTraits32>(
     ProcessReaderLinux* reader,
@@ -270,7 +269,7 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
 }
 
 #elif defined(ARCH_CPU_MIPS_FAMILY)
-
+//TODO
 template <typename Traits>
 static bool ReadContext(ProcessReaderLinux* reader,
                         LinuxVMAddress context_address,
@@ -324,6 +323,59 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  //const ProcessMemory* memory = reader->Memory();
+
+  //LinuxVMAddress gregs_address = context_address +
+  //                               offsetof(UContext<Traits>, mcontext) +
+  //                               offsetof(typename Traits::MContext, gregs);
+
+  //typename Traits::SignalThreadContext thread_context;
+  //if (!memory->Read(gregs_address, sizeof(thread_context), &thread_context)) {
+  //  LOG(ERROR) << "Couldn't read gregs";
+  //  return false;
+  //}
+
+  //LinuxVMAddress fpregs_address = context_address +
+  //                                offsetof(UContext<Traits>, mcontext) +
+  //                                offsetof(typename Traits::MContext, fpregs);
+
+  //typename Traits::SignalFloatContext fp_context;
+  //if (!memory->Read(fpregs_address, sizeof(fp_context), &fp_context)) {
+  //  LOG(ERROR) << "Couldn't read fpregs";
+  //  return false;
+  //}
+
+  //InitializeCPUContextLOONG64<Traits>(thread_context, fp_context, dest_context);
+
+  return true;
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits32>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONG64;
+  context_.loong64 = &context_union_.loong64;
+
+  return internal::ReadContext<ContextTraits32>(
+      reader, context_address, context_.loong64);
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONG64;
+  context_.loong64 = &context_union_.loong64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.loong64);
+}
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(ProcessReaderLinux* process_reader,
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index 1719f0be76..53e1d311f7 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -88,6 +88,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+    CPUContextLOONG64 loong64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index a9098ac803..1ef175d1e7 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -108,6 +108,9 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+  stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
+                                    : thread_info.thread_context.t32.regs[29];
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 110024680b..2cbdb1bd77 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -422,6 +422,98 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
               "context offset mismatch");
 #endif
 
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+//TODO
+struct MContext32 {
+  uint32_t regmask;
+  uint32_t status;
+  uint64_t pc;
+  uint64_t gregs[32];
+  struct {
+    float _fp_fregs;
+    unsigned int _fp_pad;
+  } fpregs[32];
+  uint32_t fp_owned;
+  uint32_t fpc_csr;
+  uint32_t fpc_eir;
+  uint32_t used_math;
+  uint32_t dsp;
+  uint64_t mdhi;
+  uint64_t mdlo;
+  uint32_t hi1;
+  uint32_t lo1;
+  uint32_t hi2;
+  uint32_t lo2;
+  uint32_t hi3;
+  uint32_t lo3;
+};
+
+struct MContext64 {
+  uint64_t gregs[32];
+  double fpregs[32];
+  uint64_t mdhi;
+  uint64_t hi1;
+  uint64_t hi2;
+  uint64_t hi3;
+  uint64_t mdlo;
+  uint64_t lo1;
+  uint64_t lo2;
+  uint64_t lo3;
+  uint64_t pc;
+  uint32_t fpc_csr;
+  uint32_t used_math;
+  uint32_t dsp;
+  uint32_t __glibc_reserved1;
+};
+
+struct SignalThreadContext32 {
+  uint64_t regs[32];
+  uint32_t lo;
+  uint32_t hi;
+  uint32_t cp0_epc;
+  uint32_t cp0_badvaddr;
+  uint32_t cp0_status;
+  uint32_t cp0_cause;
+
+  SignalThreadContext32() {}
+  explicit SignalThreadContext32(
+      const struct ThreadContext::t32_t& thread_context) {
+    for (size_t reg = 0; reg < 32; ++reg) {
+      regs[reg] = thread_context.regs[reg];
+    }
+    lo = thread_context.lo;
+    hi = thread_context.hi;
+    cp0_epc = thread_context.cp0_epc;
+    cp0_badvaddr = thread_context.cp0_badvaddr;
+    cp0_status = thread_context.cp0_status;
+    cp0_cause = thread_context.cp0_cause;
+  }
+};
+
+struct ContextTraits32 : public Traits32 {
+  using MContext = MContext32;
+  using SignalThreadContext = SignalThreadContext32;
+  using SignalFloatContext = FloatContext::f32_t;
+  using CPUContext = CPUContextLOONG64;
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONG64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  typename Traits::ULong_32Only alignment_padding_;
+  typename Traits::MContext mcontext;
+  Sigset<Traits> sigmask;
+};
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index a99da3e4b6..05c2675a3e 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -204,6 +204,7 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_LOONG_FAMILY)
 #else
 #error port to your architecture
 #endif
@@ -219,6 +220,8 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -239,6 +242,8 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -372,6 +377,8 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index f279e0adad..27ee0a9783 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -189,6 +189,8 @@ bool ThreadSnapshotLinux::Initialize(
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+  //TODO
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index 40cd7e7f54..638e110c07 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -73,6 +73,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONG_FAMILY)
+    CPUContextLOONG64 loong64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/util/linux/ptracer.cc b/third_party/crashpad/crashpad/util/linux/ptracer.cc
index 557e0d3635..e08501e99d 100644
--- a/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -273,7 +273,7 @@ bool GetThreadArea64(pid_t tid,
   }
   return true;
 }
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
 // PTRACE_GETREGSET, introduced in Linux 2.6.34 (2225a122ae26), requires kernel
 // support enabled by HAVE_ARCH_TRACEHOOK. This has been set for x86 (including
 // x86_64) since Linux 2.6.28 (99bbc4b1e677a), but for MIPS only since
@@ -296,7 +296,7 @@ bool GetGeneralPurposeRegistersLegacy(pid_t tid,
 // ptrace unsupported on MIPS for kernels older than 3.13
 #if defined(ARCH_CPU_MIPSEL)
 #define THREAD_CONTEXT_FIELD t32
-#elif defined(ARCH_CPU_MIPS64EL)
+#elif defined(ARCH_CPU_MIPS64EL) || defined(ARCH_CPU_LOONG_FAMILY)
 #define THREAD_CONTEXT_FIELD t64
 #endif
   for (size_t reg = 0; reg < 32; ++reg) {
@@ -385,6 +385,10 @@ bool GetThreadArea64(pid_t tid,
                      const ThreadContext& context,
                      LinuxVMAddress* address,
                      bool can_log) {
+#if defined(ARCH_CPU_LOONG64)
+  PLOG_IF(ERROR, can_log) << "GetThreadArea64 is not supported on loongarch64";
+  return false;
+#else
   void* result;
 #if defined(ARCH_CPU_MIPSEL)
   if (ptrace(PTRACE_GET_THREAD_AREA_3264, tid, nullptr, &result) != 0) {
@@ -396,6 +400,7 @@ bool GetThreadArea64(pid_t tid,
   }
   *address = FromPointerCast<LinuxVMAddress>(result);
   return true;
+#endif
 }
 
 #else
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 5b55c24a76..6f3c4ed885 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -67,7 +67,7 @@ union ThreadContext {
     uint32_t pc;
     uint32_t cpsr;
     uint32_t orig_r0;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
     // Reflects output format of static int gpr32_get(), defined in
     // arch/mips/kernel/ptrace.c in kernel source
     uint32_t padding0_[6];
@@ -122,7 +122,7 @@ union ThreadContext {
     uint64_t sp;
     uint64_t pc;
     uint64_t pstate;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
     // Reflects output format of static int gpr64_get(), defined in
     // arch/mips/kernel/ptrace.c in kernel source
     uint64_t regs[32];
@@ -141,13 +141,13 @@ union ThreadContext {
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
 // No appropriate NativeThreadsContext type available for MIPS
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64
 
-#if !defined(ARCH_CPU_MIPS_FAMILY)
+#if !defined(ARCH_CPU_MIPS_FAMILY) && !defined(ARCH_CPU_LOONG_FAMILY)
 #if defined(ARCH_CPU_32_BITS)
   static_assert(sizeof(t32_t) == sizeof(NativeThreadContext), "Size mismatch");
 #else  // ARCH_CPU_64_BITS
@@ -209,7 +209,7 @@ union FloatContext {
 
     bool have_fpregs;
     bool have_vfp;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
     // Reflects data format filled by ptrace_getfpregs() in
     // arch/mips/kernel/ptrace.c
     struct {
@@ -246,7 +246,7 @@ union FloatContext {
     uint32_t fpsr;
     uint32_t fpcr;
     uint8_t padding[8];
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
     // Reflects data format filled by ptrace_getfpregs() in
     // arch/mips/kernel/ptrace.c
     double fpregs[32];
@@ -278,7 +278,7 @@ union FloatContext {
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
 // No appropriate floating point context native type for available MIPS.
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index 7e3f41186f..17468decf5 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -237,6 +237,8 @@ std::string UserAgent() {
 #elif defined(ARCH_CPU_BIG_ENDIAN)
     static constexpr char arch[] = "aarch64_be";
 #endif
+#elif defined(ARCH_CPU_LOONG64)
+    static constexpr char arch[] = "loongarch64";
 #else
 #error Port
 #endif
diff --git a/third_party/dav1d/config/linux/loong64/config.h b/third_party/dav1d/config/linux/loong64/config.h
new file mode 100644
index 0000000000..f8a1ce1328
--- /dev/null
+++ b/third_party/dav1d/config/linux/loong64/config.h
@@ -0,0 +1,22 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+#pragma once
+#define ARCH_AARCH64 0
+#define ARCH_ARM 0
+#define ARCH_PPC64LE 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define CONFIG_16BPC 1
+#define CONFIG_8BPC 1
+// #define CONFIG_LOG 1 -- Logging is controlled by Chromium
+#define ENDIANNESS_BIG 0
+#define HAVE_ASM 0
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_DLSYM 1
+#define HAVE_POSIX_MEMALIGN 1
+// #define HAVE_PTHREAD_GETAFFINITY_NP 1 -- Controlled by Chomium
+#define HAVE_UNISTD_H 1
+// #define STACK_ALIGNMENT 32 -- Stack alignment is controlled by Chromium
diff --git a/third_party/dawn/src/common/Platform.h b/third_party/dawn/src/common/Platform.h
index f9471021fd..859930c689 100644
--- a/third_party/dawn/src/common/Platform.h
+++ b/third_party/dawn/src/common/Platform.h
@@ -68,7 +68,7 @@
 #endif
 
 #if defined(_WIN64) || defined(__aarch64__) || defined(__x86_64__) || defined(__mips64__) || \
-    defined(__s390x__) || defined(__PPC64__)
+    defined(__s390x__) || defined(__PPC64__) || defined(__loongarch64)
 #    define DAWN_PLATFORM_64_BIT 1
 static_assert(sizeof(sizeof(char)) == 8, "Expect sizeof(size_t) == 8");
 #elif defined(_WIN32) || defined(__arm__) || defined(__i386__) || defined(__mips32__) || \
diff --git a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
index 154241a270..4df8a16d88 100755
--- a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
+++ b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
@@ -40,7 +40,8 @@ BRANDINGS = [
 ARCH_MAP = {
     'android': ['ia32', 'x64', 'arm-neon', 'arm64'],
     'linux': [
-        'ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64'
+        #'ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64'
+        'x64', 'loong64'
     ],
     'mac': ['x64', 'arm64'],
     'win': ['ia32', 'x64', 'arm64'],
@@ -140,6 +141,8 @@ def DetermineHostOsAndArch():
     host_arch = 'mipsel'
   elif platform.machine() == 'mips64':
     host_arch = 'mips64el'
+  elif platform.machine() == 'loongarch64':
+    host_arch = 'loong64'
   elif platform.machine().startswith('arm'):
     host_arch = 'arm'
   else:
@@ -920,6 +923,20 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
             '--extra-cflags=--target=mips64el-linux-gnuabi64',
             '--extra-ldflags=--target=mips64el-linux-gnuabi64',
         ])
+    elif target_arch == 'loong64':
+      if target_os == 'linux':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--arch=loongarch64',
+            '--target-os=linux',
+            '--cc=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang',
+            '--cxx=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang++',
+            '--ld=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang',
+            '--sysroot=' + os.path.join(
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_sid_loong64-sysroot'),
+            '--extra-cflags=--target=loongarch64-linux-gnu ',
+            '--extra-ldflags=--target=loongarch64-linux-gnu ',
+        ])
     else:
       print(
           'Error: Unknown target arch %r for target OS %r!' % (target_arch,
@@ -934,12 +951,15 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
     ])
 
   if 'win' not in target_os and 'android' not in target_os:
-    configure_flags['Common'].extend([
-        '--enable-pic',
-        '--cc=clang',
-        '--cxx=clang++',
-        '--ld=clang',
-    ])
+    if target_arch != 'loong64':
+      configure_flags['Common'].extend([
+          '--enable-pic',
+          '--cc=clang',
+          '--cxx=clang++',
+          '--ld=clang',
+      ])
+    else:
+      configure_flags['Common'].extend(['--enable-pic'])
 
     # Clang Linux will use the first 'ld' it finds on the path, which will
     # typically be the system one, so explicitly configure use of Clang's
diff --git a/third_party/ffmpeg/chromium/scripts/copy_config.sh b/third_party/ffmpeg/chromium/scripts/copy_config.sh
index 0e5159d6f4..3874ae050c 100755
--- a/third_party/ffmpeg/chromium/scripts/copy_config.sh
+++ b/third_party/ffmpeg/chromium/scripts/copy_config.sh
@@ -10,7 +10,7 @@ for os in android linux linux-noasm mac win; do
     # Copy config files for various architectures:
     #   - ia32/x64 have config.asm, config.h
     #   - arm/arm-neon have config.h
-    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el; do
+    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el loong64; do
       # Don't waste time on non-existent configs, if no config.h then skip.
       [ ! -e "build.$arch.$os/$target/config.h" ] && continue
       for f in config.h config.asm libavutil/avconfig.h libavutil/ffversion.h libavcodec/bsf_list.c libavcodec/codec_list.c libavcodec/parser_list.c libavformat/demuxer_list.c libavformat/muxer_list.c libavformat/protocol_list.c; do
diff --git a/third_party/ffmpeg/chromium/scripts/generate_gn.py b/third_party/ffmpeg/chromium/scripts/generate_gn.py
index 2f0c90eeae..ae0da8a875 100755
--- a/third_party/ffmpeg/chromium/scripts/generate_gn.py
+++ b/third_party/ffmpeg/chromium/scripts/generate_gn.py
@@ -76,7 +76,7 @@ _Attrs = ('ARCHITECTURE', 'TARGET', 'PLATFORM')
 Attr = collections.namedtuple('Attr', _Attrs)(*_Attrs)
 SUPPORT_MATRIX = {
     Attr.ARCHITECTURE:
-        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon']),
+        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'loong64']),
     Attr.TARGET:
         set(['Chromium', 'Chrome', 'ChromeOS']),
     Attr.PLATFORM:
diff --git a/third_party/libvpx/BUILD.gn b/third_party/libvpx/BUILD.gn
index 758aca1540..b006aa3354 100644
--- a/third_party/libvpx/BUILD.gn
+++ b/third_party/libvpx/BUILD.gn
@@ -399,6 +399,8 @@ static_library("libvpx") {
       sources = libvpx_srcs_arm64
       public_deps = [ ":libvpx_arm64_headers" ]
     }
+  } else if (current_cpu == "loong64") {
+    sources = libvpx_srcs_generic
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff --git a/third_party/libvpx/source/config/linux/loong64/vp8_rtcd.h b/third_party/libvpx/source/config/linux/loong64/vp8_rtcd.h
new file mode 100644
index 0000000000..aa475b55fa
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vp8_rtcd.h
@@ -0,0 +1,357 @@
+// This file is generated. Do not edit.
+#ifndef VP8_RTCD_H_
+#define VP8_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP8
+ */
+
+struct blockd;
+struct macroblockd;
+struct loop_filter_info;
+
+/* Encoder forward decls */
+struct block;
+struct macroblock;
+struct variance_vtable;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_bilinear_predict16x16_c(unsigned char* src_ptr,
+                                 int src_pixels_per_line,
+                                 int xoffset,
+                                 int yoffset,
+                                 unsigned char* dst_ptr,
+                                 int dst_pitch);
+#define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_c
+
+void vp8_bilinear_predict4x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict4x4 vp8_bilinear_predict4x4_c
+
+void vp8_bilinear_predict8x4_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x4 vp8_bilinear_predict8x4_c
+
+void vp8_bilinear_predict8x8_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x8 vp8_bilinear_predict8x8_c
+
+void vp8_blend_b_c(unsigned char* y,
+                   unsigned char* u,
+                   unsigned char* v,
+                   int y_1,
+                   int u_1,
+                   int v_1,
+                   int alpha,
+                   int stride);
+#define vp8_blend_b vp8_blend_b_c
+
+void vp8_blend_mb_inner_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_inner vp8_blend_mb_inner_c
+
+void vp8_blend_mb_outer_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y_1,
+                          int u_1,
+                          int v_1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_outer vp8_blend_mb_outer_c
+
+int vp8_block_error_c(short* coeff, short* dqcoeff);
+#define vp8_block_error vp8_block_error_c
+
+void vp8_copy32xn_c(const unsigned char* src_ptr,
+                    int src_stride,
+                    unsigned char* dst_ptr,
+                    int dst_stride,
+                    int height);
+#define vp8_copy32xn vp8_copy32xn_c
+
+void vp8_copy_mem16x16_c(unsigned char* src,
+                         int src_stride,
+                         unsigned char* dst,
+                         int dst_stride);
+#define vp8_copy_mem16x16 vp8_copy_mem16x16_c
+
+void vp8_copy_mem8x4_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x4 vp8_copy_mem8x4_c
+
+void vp8_copy_mem8x8_c(unsigned char* src,
+                       int src_stride,
+                       unsigned char* dst,
+                       int dst_stride);
+#define vp8_copy_mem8x8 vp8_copy_mem8x8_c
+
+void vp8_dc_only_idct_add_c(short input_dc,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_dc_only_idct_add vp8_dc_only_idct_add_c
+
+int vp8_denoiser_filter_c(unsigned char* mc_running_avg_y,
+                          int mc_avg_y_stride,
+                          unsigned char* running_avg_y,
+                          int avg_y_stride,
+                          unsigned char* sig,
+                          int sig_stride,
+                          unsigned int motion_magnitude,
+                          int increase_denoising);
+#define vp8_denoiser_filter vp8_denoiser_filter_c
+
+int vp8_denoiser_filter_uv_c(unsigned char* mc_running_avg,
+                             int mc_avg_stride,
+                             unsigned char* running_avg,
+                             int avg_stride,
+                             unsigned char* sig,
+                             int sig_stride,
+                             unsigned int motion_magnitude,
+                             int increase_denoising);
+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c
+
+void vp8_dequant_idct_add_c(short* input,
+                            short* dq,
+                            unsigned char* dest,
+                            int stride);
+#define vp8_dequant_idct_add vp8_dequant_idct_add_c
+
+void vp8_dequant_idct_add_uv_block_c(short* q,
+                                     short* dq,
+                                     unsigned char* dst_u,
+                                     unsigned char* dst_v,
+                                     int stride,
+                                     char* eobs);
+#define vp8_dequant_idct_add_uv_block vp8_dequant_idct_add_uv_block_c
+
+void vp8_dequant_idct_add_y_block_c(short* q,
+                                    short* dq,
+                                    unsigned char* dst,
+                                    int stride,
+                                    char* eobs);
+#define vp8_dequant_idct_add_y_block vp8_dequant_idct_add_y_block_c
+
+void vp8_dequantize_b_c(struct blockd*, short* DQC);
+#define vp8_dequantize_b vp8_dequantize_b_c
+
+int vp8_diamond_search_sad_c(struct macroblock* x,
+                             struct block* b,
+                             struct blockd* d,
+                             union int_mv* ref_mv,
+                             union int_mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             struct variance_vtable* fn_ptr,
+                             int* mvcost[2],
+                             union int_mv* center_mv);
+#define vp8_diamond_search_sad vp8_diamond_search_sad_c
+
+void vp8_fast_quantize_b_c(struct block*, struct blockd*);
+#define vp8_fast_quantize_b vp8_fast_quantize_b_c
+
+void vp8_filter_by_weight16x16_c(unsigned char* src,
+                                 int src_stride,
+                                 unsigned char* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp8_filter_by_weight16x16 vp8_filter_by_weight16x16_c
+
+void vp8_filter_by_weight4x4_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight4x4 vp8_filter_by_weight4x4_c
+
+void vp8_filter_by_weight8x8_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight8x8 vp8_filter_by_weight8x8_c
+
+int vp8_full_search_sad_c(struct macroblock* x,
+                          struct block* b,
+                          struct blockd* d,
+                          union int_mv* ref_mv,
+                          int sad_per_bit,
+                          int distance,
+                          struct variance_vtable* fn_ptr,
+                          int* mvcost[2],
+                          union int_mv* center_mv);
+#define vp8_full_search_sad vp8_full_search_sad_c
+
+void vp8_loop_filter_bh_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bh vp8_loop_filter_bh_c
+
+void vp8_loop_filter_bv_c(unsigned char* y_ptr,
+                          unsigned char* u_ptr,
+                          unsigned char* v_ptr,
+                          int y_stride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bv vp8_loop_filter_bv_c
+
+void vp8_loop_filter_mbh_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbh vp8_loop_filter_mbh_c
+
+void vp8_loop_filter_mbv_c(unsigned char* y_ptr,
+                           unsigned char* u_ptr,
+                           unsigned char* v_ptr,
+                           int y_stride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbv vp8_loop_filter_mbv_c
+
+void vp8_loop_filter_bhs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bh vp8_loop_filter_bhs_c
+
+void vp8_loop_filter_bvs_c(unsigned char* y_ptr,
+                           int y_stride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bv vp8_loop_filter_bvs_c
+
+void vp8_loop_filter_simple_horizontal_edge_c(unsigned char* y_ptr,
+                                              int y_stride,
+                                              const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbh vp8_loop_filter_simple_horizontal_edge_c
+
+void vp8_loop_filter_simple_vertical_edge_c(unsigned char* y_ptr,
+                                            int y_stride,
+                                            const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbv vp8_loop_filter_simple_vertical_edge_c
+
+int vp8_mbblock_error_c(struct macroblock* mb, int dc);
+#define vp8_mbblock_error vp8_mbblock_error_c
+
+int vp8_mbuverror_c(struct macroblock* mb);
+#define vp8_mbuverror vp8_mbuverror_c
+
+int vp8_refining_search_sad_c(struct macroblock* x,
+                              struct block* b,
+                              struct blockd* d,
+                              union int_mv* ref_mv,
+                              int error_per_bit,
+                              int search_range,
+                              struct variance_vtable* fn_ptr,
+                              int* mvcost[2],
+                              union int_mv* center_mv);
+#define vp8_refining_search_sad vp8_refining_search_sad_c
+
+void vp8_regular_quantize_b_c(struct block*, struct blockd*);
+#define vp8_regular_quantize_b vp8_regular_quantize_b_c
+
+void vp8_short_fdct4x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct4x4 vp8_short_fdct4x4_c
+
+void vp8_short_fdct8x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct8x4 vp8_short_fdct8x4_c
+
+void vp8_short_idct4x4llm_c(short* input,
+                            unsigned char* pred_ptr,
+                            int pred_stride,
+                            unsigned char* dst_ptr,
+                            int dst_stride);
+#define vp8_short_idct4x4llm vp8_short_idct4x4llm_c
+
+void vp8_short_inv_walsh4x4_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4 vp8_short_inv_walsh4x4_c
+
+void vp8_short_inv_walsh4x4_1_c(short* input, short* mb_dqcoeff);
+#define vp8_short_inv_walsh4x4_1 vp8_short_inv_walsh4x4_1_c
+
+void vp8_short_walsh4x4_c(short* input, short* output, int pitch);
+#define vp8_short_walsh4x4 vp8_short_walsh4x4_c
+
+void vp8_sixtap_predict16x16_c(unsigned char* src_ptr,
+                               int src_pixels_per_line,
+                               int xoffset,
+                               int yoffset,
+                               unsigned char* dst_ptr,
+                               int dst_pitch);
+#define vp8_sixtap_predict16x16 vp8_sixtap_predict16x16_c
+
+void vp8_sixtap_predict4x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_c
+
+void vp8_sixtap_predict8x4_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x4 vp8_sixtap_predict8x4_c
+
+void vp8_sixtap_predict8x8_c(unsigned char* src_ptr,
+                             int src_pixels_per_line,
+                             int xoffset,
+                             int yoffset,
+                             unsigned char* dst_ptr,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_c
+
+void vp8_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff --git a/third_party/libvpx/source/config/linux/loong64/vp9_rtcd.h b/third_party/libvpx/source/config/linux/loong64/vp9_rtcd.h
new file mode 100644
index 0000000000..0091393148
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vp9_rtcd.h
@@ -0,0 +1,275 @@
+// This file is generated. Do not edit.
+#ifndef VP9_RTCD_H_
+#define VP9_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP9
+ */
+
+#include "vp9/common/vp9_common.h"
+#include "vp9/common/vp9_enums.h"
+#include "vp9/common/vp9_filter.h"
+#include "vpx/vpx_integer.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct vp9_variance_vtable;
+struct search_site_config;
+struct mv;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int64_t vp9_block_error_c(const tran_low_t* coeff,
+                          const tran_low_t* dqcoeff,
+                          intptr_t block_size,
+                          int64_t* ssz);
+#define vp9_block_error vp9_block_error_c
+
+int64_t vp9_block_error_fp_c(const tran_low_t* coeff,
+                             const tran_low_t* dqcoeff,
+                             int block_size);
+#define vp9_block_error_fp vp9_block_error_fp_c
+
+int vp9_denoiser_filter_c(const uint8_t* sig,
+                          int sig_stride,
+                          const uint8_t* mc_avg,
+                          int mc_avg_stride,
+                          uint8_t* avg,
+                          int avg_stride,
+                          int increase_denoising,
+                          BLOCK_SIZE bs,
+                          int motion_magnitude);
+#define vp9_denoiser_filter vp9_denoiser_filter_c
+
+int vp9_diamond_search_sad_c(const struct macroblock* x,
+                             const struct search_site_config* cfg,
+                             struct mv* ref_mv,
+                             struct mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             const struct vp9_variance_vtable* fn_ptr,
+                             const struct mv* center_mv);
+#define vp9_diamond_search_sad vp9_diamond_search_sad_c
+
+void vp9_fht16x16_c(const int16_t* input,
+                    tran_low_t* output,
+                    int stride,
+                    int tx_type);
+#define vp9_fht16x16 vp9_fht16x16_c
+
+void vp9_fht4x4_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht4x4 vp9_fht4x4_c
+
+void vp9_fht8x8_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht8x8 vp9_fht8x8_c
+
+void vp9_filter_by_weight16x16_c(const uint8_t* src,
+                                 int src_stride,
+                                 uint8_t* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp9_filter_by_weight16x16 vp9_filter_by_weight16x16_c
+
+void vp9_filter_by_weight8x8_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp9_filter_by_weight8x8 vp9_filter_by_weight8x8_c
+
+void vp9_fwht4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vp9_fwht4x4 vp9_fwht4x4_c
+
+int64_t vp9_highbd_block_error_c(const tran_low_t* coeff,
+                                 const tran_low_t* dqcoeff,
+                                 intptr_t block_size,
+                                 int64_t* ssz,
+                                 int bd);
+#define vp9_highbd_block_error vp9_highbd_block_error_c
+
+void vp9_highbd_fht16x16_c(const int16_t* input,
+                           tran_low_t* output,
+                           int stride,
+                           int tx_type);
+#define vp9_highbd_fht16x16 vp9_highbd_fht16x16_c
+
+void vp9_highbd_fht4x4_c(const int16_t* input,
+                         tran_low_t* output,
+                         int stride,
+                         int tx_type);
+#define vp9_highbd_fht4x4 vp9_highbd_fht4x4_c
+
+void vp9_highbd_fht8x8_c(const int16_t* input,
+                         tran_low_t* output,
+                         int stride,
+                         int tx_type);
+#define vp9_highbd_fht8x8 vp9_highbd_fht8x8_c
+
+void vp9_highbd_fwht4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vp9_highbd_fwht4x4 vp9_highbd_fwht4x4_c
+
+void vp9_highbd_iht16x16_256_add_c(const tran_low_t* input,
+                                   uint16_t* dest,
+                                   int stride,
+                                   int tx_type,
+                                   int bd);
+#define vp9_highbd_iht16x16_256_add vp9_highbd_iht16x16_256_add_c
+
+void vp9_highbd_iht4x4_16_add_c(const tran_low_t* input,
+                                uint16_t* dest,
+                                int stride,
+                                int tx_type,
+                                int bd);
+#define vp9_highbd_iht4x4_16_add vp9_highbd_iht4x4_16_add_c
+
+void vp9_highbd_iht8x8_64_add_c(const tran_low_t* input,
+                                uint16_t* dest,
+                                int stride,
+                                int tx_type,
+                                int bd);
+#define vp9_highbd_iht8x8_64_add vp9_highbd_iht8x8_64_add_c
+
+void vp9_highbd_mbpost_proc_across_ip_c(uint16_t* src,
+                                        int pitch,
+                                        int rows,
+                                        int cols,
+                                        int flimit);
+#define vp9_highbd_mbpost_proc_across_ip vp9_highbd_mbpost_proc_across_ip_c
+
+void vp9_highbd_mbpost_proc_down_c(uint16_t* dst,
+                                   int pitch,
+                                   int rows,
+                                   int cols,
+                                   int flimit);
+#define vp9_highbd_mbpost_proc_down vp9_highbd_mbpost_proc_down_c
+
+void vp9_highbd_post_proc_down_and_across_c(const uint16_t* src_ptr,
+                                            uint16_t* dst_ptr,
+                                            int src_pixels_per_line,
+                                            int dst_pixels_per_line,
+                                            int rows,
+                                            int cols,
+                                            int flimit);
+#define vp9_highbd_post_proc_down_and_across \
+  vp9_highbd_post_proc_down_and_across_c
+
+void vp9_highbd_quantize_fp_c(const tran_low_t* coeff_ptr,
+                              intptr_t n_coeffs,
+                              int skip_block,
+                              const int16_t* round_ptr,
+                              const int16_t* quant_ptr,
+                              tran_low_t* qcoeff_ptr,
+                              tran_low_t* dqcoeff_ptr,
+                              const int16_t* dequant_ptr,
+                              uint16_t* eob_ptr,
+                              const int16_t* scan,
+                              const int16_t* iscan);
+#define vp9_highbd_quantize_fp vp9_highbd_quantize_fp_c
+
+void vp9_highbd_quantize_fp_32x32_c(const tran_low_t* coeff_ptr,
+                                    intptr_t n_coeffs,
+                                    int skip_block,
+                                    const int16_t* round_ptr,
+                                    const int16_t* quant_ptr,
+                                    tran_low_t* qcoeff_ptr,
+                                    tran_low_t* dqcoeff_ptr,
+                                    const int16_t* dequant_ptr,
+                                    uint16_t* eob_ptr,
+                                    const int16_t* scan,
+                                    const int16_t* iscan);
+#define vp9_highbd_quantize_fp_32x32 vp9_highbd_quantize_fp_32x32_c
+
+void vp9_highbd_temporal_filter_apply_c(const uint8_t* frame1,
+                                        unsigned int stride,
+                                        const uint8_t* frame2,
+                                        unsigned int block_width,
+                                        unsigned int block_height,
+                                        int strength,
+                                        int* blk_fw,
+                                        int use_32x32,
+                                        uint32_t* accumulator,
+                                        uint16_t* count);
+#define vp9_highbd_temporal_filter_apply vp9_highbd_temporal_filter_apply_c
+
+void vp9_iht16x16_256_add_c(const tran_low_t* input,
+                            uint8_t* dest,
+                            int stride,
+                            int tx_type);
+#define vp9_iht16x16_256_add vp9_iht16x16_256_add_c
+
+void vp9_iht4x4_16_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht4x4_16_add vp9_iht4x4_16_add_c
+
+void vp9_iht8x8_64_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+#define vp9_iht8x8_64_add vp9_iht8x8_64_add_c
+
+void vp9_quantize_fp_c(const tran_low_t* coeff_ptr,
+                       intptr_t n_coeffs,
+                       int skip_block,
+                       const int16_t* round_ptr,
+                       const int16_t* quant_ptr,
+                       tran_low_t* qcoeff_ptr,
+                       tran_low_t* dqcoeff_ptr,
+                       const int16_t* dequant_ptr,
+                       uint16_t* eob_ptr,
+                       const int16_t* scan,
+                       const int16_t* iscan);
+#define vp9_quantize_fp vp9_quantize_fp_c
+
+void vp9_quantize_fp_32x32_c(const tran_low_t* coeff_ptr,
+                             intptr_t n_coeffs,
+                             int skip_block,
+                             const int16_t* round_ptr,
+                             const int16_t* quant_ptr,
+                             tran_low_t* qcoeff_ptr,
+                             tran_low_t* dqcoeff_ptr,
+                             const int16_t* dequant_ptr,
+                             uint16_t* eob_ptr,
+                             const int16_t* scan,
+                             const int16_t* iscan);
+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_c
+
+void vp9_scale_and_extend_frame_c(const struct yv12_buffer_config* src,
+                                  struct yv12_buffer_config* dst,
+                                  INTERP_FILTER filter_type,
+                                  int phase_scaler);
+#define vp9_scale_and_extend_frame vp9_scale_and_extend_frame_c
+
+void vp9_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff --git a/third_party/libvpx/source/config/linux/loong64/vpx_config.asm b/third_party/libvpx/source/config/linux/loong64/vpx_config.asm
new file mode 100644
index 0000000000..00712e52bb
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vpx_config.asm
@@ -0,0 +1,98 @@
+@ This file was created from a .asm file
+@  using the ads2gas.pl script.
+	.syntax unified
+.equ VPX_ARCH_ARM ,  0
+.equ ARCH_ARM ,  0
+.equ VPX_ARCH_MIPS ,  0
+.equ ARCH_MIPS ,  0
+.equ VPX_ARCH_X86 ,  0
+.equ ARCH_X86 ,  0
+.equ VPX_ARCH_X86_64 ,  0
+.equ ARCH_X86_64 ,  0
+.equ VPX_ARCH_PPC ,  0
+.equ ARCH_PPC ,  0
+.equ HAVE_NEON ,  0
+.equ HAVE_NEON_ASM ,  0
+.equ HAVE_MIPS32 ,  0
+.equ HAVE_DSPR2 ,  0
+.equ HAVE_MSA ,  0
+.equ HAVE_MIPS64 ,  0
+.equ HAVE_MMX ,  0
+.equ HAVE_SSE ,  0
+.equ HAVE_SSE2 ,  0
+.equ HAVE_SSE3 ,  0
+.equ HAVE_SSSE3 ,  0
+.equ HAVE_SSE4_1 ,  0
+.equ HAVE_AVX ,  0
+.equ HAVE_AVX2 ,  0
+.equ HAVE_AVX512 ,  0
+.equ HAVE_VSX ,  0
+.equ HAVE_MMI ,  0
+.equ HAVE_VPX_PORTS ,  1
+.equ HAVE_PTHREAD_H ,  1
+.equ HAVE_UNISTD_H ,  0
+.equ CONFIG_DEPENDENCY_TRACKING ,  1
+.equ CONFIG_EXTERNAL_BUILD ,  1
+.equ CONFIG_INSTALL_DOCS ,  0
+.equ CONFIG_INSTALL_BINS ,  1
+.equ CONFIG_INSTALL_LIBS ,  1
+.equ CONFIG_INSTALL_SRCS ,  0
+.equ CONFIG_DEBUG ,  0
+.equ CONFIG_GPROF ,  0
+.equ CONFIG_GCOV ,  0
+.equ CONFIG_RVCT ,  0
+.equ CONFIG_GCC ,  1
+.equ CONFIG_MSVS ,  0
+.equ CONFIG_PIC ,  0
+.equ CONFIG_BIG_ENDIAN ,  0
+.equ CONFIG_CODEC_SRCS ,  0
+.equ CONFIG_DEBUG_LIBS ,  0
+.equ CONFIG_DEQUANT_TOKENS ,  0
+.equ CONFIG_DC_RECON ,  0
+.equ CONFIG_RUNTIME_CPU_DETECT ,  0
+.equ CONFIG_POSTPROC ,  1
+.equ CONFIG_VP9_POSTPROC ,  1
+.equ CONFIG_MULTITHREAD ,  1
+.equ CONFIG_INTERNAL_STATS ,  0
+.equ CONFIG_VP8_ENCODER ,  1
+.equ CONFIG_VP8_DECODER ,  1
+.equ CONFIG_VP9_ENCODER ,  1
+.equ CONFIG_VP9_DECODER ,  1
+.equ CONFIG_VP8 ,  1
+.equ CONFIG_VP9 ,  1
+.equ CONFIG_ENCODERS ,  1
+.equ CONFIG_DECODERS ,  1
+.equ CONFIG_STATIC_MSVCRT ,  0
+.equ CONFIG_SPATIAL_RESAMPLING ,  1
+.equ CONFIG_REALTIME_ONLY ,  1
+.equ CONFIG_ONTHEFLY_BITPACKING ,  0
+.equ CONFIG_ERROR_CONCEALMENT ,  0
+.equ CONFIG_SHARED ,  0
+.equ CONFIG_STATIC ,  1
+.equ CONFIG_SMALL ,  0
+.equ CONFIG_POSTPROC_VISUALIZER ,  0
+.equ CONFIG_OS_SUPPORT ,  1
+.equ CONFIG_UNIT_TESTS ,  1
+.equ CONFIG_WEBM_IO ,  1
+.equ CONFIG_LIBYUV ,  0
+.equ CONFIG_DECODE_PERF_TESTS ,  0
+.equ CONFIG_ENCODE_PERF_TESTS ,  0
+.equ CONFIG_MULTI_RES_ENCODING ,  1
+.equ CONFIG_TEMPORAL_DENOISING ,  1
+.equ CONFIG_VP9_TEMPORAL_DENOISING ,  1
+.equ CONFIG_CONSISTENT_RECODE ,  0
+.equ CONFIG_COEFFICIENT_RANGE_CHECKING ,  0
+.equ CONFIG_VP9_HIGHBITDEPTH ,  1
+.equ CONFIG_BETTER_HW_COMPATIBILITY ,  0
+.equ CONFIG_EXPERIMENTAL ,  0
+.equ CONFIG_SIZE_LIMIT ,  1
+.equ CONFIG_ALWAYS_ADJUST_BPM ,  0
+.equ CONFIG_BITSTREAM_DEBUG ,  0
+.equ CONFIG_MISMATCH_DEBUG ,  0
+.equ CONFIG_FP_MB_STATS ,  0
+.equ CONFIG_EMULATE_HARDWARE ,  0
+.equ CONFIG_NON_GREEDY_MV ,  0
+.equ CONFIG_RATE_CTRL ,  0
+.equ DECODE_WIDTH_LIMIT ,  16384
+.equ DECODE_HEIGHT_LIMIT ,  16384
+	.section	.note.GNU-stack,"",%progbits
diff --git a/third_party/libvpx/source/config/linux/loong64/vpx_config.c b/third_party/libvpx/source/config/linux/loong64/vpx_config.c
new file mode 100644
index 0000000000..8aad25ff17
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vpx_config.c
@@ -0,0 +1,10 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+#include "vpx/vpx_codec.h"
+static const char* const cfg = "--target=generic-gnu --enable-vp9-highbitdepth --enable-external-build --enable-postproc --enable-multi-res-encoding --enable-temporal-denoising --enable-vp9-temporal-denoising --enable-vp9-postproc --size-limit=16384x16384 --enable-realtime-only --disable-install-docs --disable-libyuv";
+const char *vpx_codec_build_config(void) {return cfg;}
diff --git a/third_party/libvpx/source/config/linux/loong64/vpx_config.h b/third_party/libvpx/source/config/linux/loong64/vpx_config.h
new file mode 100644
index 0000000000..fddb76bd2f
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vpx_config.h
@@ -0,0 +1,107 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+/* This file automatically generated by configure. Do not edit! */
+#ifndef VPX_CONFIG_H
+#define VPX_CONFIG_H
+#define RESTRICT    
+#define INLINE      inline
+#define VPX_ARCH_ARM 0
+#define ARCH_ARM 0
+#define VPX_ARCH_MIPS 0
+#define ARCH_MIPS 0
+#define VPX_ARCH_X86 0
+#define ARCH_X86 0
+#define VPX_ARCH_X86_64 0
+#define ARCH_X86_64 0
+#define VPX_ARCH_PPC 0
+#define ARCH_PPC 0
+#define HAVE_NEON 0
+#define HAVE_NEON_ASM 0
+#define HAVE_MIPS32 0
+#define HAVE_DSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MIPS64 0
+#define HAVE_MMX 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSSE3 0
+#define HAVE_SSE4_1 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_VSX 0
+#define HAVE_MMI 0
+#define HAVE_VPX_PORTS 1
+#define HAVE_PTHREAD_H 1
+#define HAVE_UNISTD_H 0
+#define CONFIG_DEPENDENCY_TRACKING 1
+#define CONFIG_EXTERNAL_BUILD 1
+#define CONFIG_INSTALL_DOCS 0
+#define CONFIG_INSTALL_BINS 1
+#define CONFIG_INSTALL_LIBS 1
+#define CONFIG_INSTALL_SRCS 0
+#define CONFIG_DEBUG 0
+#define CONFIG_GPROF 0
+#define CONFIG_GCOV 0
+#define CONFIG_RVCT 0
+#define CONFIG_GCC 1
+#define CONFIG_MSVS 0
+#define CONFIG_PIC 0
+#define CONFIG_BIG_ENDIAN 0
+#define CONFIG_CODEC_SRCS 0
+#define CONFIG_DEBUG_LIBS 0
+#define CONFIG_DEQUANT_TOKENS 0
+#define CONFIG_DC_RECON 0
+#define CONFIG_RUNTIME_CPU_DETECT 0
+#define CONFIG_POSTPROC 1
+#define CONFIG_VP9_POSTPROC 1
+#define CONFIG_MULTITHREAD 1
+#define CONFIG_INTERNAL_STATS 0
+#define CONFIG_VP8_ENCODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP9_ENCODER 1
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_VP8 1
+#define CONFIG_VP9 1
+#define CONFIG_ENCODERS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_STATIC_MSVCRT 0
+#define CONFIG_SPATIAL_RESAMPLING 1
+#define CONFIG_REALTIME_ONLY 1
+#define CONFIG_ONTHEFLY_BITPACKING 0
+#define CONFIG_ERROR_CONCEALMENT 0
+#define CONFIG_SHARED 0
+#define CONFIG_STATIC 1
+#define CONFIG_SMALL 0
+#define CONFIG_POSTPROC_VISUALIZER 0
+#define CONFIG_OS_SUPPORT 1
+#define CONFIG_UNIT_TESTS 1
+#define CONFIG_WEBM_IO 1
+#define CONFIG_LIBYUV 0
+#define CONFIG_DECODE_PERF_TESTS 0
+#define CONFIG_ENCODE_PERF_TESTS 0
+#define CONFIG_MULTI_RES_ENCODING 1
+#define CONFIG_TEMPORAL_DENOISING 1
+#define CONFIG_VP9_TEMPORAL_DENOISING 1
+#define CONFIG_CONSISTENT_RECODE 0
+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0
+#define CONFIG_VP9_HIGHBITDEPTH 1
+#define CONFIG_BETTER_HW_COMPATIBILITY 0
+#define CONFIG_EXPERIMENTAL 0
+#define CONFIG_SIZE_LIMIT 1
+#define CONFIG_ALWAYS_ADJUST_BPM 0
+#define CONFIG_BITSTREAM_DEBUG 0
+#define CONFIG_MISMATCH_DEBUG 0
+#define CONFIG_FP_MB_STATS 0
+#define CONFIG_EMULATE_HARDWARE 0
+#define CONFIG_NON_GREEDY_MV 0
+#define CONFIG_RATE_CTRL 0
+#define DECODE_WIDTH_LIMIT 16384
+#define DECODE_HEIGHT_LIMIT 16384
+#endif /* VPX_CONFIG_H */
diff --git a/third_party/libvpx/source/config/linux/loong64/vpx_dsp_rtcd.h b/third_party/libvpx/source/config/linux/loong64/vpx_dsp_rtcd.h
new file mode 100644
index 0000000000..8ba4d88055
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vpx_dsp_rtcd.h
@@ -0,0 +1,3868 @@
+// This file is generated. Do not edit.
+#ifndef VPX_DSP_RTCD_H_
+#define VPX_DSP_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * DSP
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vpx_dsp/vpx_dsp_common.h"
+#include "vpx_dsp/vpx_filter.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+unsigned int vpx_avg_4x4_c(const uint8_t*, int p);
+#define vpx_avg_4x4 vpx_avg_4x4_c
+
+unsigned int vpx_avg_8x8_c(const uint8_t*, int p);
+#define vpx_avg_8x8 vpx_avg_8x8_c
+
+void vpx_comp_avg_pred_c(uint8_t* comp_pred,
+                         const uint8_t* pred,
+                         int width,
+                         int height,
+                         const uint8_t* ref,
+                         int ref_stride);
+#define vpx_comp_avg_pred vpx_comp_avg_pred_c
+
+void vpx_convolve8_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_convolve8 vpx_convolve8_c
+
+void vpx_convolve8_avg_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve8_avg vpx_convolve8_avg_c
+
+void vpx_convolve8_avg_horiz_c(const uint8_t* src,
+                               ptrdiff_t src_stride,
+                               uint8_t* dst,
+                               ptrdiff_t dst_stride,
+                               const InterpKernel* filter,
+                               int x0_q4,
+                               int x_step_q4,
+                               int y0_q4,
+                               int y_step_q4,
+                               int w,
+                               int h);
+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_c
+
+void vpx_convolve8_avg_vert_c(const uint8_t* src,
+                              ptrdiff_t src_stride,
+                              uint8_t* dst,
+                              ptrdiff_t dst_stride,
+                              const InterpKernel* filter,
+                              int x0_q4,
+                              int x_step_q4,
+                              int y0_q4,
+                              int y_step_q4,
+                              int w,
+                              int h);
+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_c
+
+void vpx_convolve8_horiz_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_convolve8_horiz vpx_convolve8_horiz_c
+
+void vpx_convolve8_vert_c(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const InterpKernel* filter,
+                          int x0_q4,
+                          int x_step_q4,
+                          int y0_q4,
+                          int y_step_q4,
+                          int w,
+                          int h);
+#define vpx_convolve8_vert vpx_convolve8_vert_c
+
+void vpx_convolve_avg_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_convolve_avg vpx_convolve_avg_c
+
+void vpx_convolve_copy_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_convolve_copy vpx_convolve_copy_c
+
+void vpx_d117_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c
+
+void vpx_d117_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c
+
+void vpx_d117_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c
+
+void vpx_d117_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c
+
+void vpx_d135_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c
+
+void vpx_d135_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c
+
+void vpx_d135_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c
+
+void vpx_d135_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c
+
+void vpx_d153_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c
+
+void vpx_d153_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c
+
+void vpx_d153_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c
+
+void vpx_d153_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c
+
+void vpx_d207_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c
+
+void vpx_d207_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c
+
+void vpx_d207_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c
+
+void vpx_d207_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c
+
+void vpx_d45_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_c
+
+void vpx_d45_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_c
+
+void vpx_d45_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c
+
+void vpx_d45_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_c
+
+void vpx_d45e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d45e_predictor_4x4 vpx_d45e_predictor_4x4_c
+
+void vpx_d63_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_c
+
+void vpx_d63_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_c
+
+void vpx_d63_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c
+
+void vpx_d63_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_c
+
+void vpx_d63e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d63e_predictor_4x4 vpx_d63e_predictor_4x4_c
+
+void vpx_dc_128_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_c
+
+void vpx_dc_128_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_c
+
+void vpx_dc_128_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c
+
+void vpx_dc_128_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c
+
+void vpx_dc_left_predictor_16x16_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_c
+
+void vpx_dc_left_predictor_32x32_c(uint8_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_c
+
+void vpx_dc_left_predictor_4x4_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c
+
+void vpx_dc_left_predictor_8x8_c(uint8_t* dst,
+                                 ptrdiff_t stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c
+
+void vpx_dc_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_c
+
+void vpx_dc_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_c
+
+void vpx_dc_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c
+
+void vpx_dc_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_c
+
+void vpx_dc_top_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_c
+
+void vpx_dc_top_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_c
+
+void vpx_dc_top_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c
+
+void vpx_dc_top_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c
+
+void vpx_fdct16x16_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16 vpx_fdct16x16_c
+
+void vpx_fdct16x16_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c
+
+void vpx_fdct32x32_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32 vpx_fdct32x32_c
+
+void vpx_fdct32x32_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c
+
+void vpx_fdct32x32_rd_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_c
+
+void vpx_fdct4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4 vpx_fdct4x4_c
+
+void vpx_fdct4x4_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c
+
+void vpx_fdct8x8_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8 vpx_fdct8x8_c
+
+void vpx_fdct8x8_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c
+
+void vpx_get16x16var_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* ref_ptr,
+                       int ref_stride,
+                       unsigned int* sse,
+                       int* sum);
+#define vpx_get16x16var vpx_get16x16var_c
+
+unsigned int vpx_get4x4sse_cs_c(const unsigned char* src_ptr,
+                                int src_stride,
+                                const unsigned char* ref_ptr,
+                                int ref_stride);
+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_c
+
+void vpx_get8x8var_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     unsigned int* sse,
+                     int* sum);
+#define vpx_get8x8var vpx_get8x8var_c
+
+unsigned int vpx_get_mb_ss_c(const int16_t*);
+#define vpx_get_mb_ss vpx_get_mb_ss_c
+
+void vpx_h_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_c
+
+void vpx_h_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_c
+
+void vpx_h_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_c
+
+void vpx_h_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_c
+
+void vpx_hadamard_16x16_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          tran_low_t* coeff);
+#define vpx_hadamard_16x16 vpx_hadamard_16x16_c
+
+void vpx_hadamard_32x32_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          tran_low_t* coeff);
+#define vpx_hadamard_32x32 vpx_hadamard_32x32_c
+
+void vpx_hadamard_8x8_c(const int16_t* src_diff,
+                        ptrdiff_t src_stride,
+                        tran_low_t* coeff);
+#define vpx_hadamard_8x8 vpx_hadamard_8x8_c
+
+void vpx_he_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_he_predictor_4x4 vpx_he_predictor_4x4_c
+
+void vpx_highbd_10_get16x16var_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse,
+                                 int* sum);
+#define vpx_highbd_10_get16x16var vpx_highbd_10_get16x16var_c
+
+void vpx_highbd_10_get8x8var_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse,
+                               int* sum);
+#define vpx_highbd_10_get8x8var vpx_highbd_10_get8x8var_c
+
+unsigned int vpx_highbd_10_mse16x16_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      unsigned int* sse);
+#define vpx_highbd_10_mse16x16 vpx_highbd_10_mse16x16_c
+
+unsigned int vpx_highbd_10_mse16x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     unsigned int* sse);
+#define vpx_highbd_10_mse16x8 vpx_highbd_10_mse16x8_c
+
+unsigned int vpx_highbd_10_mse8x16_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     unsigned int* sse);
+#define vpx_highbd_10_mse8x16 vpx_highbd_10_mse8x16_c
+
+unsigned int vpx_highbd_10_mse8x8_c(const uint8_t* src_ptr,
+                                    int src_stride,
+                                    const uint8_t* ref_ptr,
+                                    int ref_stride,
+                                    unsigned int* sse);
+#define vpx_highbd_10_mse8x8 vpx_highbd_10_mse8x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance16x16_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance16x16 \
+  vpx_highbd_10_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance16x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance16x32 \
+  vpx_highbd_10_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance16x8 \
+  vpx_highbd_10_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance32x16_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance32x16 \
+  vpx_highbd_10_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance32x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance32x32 \
+  vpx_highbd_10_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance32x64_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance32x64 \
+  vpx_highbd_10_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance4x4 \
+  vpx_highbd_10_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance4x8 \
+  vpx_highbd_10_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance64x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance64x32 \
+  vpx_highbd_10_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance64x64_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance64x64 \
+  vpx_highbd_10_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance8x16 \
+  vpx_highbd_10_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance8x4 \
+  vpx_highbd_10_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_highbd_10_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_10_sub_pixel_avg_variance8x8 \
+  vpx_highbd_10_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance16x16 \
+  vpx_highbd_10_sub_pixel_variance16x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance16x32 \
+  vpx_highbd_10_sub_pixel_variance16x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance16x8 \
+  vpx_highbd_10_sub_pixel_variance16x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance32x16 \
+  vpx_highbd_10_sub_pixel_variance32x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance32x32 \
+  vpx_highbd_10_sub_pixel_variance32x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance32x64 \
+  vpx_highbd_10_sub_pixel_variance32x64_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance4x4 \
+  vpx_highbd_10_sub_pixel_variance4x4_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance4x8 \
+  vpx_highbd_10_sub_pixel_variance4x8_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance64x32 \
+  vpx_highbd_10_sub_pixel_variance64x32_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance64x64 \
+  vpx_highbd_10_sub_pixel_variance64x64_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance8x16 \
+  vpx_highbd_10_sub_pixel_variance8x16_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance8x4 \
+  vpx_highbd_10_sub_pixel_variance8x4_c
+
+uint32_t vpx_highbd_10_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_10_sub_pixel_variance8x8 \
+  vpx_highbd_10_sub_pixel_variance8x8_c
+
+unsigned int vpx_highbd_10_variance16x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance16x16 vpx_highbd_10_variance16x16_c
+
+unsigned int vpx_highbd_10_variance16x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance16x32 vpx_highbd_10_variance16x32_c
+
+unsigned int vpx_highbd_10_variance16x8_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_10_variance16x8 vpx_highbd_10_variance16x8_c
+
+unsigned int vpx_highbd_10_variance32x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance32x16 vpx_highbd_10_variance32x16_c
+
+unsigned int vpx_highbd_10_variance32x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance32x32 vpx_highbd_10_variance32x32_c
+
+unsigned int vpx_highbd_10_variance32x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance32x64 vpx_highbd_10_variance32x64_c
+
+unsigned int vpx_highbd_10_variance4x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_10_variance4x4 vpx_highbd_10_variance4x4_c
+
+unsigned int vpx_highbd_10_variance4x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_10_variance4x8 vpx_highbd_10_variance4x8_c
+
+unsigned int vpx_highbd_10_variance64x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance64x32 vpx_highbd_10_variance64x32_c
+
+unsigned int vpx_highbd_10_variance64x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_10_variance64x64 vpx_highbd_10_variance64x64_c
+
+unsigned int vpx_highbd_10_variance8x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_10_variance8x16 vpx_highbd_10_variance8x16_c
+
+unsigned int vpx_highbd_10_variance8x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_10_variance8x4 vpx_highbd_10_variance8x4_c
+
+unsigned int vpx_highbd_10_variance8x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_10_variance8x8 vpx_highbd_10_variance8x8_c
+
+void vpx_highbd_12_get16x16var_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse,
+                                 int* sum);
+#define vpx_highbd_12_get16x16var vpx_highbd_12_get16x16var_c
+
+void vpx_highbd_12_get8x8var_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse,
+                               int* sum);
+#define vpx_highbd_12_get8x8var vpx_highbd_12_get8x8var_c
+
+unsigned int vpx_highbd_12_mse16x16_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      unsigned int* sse);
+#define vpx_highbd_12_mse16x16 vpx_highbd_12_mse16x16_c
+
+unsigned int vpx_highbd_12_mse16x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     unsigned int* sse);
+#define vpx_highbd_12_mse16x8 vpx_highbd_12_mse16x8_c
+
+unsigned int vpx_highbd_12_mse8x16_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     unsigned int* sse);
+#define vpx_highbd_12_mse8x16 vpx_highbd_12_mse8x16_c
+
+unsigned int vpx_highbd_12_mse8x8_c(const uint8_t* src_ptr,
+                                    int src_stride,
+                                    const uint8_t* ref_ptr,
+                                    int ref_stride,
+                                    unsigned int* sse);
+#define vpx_highbd_12_mse8x8 vpx_highbd_12_mse8x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance16x16_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance16x16 \
+  vpx_highbd_12_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance16x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance16x32 \
+  vpx_highbd_12_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance16x8 \
+  vpx_highbd_12_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance32x16_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance32x16 \
+  vpx_highbd_12_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance32x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance32x32 \
+  vpx_highbd_12_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance32x64_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance32x64 \
+  vpx_highbd_12_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance4x4 \
+  vpx_highbd_12_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance4x8 \
+  vpx_highbd_12_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance64x32_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance64x32 \
+  vpx_highbd_12_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance64x64_c(
+    const uint8_t* src_ptr,
+    int src_stride,
+    int x_offset,
+    int y_offset,
+    const uint8_t* ref_ptr,
+    int ref_stride,
+    uint32_t* sse,
+    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance64x64 \
+  vpx_highbd_12_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance8x16 \
+  vpx_highbd_12_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance8x4 \
+  vpx_highbd_12_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_highbd_12_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_12_sub_pixel_avg_variance8x8 \
+  vpx_highbd_12_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance16x16 \
+  vpx_highbd_12_sub_pixel_variance16x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance16x32 \
+  vpx_highbd_12_sub_pixel_variance16x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance16x8 \
+  vpx_highbd_12_sub_pixel_variance16x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance32x16 \
+  vpx_highbd_12_sub_pixel_variance32x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance32x32 \
+  vpx_highbd_12_sub_pixel_variance32x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance32x64 \
+  vpx_highbd_12_sub_pixel_variance32x64_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance4x4 \
+  vpx_highbd_12_sub_pixel_variance4x4_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance4x8 \
+  vpx_highbd_12_sub_pixel_variance4x8_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance64x32 \
+  vpx_highbd_12_sub_pixel_variance64x32_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                                 int src_stride,
+                                                 int x_offset,
+                                                 int y_offset,
+                                                 const uint8_t* ref_ptr,
+                                                 int ref_stride,
+                                                 uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance64x64 \
+  vpx_highbd_12_sub_pixel_variance64x64_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance8x16 \
+  vpx_highbd_12_sub_pixel_variance8x16_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance8x4 \
+  vpx_highbd_12_sub_pixel_variance8x4_c
+
+uint32_t vpx_highbd_12_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_12_sub_pixel_variance8x8 \
+  vpx_highbd_12_sub_pixel_variance8x8_c
+
+unsigned int vpx_highbd_12_variance16x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance16x16 vpx_highbd_12_variance16x16_c
+
+unsigned int vpx_highbd_12_variance16x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance16x32 vpx_highbd_12_variance16x32_c
+
+unsigned int vpx_highbd_12_variance16x8_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_12_variance16x8 vpx_highbd_12_variance16x8_c
+
+unsigned int vpx_highbd_12_variance32x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance32x16 vpx_highbd_12_variance32x16_c
+
+unsigned int vpx_highbd_12_variance32x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance32x32 vpx_highbd_12_variance32x32_c
+
+unsigned int vpx_highbd_12_variance32x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance32x64 vpx_highbd_12_variance32x64_c
+
+unsigned int vpx_highbd_12_variance4x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_12_variance4x4 vpx_highbd_12_variance4x4_c
+
+unsigned int vpx_highbd_12_variance4x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_12_variance4x8 vpx_highbd_12_variance4x8_c
+
+unsigned int vpx_highbd_12_variance64x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance64x32 vpx_highbd_12_variance64x32_c
+
+unsigned int vpx_highbd_12_variance64x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           unsigned int* sse);
+#define vpx_highbd_12_variance64x64 vpx_highbd_12_variance64x64_c
+
+unsigned int vpx_highbd_12_variance8x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_12_variance8x16 vpx_highbd_12_variance8x16_c
+
+unsigned int vpx_highbd_12_variance8x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_12_variance8x4 vpx_highbd_12_variance8x4_c
+
+unsigned int vpx_highbd_12_variance8x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_12_variance8x8 vpx_highbd_12_variance8x8_c
+
+void vpx_highbd_8_get16x16var_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse,
+                                int* sum);
+#define vpx_highbd_8_get16x16var vpx_highbd_8_get16x16var_c
+
+void vpx_highbd_8_get8x8var_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              unsigned int* sse,
+                              int* sum);
+#define vpx_highbd_8_get8x8var vpx_highbd_8_get8x8var_c
+
+unsigned int vpx_highbd_8_mse16x16_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     unsigned int* sse);
+#define vpx_highbd_8_mse16x16 vpx_highbd_8_mse16x16_c
+
+unsigned int vpx_highbd_8_mse16x8_c(const uint8_t* src_ptr,
+                                    int src_stride,
+                                    const uint8_t* ref_ptr,
+                                    int ref_stride,
+                                    unsigned int* sse);
+#define vpx_highbd_8_mse16x8 vpx_highbd_8_mse16x8_c
+
+unsigned int vpx_highbd_8_mse8x16_c(const uint8_t* src_ptr,
+                                    int src_stride,
+                                    const uint8_t* ref_ptr,
+                                    int ref_stride,
+                                    unsigned int* sse);
+#define vpx_highbd_8_mse8x16 vpx_highbd_8_mse8x16_c
+
+unsigned int vpx_highbd_8_mse8x8_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_highbd_8_mse8x8 vpx_highbd_8_mse8x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance16x16_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance16x16 \
+  vpx_highbd_8_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance16x32_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance16x32 \
+  vpx_highbd_8_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance16x8 \
+  vpx_highbd_8_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance32x16_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance32x16 \
+  vpx_highbd_8_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance32x32_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance32x32 \
+  vpx_highbd_8_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance32x64_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance32x64 \
+  vpx_highbd_8_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                                  int src_stride,
+                                                  int x_offset,
+                                                  int y_offset,
+                                                  const uint8_t* ref_ptr,
+                                                  int ref_stride,
+                                                  uint32_t* sse,
+                                                  const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance4x4 \
+  vpx_highbd_8_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                                  int src_stride,
+                                                  int x_offset,
+                                                  int y_offset,
+                                                  const uint8_t* ref_ptr,
+                                                  int ref_stride,
+                                                  uint32_t* sse,
+                                                  const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance4x8 \
+  vpx_highbd_8_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance64x32_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance64x32 \
+  vpx_highbd_8_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance64x64_c(const uint8_t* src_ptr,
+                                                    int src_stride,
+                                                    int x_offset,
+                                                    int y_offset,
+                                                    const uint8_t* ref_ptr,
+                                                    int ref_stride,
+                                                    uint32_t* sse,
+                                                    const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance64x64 \
+  vpx_highbd_8_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                                   int src_stride,
+                                                   int x_offset,
+                                                   int y_offset,
+                                                   const uint8_t* ref_ptr,
+                                                   int ref_stride,
+                                                   uint32_t* sse,
+                                                   const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance8x16 \
+  vpx_highbd_8_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                                  int src_stride,
+                                                  int x_offset,
+                                                  int y_offset,
+                                                  const uint8_t* ref_ptr,
+                                                  int ref_stride,
+                                                  uint32_t* sse,
+                                                  const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance8x4 \
+  vpx_highbd_8_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_highbd_8_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                                  int src_stride,
+                                                  int x_offset,
+                                                  int y_offset,
+                                                  const uint8_t* ref_ptr,
+                                                  int ref_stride,
+                                                  uint32_t* sse,
+                                                  const uint8_t* second_pred);
+#define vpx_highbd_8_sub_pixel_avg_variance8x8 \
+  vpx_highbd_8_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance16x16 \
+  vpx_highbd_8_sub_pixel_variance16x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance16x32 \
+  vpx_highbd_8_sub_pixel_variance16x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance16x8 \
+  vpx_highbd_8_sub_pixel_variance16x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance32x16 \
+  vpx_highbd_8_sub_pixel_variance32x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance32x32 \
+  vpx_highbd_8_sub_pixel_variance32x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance32x64 \
+  vpx_highbd_8_sub_pixel_variance32x64_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                              int src_stride,
+                                              int x_offset,
+                                              int y_offset,
+                                              const uint8_t* ref_ptr,
+                                              int ref_stride,
+                                              uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance4x4 vpx_highbd_8_sub_pixel_variance4x4_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                              int src_stride,
+                                              int x_offset,
+                                              int y_offset,
+                                              const uint8_t* ref_ptr,
+                                              int ref_stride,
+                                              uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance4x8 vpx_highbd_8_sub_pixel_variance4x8_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance64x32 \
+  vpx_highbd_8_sub_pixel_variance64x32_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                                int src_stride,
+                                                int x_offset,
+                                                int y_offset,
+                                                const uint8_t* ref_ptr,
+                                                int ref_stride,
+                                                uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance64x64 \
+  vpx_highbd_8_sub_pixel_variance64x64_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                               int src_stride,
+                                               int x_offset,
+                                               int y_offset,
+                                               const uint8_t* ref_ptr,
+                                               int ref_stride,
+                                               uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance8x16 \
+  vpx_highbd_8_sub_pixel_variance8x16_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                              int src_stride,
+                                              int x_offset,
+                                              int y_offset,
+                                              const uint8_t* ref_ptr,
+                                              int ref_stride,
+                                              uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance8x4 vpx_highbd_8_sub_pixel_variance8x4_c
+
+uint32_t vpx_highbd_8_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                              int src_stride,
+                                              int x_offset,
+                                              int y_offset,
+                                              const uint8_t* ref_ptr,
+                                              int ref_stride,
+                                              uint32_t* sse);
+#define vpx_highbd_8_sub_pixel_variance8x8 vpx_highbd_8_sub_pixel_variance8x8_c
+
+unsigned int vpx_highbd_8_variance16x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance16x16 vpx_highbd_8_variance16x16_c
+
+unsigned int vpx_highbd_8_variance16x32_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance16x32 vpx_highbd_8_variance16x32_c
+
+unsigned int vpx_highbd_8_variance16x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_8_variance16x8 vpx_highbd_8_variance16x8_c
+
+unsigned int vpx_highbd_8_variance32x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance32x16 vpx_highbd_8_variance32x16_c
+
+unsigned int vpx_highbd_8_variance32x32_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance32x32 vpx_highbd_8_variance32x32_c
+
+unsigned int vpx_highbd_8_variance32x64_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance32x64 vpx_highbd_8_variance32x64_c
+
+unsigned int vpx_highbd_8_variance4x4_c(const uint8_t* src_ptr,
+                                        int src_stride,
+                                        const uint8_t* ref_ptr,
+                                        int ref_stride,
+                                        unsigned int* sse);
+#define vpx_highbd_8_variance4x4 vpx_highbd_8_variance4x4_c
+
+unsigned int vpx_highbd_8_variance4x8_c(const uint8_t* src_ptr,
+                                        int src_stride,
+                                        const uint8_t* ref_ptr,
+                                        int ref_stride,
+                                        unsigned int* sse);
+#define vpx_highbd_8_variance4x8 vpx_highbd_8_variance4x8_c
+
+unsigned int vpx_highbd_8_variance64x32_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance64x32 vpx_highbd_8_variance64x32_c
+
+unsigned int vpx_highbd_8_variance64x64_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          unsigned int* sse);
+#define vpx_highbd_8_variance64x64 vpx_highbd_8_variance64x64_c
+
+unsigned int vpx_highbd_8_variance8x16_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         unsigned int* sse);
+#define vpx_highbd_8_variance8x16 vpx_highbd_8_variance8x16_c
+
+unsigned int vpx_highbd_8_variance8x4_c(const uint8_t* src_ptr,
+                                        int src_stride,
+                                        const uint8_t* ref_ptr,
+                                        int ref_stride,
+                                        unsigned int* sse);
+#define vpx_highbd_8_variance8x4 vpx_highbd_8_variance8x4_c
+
+unsigned int vpx_highbd_8_variance8x8_c(const uint8_t* src_ptr,
+                                        int src_stride,
+                                        const uint8_t* ref_ptr,
+                                        int ref_stride,
+                                        unsigned int* sse);
+#define vpx_highbd_8_variance8x8 vpx_highbd_8_variance8x8_c
+
+unsigned int vpx_highbd_avg_4x4_c(const uint8_t* s8, int p);
+#define vpx_highbd_avg_4x4 vpx_highbd_avg_4x4_c
+
+unsigned int vpx_highbd_avg_8x8_c(const uint8_t* s8, int p);
+#define vpx_highbd_avg_8x8 vpx_highbd_avg_8x8_c
+
+void vpx_highbd_comp_avg_pred_c(uint16_t* comp_pred,
+                                const uint16_t* pred,
+                                int width,
+                                int height,
+                                const uint16_t* ref,
+                                int ref_stride);
+#define vpx_highbd_comp_avg_pred vpx_highbd_comp_avg_pred_c
+
+void vpx_highbd_convolve8_c(const uint16_t* src,
+                            ptrdiff_t src_stride,
+                            uint16_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h,
+                            int bd);
+#define vpx_highbd_convolve8 vpx_highbd_convolve8_c
+
+void vpx_highbd_convolve8_avg_c(const uint16_t* src,
+                                ptrdiff_t src_stride,
+                                uint16_t* dst,
+                                ptrdiff_t dst_stride,
+                                const InterpKernel* filter,
+                                int x0_q4,
+                                int x_step_q4,
+                                int y0_q4,
+                                int y_step_q4,
+                                int w,
+                                int h,
+                                int bd);
+#define vpx_highbd_convolve8_avg vpx_highbd_convolve8_avg_c
+
+void vpx_highbd_convolve8_avg_horiz_c(const uint16_t* src,
+                                      ptrdiff_t src_stride,
+                                      uint16_t* dst,
+                                      ptrdiff_t dst_stride,
+                                      const InterpKernel* filter,
+                                      int x0_q4,
+                                      int x_step_q4,
+                                      int y0_q4,
+                                      int y_step_q4,
+                                      int w,
+                                      int h,
+                                      int bd);
+#define vpx_highbd_convolve8_avg_horiz vpx_highbd_convolve8_avg_horiz_c
+
+void vpx_highbd_convolve8_avg_vert_c(const uint16_t* src,
+                                     ptrdiff_t src_stride,
+                                     uint16_t* dst,
+                                     ptrdiff_t dst_stride,
+                                     const InterpKernel* filter,
+                                     int x0_q4,
+                                     int x_step_q4,
+                                     int y0_q4,
+                                     int y_step_q4,
+                                     int w,
+                                     int h,
+                                     int bd);
+#define vpx_highbd_convolve8_avg_vert vpx_highbd_convolve8_avg_vert_c
+
+void vpx_highbd_convolve8_horiz_c(const uint16_t* src,
+                                  ptrdiff_t src_stride,
+                                  uint16_t* dst,
+                                  ptrdiff_t dst_stride,
+                                  const InterpKernel* filter,
+                                  int x0_q4,
+                                  int x_step_q4,
+                                  int y0_q4,
+                                  int y_step_q4,
+                                  int w,
+                                  int h,
+                                  int bd);
+#define vpx_highbd_convolve8_horiz vpx_highbd_convolve8_horiz_c
+
+void vpx_highbd_convolve8_vert_c(const uint16_t* src,
+                                 ptrdiff_t src_stride,
+                                 uint16_t* dst,
+                                 ptrdiff_t dst_stride,
+                                 const InterpKernel* filter,
+                                 int x0_q4,
+                                 int x_step_q4,
+                                 int y0_q4,
+                                 int y_step_q4,
+                                 int w,
+                                 int h,
+                                 int bd);
+#define vpx_highbd_convolve8_vert vpx_highbd_convolve8_vert_c
+
+void vpx_highbd_convolve_avg_c(const uint16_t* src,
+                               ptrdiff_t src_stride,
+                               uint16_t* dst,
+                               ptrdiff_t dst_stride,
+                               const InterpKernel* filter,
+                               int x0_q4,
+                               int x_step_q4,
+                               int y0_q4,
+                               int y_step_q4,
+                               int w,
+                               int h,
+                               int bd);
+#define vpx_highbd_convolve_avg vpx_highbd_convolve_avg_c
+
+void vpx_highbd_convolve_copy_c(const uint16_t* src,
+                                ptrdiff_t src_stride,
+                                uint16_t* dst,
+                                ptrdiff_t dst_stride,
+                                const InterpKernel* filter,
+                                int x0_q4,
+                                int x_step_q4,
+                                int y0_q4,
+                                int y_step_q4,
+                                int w,
+                                int h,
+                                int bd);
+#define vpx_highbd_convolve_copy vpx_highbd_convolve_copy_c
+
+void vpx_highbd_d117_predictor_16x16_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d117_predictor_16x16 vpx_highbd_d117_predictor_16x16_c
+
+void vpx_highbd_d117_predictor_32x32_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d117_predictor_32x32 vpx_highbd_d117_predictor_32x32_c
+
+void vpx_highbd_d117_predictor_4x4_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d117_predictor_4x4 vpx_highbd_d117_predictor_4x4_c
+
+void vpx_highbd_d117_predictor_8x8_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d117_predictor_8x8 vpx_highbd_d117_predictor_8x8_c
+
+void vpx_highbd_d135_predictor_16x16_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d135_predictor_16x16 vpx_highbd_d135_predictor_16x16_c
+
+void vpx_highbd_d135_predictor_32x32_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d135_predictor_32x32 vpx_highbd_d135_predictor_32x32_c
+
+void vpx_highbd_d135_predictor_4x4_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d135_predictor_4x4 vpx_highbd_d135_predictor_4x4_c
+
+void vpx_highbd_d135_predictor_8x8_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d135_predictor_8x8 vpx_highbd_d135_predictor_8x8_c
+
+void vpx_highbd_d153_predictor_16x16_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d153_predictor_16x16 vpx_highbd_d153_predictor_16x16_c
+
+void vpx_highbd_d153_predictor_32x32_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d153_predictor_32x32 vpx_highbd_d153_predictor_32x32_c
+
+void vpx_highbd_d153_predictor_4x4_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d153_predictor_4x4 vpx_highbd_d153_predictor_4x4_c
+
+void vpx_highbd_d153_predictor_8x8_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d153_predictor_8x8 vpx_highbd_d153_predictor_8x8_c
+
+void vpx_highbd_d207_predictor_16x16_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d207_predictor_16x16 vpx_highbd_d207_predictor_16x16_c
+
+void vpx_highbd_d207_predictor_32x32_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_d207_predictor_32x32 vpx_highbd_d207_predictor_32x32_c
+
+void vpx_highbd_d207_predictor_4x4_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d207_predictor_4x4 vpx_highbd_d207_predictor_4x4_c
+
+void vpx_highbd_d207_predictor_8x8_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_d207_predictor_8x8 vpx_highbd_d207_predictor_8x8_c
+
+void vpx_highbd_d45_predictor_16x16_c(uint16_t* dst,
+                                      ptrdiff_t stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define vpx_highbd_d45_predictor_16x16 vpx_highbd_d45_predictor_16x16_c
+
+void vpx_highbd_d45_predictor_32x32_c(uint16_t* dst,
+                                      ptrdiff_t stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define vpx_highbd_d45_predictor_32x32 vpx_highbd_d45_predictor_32x32_c
+
+void vpx_highbd_d45_predictor_4x4_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_d45_predictor_4x4 vpx_highbd_d45_predictor_4x4_c
+
+void vpx_highbd_d45_predictor_8x8_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_d45_predictor_8x8 vpx_highbd_d45_predictor_8x8_c
+
+void vpx_highbd_d63_predictor_16x16_c(uint16_t* dst,
+                                      ptrdiff_t stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define vpx_highbd_d63_predictor_16x16 vpx_highbd_d63_predictor_16x16_c
+
+void vpx_highbd_d63_predictor_32x32_c(uint16_t* dst,
+                                      ptrdiff_t stride,
+                                      const uint16_t* above,
+                                      const uint16_t* left,
+                                      int bd);
+#define vpx_highbd_d63_predictor_32x32 vpx_highbd_d63_predictor_32x32_c
+
+void vpx_highbd_d63_predictor_4x4_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_d63_predictor_4x4 vpx_highbd_d63_predictor_4x4_c
+
+void vpx_highbd_d63_predictor_8x8_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_d63_predictor_8x8 vpx_highbd_d63_predictor_8x8_c
+
+void vpx_highbd_dc_128_predictor_16x16_c(uint16_t* dst,
+                                         ptrdiff_t stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define vpx_highbd_dc_128_predictor_16x16 vpx_highbd_dc_128_predictor_16x16_c
+
+void vpx_highbd_dc_128_predictor_32x32_c(uint16_t* dst,
+                                         ptrdiff_t stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define vpx_highbd_dc_128_predictor_32x32 vpx_highbd_dc_128_predictor_32x32_c
+
+void vpx_highbd_dc_128_predictor_4x4_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_dc_128_predictor_4x4 vpx_highbd_dc_128_predictor_4x4_c
+
+void vpx_highbd_dc_128_predictor_8x8_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_dc_128_predictor_8x8 vpx_highbd_dc_128_predictor_8x8_c
+
+void vpx_highbd_dc_left_predictor_16x16_c(uint16_t* dst,
+                                          ptrdiff_t stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define vpx_highbd_dc_left_predictor_16x16 vpx_highbd_dc_left_predictor_16x16_c
+
+void vpx_highbd_dc_left_predictor_32x32_c(uint16_t* dst,
+                                          ptrdiff_t stride,
+                                          const uint16_t* above,
+                                          const uint16_t* left,
+                                          int bd);
+#define vpx_highbd_dc_left_predictor_32x32 vpx_highbd_dc_left_predictor_32x32_c
+
+void vpx_highbd_dc_left_predictor_4x4_c(uint16_t* dst,
+                                        ptrdiff_t stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define vpx_highbd_dc_left_predictor_4x4 vpx_highbd_dc_left_predictor_4x4_c
+
+void vpx_highbd_dc_left_predictor_8x8_c(uint16_t* dst,
+                                        ptrdiff_t stride,
+                                        const uint16_t* above,
+                                        const uint16_t* left,
+                                        int bd);
+#define vpx_highbd_dc_left_predictor_8x8 vpx_highbd_dc_left_predictor_8x8_c
+
+void vpx_highbd_dc_predictor_16x16_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_dc_predictor_16x16 vpx_highbd_dc_predictor_16x16_c
+
+void vpx_highbd_dc_predictor_32x32_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_dc_predictor_32x32 vpx_highbd_dc_predictor_32x32_c
+
+void vpx_highbd_dc_predictor_4x4_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define vpx_highbd_dc_predictor_4x4 vpx_highbd_dc_predictor_4x4_c
+
+void vpx_highbd_dc_predictor_8x8_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define vpx_highbd_dc_predictor_8x8 vpx_highbd_dc_predictor_8x8_c
+
+void vpx_highbd_dc_top_predictor_16x16_c(uint16_t* dst,
+                                         ptrdiff_t stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define vpx_highbd_dc_top_predictor_16x16 vpx_highbd_dc_top_predictor_16x16_c
+
+void vpx_highbd_dc_top_predictor_32x32_c(uint16_t* dst,
+                                         ptrdiff_t stride,
+                                         const uint16_t* above,
+                                         const uint16_t* left,
+                                         int bd);
+#define vpx_highbd_dc_top_predictor_32x32 vpx_highbd_dc_top_predictor_32x32_c
+
+void vpx_highbd_dc_top_predictor_4x4_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_dc_top_predictor_4x4 vpx_highbd_dc_top_predictor_4x4_c
+
+void vpx_highbd_dc_top_predictor_8x8_c(uint16_t* dst,
+                                       ptrdiff_t stride,
+                                       const uint16_t* above,
+                                       const uint16_t* left,
+                                       int bd);
+#define vpx_highbd_dc_top_predictor_8x8 vpx_highbd_dc_top_predictor_8x8_c
+
+void vpx_highbd_fdct16x16_c(const int16_t* input,
+                            tran_low_t* output,
+                            int stride);
+#define vpx_highbd_fdct16x16 vpx_highbd_fdct16x16_c
+
+void vpx_highbd_fdct16x16_1_c(const int16_t* input,
+                              tran_low_t* output,
+                              int stride);
+#define vpx_highbd_fdct16x16_1 vpx_highbd_fdct16x16_1_c
+
+void vpx_highbd_fdct32x32_c(const int16_t* input,
+                            tran_low_t* output,
+                            int stride);
+#define vpx_highbd_fdct32x32 vpx_highbd_fdct32x32_c
+
+void vpx_highbd_fdct32x32_1_c(const int16_t* input,
+                              tran_low_t* output,
+                              int stride);
+#define vpx_highbd_fdct32x32_1 vpx_highbd_fdct32x32_1_c
+
+void vpx_highbd_fdct32x32_rd_c(const int16_t* input,
+                               tran_low_t* output,
+                               int stride);
+#define vpx_highbd_fdct32x32_rd vpx_highbd_fdct32x32_rd_c
+
+void vpx_highbd_fdct4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_highbd_fdct4x4 vpx_highbd_fdct4x4_c
+
+void vpx_highbd_fdct8x8_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_highbd_fdct8x8 vpx_highbd_fdct8x8_c
+
+void vpx_highbd_fdct8x8_1_c(const int16_t* input,
+                            tran_low_t* output,
+                            int stride);
+#define vpx_highbd_fdct8x8_1 vpx_highbd_fdct8x8_1_c
+
+void vpx_highbd_h_predictor_16x16_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_h_predictor_16x16 vpx_highbd_h_predictor_16x16_c
+
+void vpx_highbd_h_predictor_32x32_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_h_predictor_32x32 vpx_highbd_h_predictor_32x32_c
+
+void vpx_highbd_h_predictor_4x4_c(uint16_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define vpx_highbd_h_predictor_4x4 vpx_highbd_h_predictor_4x4_c
+
+void vpx_highbd_h_predictor_8x8_c(uint16_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define vpx_highbd_h_predictor_8x8 vpx_highbd_h_predictor_8x8_c
+
+void vpx_highbd_hadamard_16x16_c(const int16_t* src_diff,
+                                 ptrdiff_t src_stride,
+                                 tran_low_t* coeff);
+#define vpx_highbd_hadamard_16x16 vpx_highbd_hadamard_16x16_c
+
+void vpx_highbd_hadamard_32x32_c(const int16_t* src_diff,
+                                 ptrdiff_t src_stride,
+                                 tran_low_t* coeff);
+#define vpx_highbd_hadamard_32x32 vpx_highbd_hadamard_32x32_c
+
+void vpx_highbd_hadamard_8x8_c(const int16_t* src_diff,
+                               ptrdiff_t src_stride,
+                               tran_low_t* coeff);
+#define vpx_highbd_hadamard_8x8 vpx_highbd_hadamard_8x8_c
+
+void vpx_highbd_idct16x16_10_add_c(const tran_low_t* input,
+                                   uint16_t* dest,
+                                   int stride,
+                                   int bd);
+#define vpx_highbd_idct16x16_10_add vpx_highbd_idct16x16_10_add_c
+
+void vpx_highbd_idct16x16_1_add_c(const tran_low_t* input,
+                                  uint16_t* dest,
+                                  int stride,
+                                  int bd);
+#define vpx_highbd_idct16x16_1_add vpx_highbd_idct16x16_1_add_c
+
+void vpx_highbd_idct16x16_256_add_c(const tran_low_t* input,
+                                    uint16_t* dest,
+                                    int stride,
+                                    int bd);
+#define vpx_highbd_idct16x16_256_add vpx_highbd_idct16x16_256_add_c
+
+void vpx_highbd_idct16x16_38_add_c(const tran_low_t* input,
+                                   uint16_t* dest,
+                                   int stride,
+                                   int bd);
+#define vpx_highbd_idct16x16_38_add vpx_highbd_idct16x16_38_add_c
+
+void vpx_highbd_idct32x32_1024_add_c(const tran_low_t* input,
+                                     uint16_t* dest,
+                                     int stride,
+                                     int bd);
+#define vpx_highbd_idct32x32_1024_add vpx_highbd_idct32x32_1024_add_c
+
+void vpx_highbd_idct32x32_135_add_c(const tran_low_t* input,
+                                    uint16_t* dest,
+                                    int stride,
+                                    int bd);
+#define vpx_highbd_idct32x32_135_add vpx_highbd_idct32x32_135_add_c
+
+void vpx_highbd_idct32x32_1_add_c(const tran_low_t* input,
+                                  uint16_t* dest,
+                                  int stride,
+                                  int bd);
+#define vpx_highbd_idct32x32_1_add vpx_highbd_idct32x32_1_add_c
+
+void vpx_highbd_idct32x32_34_add_c(const tran_low_t* input,
+                                   uint16_t* dest,
+                                   int stride,
+                                   int bd);
+#define vpx_highbd_idct32x32_34_add vpx_highbd_idct32x32_34_add_c
+
+void vpx_highbd_idct4x4_16_add_c(const tran_low_t* input,
+                                 uint16_t* dest,
+                                 int stride,
+                                 int bd);
+#define vpx_highbd_idct4x4_16_add vpx_highbd_idct4x4_16_add_c
+
+void vpx_highbd_idct4x4_1_add_c(const tran_low_t* input,
+                                uint16_t* dest,
+                                int stride,
+                                int bd);
+#define vpx_highbd_idct4x4_1_add vpx_highbd_idct4x4_1_add_c
+
+void vpx_highbd_idct8x8_12_add_c(const tran_low_t* input,
+                                 uint16_t* dest,
+                                 int stride,
+                                 int bd);
+#define vpx_highbd_idct8x8_12_add vpx_highbd_idct8x8_12_add_c
+
+void vpx_highbd_idct8x8_1_add_c(const tran_low_t* input,
+                                uint16_t* dest,
+                                int stride,
+                                int bd);
+#define vpx_highbd_idct8x8_1_add vpx_highbd_idct8x8_1_add_c
+
+void vpx_highbd_idct8x8_64_add_c(const tran_low_t* input,
+                                 uint16_t* dest,
+                                 int stride,
+                                 int bd);
+#define vpx_highbd_idct8x8_64_add vpx_highbd_idct8x8_64_add_c
+
+void vpx_highbd_iwht4x4_16_add_c(const tran_low_t* input,
+                                 uint16_t* dest,
+                                 int stride,
+                                 int bd);
+#define vpx_highbd_iwht4x4_16_add vpx_highbd_iwht4x4_16_add_c
+
+void vpx_highbd_iwht4x4_1_add_c(const tran_low_t* input,
+                                uint16_t* dest,
+                                int stride,
+                                int bd);
+#define vpx_highbd_iwht4x4_1_add vpx_highbd_iwht4x4_1_add_c
+
+void vpx_highbd_lpf_horizontal_16_c(uint16_t* s,
+                                    int pitch,
+                                    const uint8_t* blimit,
+                                    const uint8_t* limit,
+                                    const uint8_t* thresh,
+                                    int bd);
+#define vpx_highbd_lpf_horizontal_16 vpx_highbd_lpf_horizontal_16_c
+
+void vpx_highbd_lpf_horizontal_16_dual_c(uint16_t* s,
+                                         int pitch,
+                                         const uint8_t* blimit,
+                                         const uint8_t* limit,
+                                         const uint8_t* thresh,
+                                         int bd);
+#define vpx_highbd_lpf_horizontal_16_dual vpx_highbd_lpf_horizontal_16_dual_c
+
+void vpx_highbd_lpf_horizontal_4_c(uint16_t* s,
+                                   int pitch,
+                                   const uint8_t* blimit,
+                                   const uint8_t* limit,
+                                   const uint8_t* thresh,
+                                   int bd);
+#define vpx_highbd_lpf_horizontal_4 vpx_highbd_lpf_horizontal_4_c
+
+void vpx_highbd_lpf_horizontal_4_dual_c(uint16_t* s,
+                                        int pitch,
+                                        const uint8_t* blimit0,
+                                        const uint8_t* limit0,
+                                        const uint8_t* thresh0,
+                                        const uint8_t* blimit1,
+                                        const uint8_t* limit1,
+                                        const uint8_t* thresh1,
+                                        int bd);
+#define vpx_highbd_lpf_horizontal_4_dual vpx_highbd_lpf_horizontal_4_dual_c
+
+void vpx_highbd_lpf_horizontal_8_c(uint16_t* s,
+                                   int pitch,
+                                   const uint8_t* blimit,
+                                   const uint8_t* limit,
+                                   const uint8_t* thresh,
+                                   int bd);
+#define vpx_highbd_lpf_horizontal_8 vpx_highbd_lpf_horizontal_8_c
+
+void vpx_highbd_lpf_horizontal_8_dual_c(uint16_t* s,
+                                        int pitch,
+                                        const uint8_t* blimit0,
+                                        const uint8_t* limit0,
+                                        const uint8_t* thresh0,
+                                        const uint8_t* blimit1,
+                                        const uint8_t* limit1,
+                                        const uint8_t* thresh1,
+                                        int bd);
+#define vpx_highbd_lpf_horizontal_8_dual vpx_highbd_lpf_horizontal_8_dual_c
+
+void vpx_highbd_lpf_vertical_16_c(uint16_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh,
+                                  int bd);
+#define vpx_highbd_lpf_vertical_16 vpx_highbd_lpf_vertical_16_c
+
+void vpx_highbd_lpf_vertical_16_dual_c(uint16_t* s,
+                                       int pitch,
+                                       const uint8_t* blimit,
+                                       const uint8_t* limit,
+                                       const uint8_t* thresh,
+                                       int bd);
+#define vpx_highbd_lpf_vertical_16_dual vpx_highbd_lpf_vertical_16_dual_c
+
+void vpx_highbd_lpf_vertical_4_c(uint16_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit,
+                                 const uint8_t* limit,
+                                 const uint8_t* thresh,
+                                 int bd);
+#define vpx_highbd_lpf_vertical_4 vpx_highbd_lpf_vertical_4_c
+
+void vpx_highbd_lpf_vertical_4_dual_c(uint16_t* s,
+                                      int pitch,
+                                      const uint8_t* blimit0,
+                                      const uint8_t* limit0,
+                                      const uint8_t* thresh0,
+                                      const uint8_t* blimit1,
+                                      const uint8_t* limit1,
+                                      const uint8_t* thresh1,
+                                      int bd);
+#define vpx_highbd_lpf_vertical_4_dual vpx_highbd_lpf_vertical_4_dual_c
+
+void vpx_highbd_lpf_vertical_8_c(uint16_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit,
+                                 const uint8_t* limit,
+                                 const uint8_t* thresh,
+                                 int bd);
+#define vpx_highbd_lpf_vertical_8 vpx_highbd_lpf_vertical_8_c
+
+void vpx_highbd_lpf_vertical_8_dual_c(uint16_t* s,
+                                      int pitch,
+                                      const uint8_t* blimit0,
+                                      const uint8_t* limit0,
+                                      const uint8_t* thresh0,
+                                      const uint8_t* blimit1,
+                                      const uint8_t* limit1,
+                                      const uint8_t* thresh1,
+                                      int bd);
+#define vpx_highbd_lpf_vertical_8_dual vpx_highbd_lpf_vertical_8_dual_c
+
+void vpx_highbd_minmax_8x8_c(const uint8_t* s8,
+                             int p,
+                             const uint8_t* d8,
+                             int dp,
+                             int* min,
+                             int* max);
+#define vpx_highbd_minmax_8x8 vpx_highbd_minmax_8x8_c
+
+void vpx_highbd_quantize_b_c(const tran_low_t* coeff_ptr,
+                             intptr_t n_coeffs,
+                             int skip_block,
+                             const int16_t* zbin_ptr,
+                             const int16_t* round_ptr,
+                             const int16_t* quant_ptr,
+                             const int16_t* quant_shift_ptr,
+                             tran_low_t* qcoeff_ptr,
+                             tran_low_t* dqcoeff_ptr,
+                             const int16_t* dequant_ptr,
+                             uint16_t* eob_ptr,
+                             const int16_t* scan,
+                             const int16_t* iscan);
+#define vpx_highbd_quantize_b vpx_highbd_quantize_b_c
+
+void vpx_highbd_quantize_b_32x32_c(const tran_low_t* coeff_ptr,
+                                   intptr_t n_coeffs,
+                                   int skip_block,
+                                   const int16_t* zbin_ptr,
+                                   const int16_t* round_ptr,
+                                   const int16_t* quant_ptr,
+                                   const int16_t* quant_shift_ptr,
+                                   tran_low_t* qcoeff_ptr,
+                                   tran_low_t* dqcoeff_ptr,
+                                   const int16_t* dequant_ptr,
+                                   uint16_t* eob_ptr,
+                                   const int16_t* scan,
+                                   const int16_t* iscan);
+#define vpx_highbd_quantize_b_32x32 vpx_highbd_quantize_b_32x32_c
+
+unsigned int vpx_highbd_sad16x16_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad16x16 vpx_highbd_sad16x16_c
+
+unsigned int vpx_highbd_sad16x16_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad16x16_avg vpx_highbd_sad16x16_avg_c
+
+void vpx_highbd_sad16x16x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad16x16x4d vpx_highbd_sad16x16x4d_c
+
+unsigned int vpx_highbd_sad16x32_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad16x32 vpx_highbd_sad16x32_c
+
+unsigned int vpx_highbd_sad16x32_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad16x32_avg vpx_highbd_sad16x32_avg_c
+
+void vpx_highbd_sad16x32x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad16x32x4d vpx_highbd_sad16x32x4d_c
+
+unsigned int vpx_highbd_sad16x8_c(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride);
+#define vpx_highbd_sad16x8 vpx_highbd_sad16x8_c
+
+unsigned int vpx_highbd_sad16x8_avg_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      const uint8_t* second_pred);
+#define vpx_highbd_sad16x8_avg vpx_highbd_sad16x8_avg_c
+
+void vpx_highbd_sad16x8x4d_c(const uint8_t* src_ptr,
+                             int src_stride,
+                             const uint8_t* const ref_array[],
+                             int ref_stride,
+                             uint32_t* sad_array);
+#define vpx_highbd_sad16x8x4d vpx_highbd_sad16x8x4d_c
+
+unsigned int vpx_highbd_sad32x16_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad32x16 vpx_highbd_sad32x16_c
+
+unsigned int vpx_highbd_sad32x16_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad32x16_avg vpx_highbd_sad32x16_avg_c
+
+void vpx_highbd_sad32x16x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad32x16x4d vpx_highbd_sad32x16x4d_c
+
+unsigned int vpx_highbd_sad32x32_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad32x32 vpx_highbd_sad32x32_c
+
+unsigned int vpx_highbd_sad32x32_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad32x32_avg vpx_highbd_sad32x32_avg_c
+
+void vpx_highbd_sad32x32x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad32x32x4d vpx_highbd_sad32x32x4d_c
+
+unsigned int vpx_highbd_sad32x64_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad32x64 vpx_highbd_sad32x64_c
+
+unsigned int vpx_highbd_sad32x64_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad32x64_avg vpx_highbd_sad32x64_avg_c
+
+void vpx_highbd_sad32x64x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad32x64x4d vpx_highbd_sad32x64x4d_c
+
+unsigned int vpx_highbd_sad4x4_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride);
+#define vpx_highbd_sad4x4 vpx_highbd_sad4x4_c
+
+unsigned int vpx_highbd_sad4x4_avg_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     const uint8_t* second_pred);
+#define vpx_highbd_sad4x4_avg vpx_highbd_sad4x4_avg_c
+
+void vpx_highbd_sad4x4x4d_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* const ref_array[],
+                            int ref_stride,
+                            uint32_t* sad_array);
+#define vpx_highbd_sad4x4x4d vpx_highbd_sad4x4x4d_c
+
+unsigned int vpx_highbd_sad4x8_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride);
+#define vpx_highbd_sad4x8 vpx_highbd_sad4x8_c
+
+unsigned int vpx_highbd_sad4x8_avg_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     const uint8_t* second_pred);
+#define vpx_highbd_sad4x8_avg vpx_highbd_sad4x8_avg_c
+
+void vpx_highbd_sad4x8x4d_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* const ref_array[],
+                            int ref_stride,
+                            uint32_t* sad_array);
+#define vpx_highbd_sad4x8x4d vpx_highbd_sad4x8x4d_c
+
+unsigned int vpx_highbd_sad64x32_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad64x32 vpx_highbd_sad64x32_c
+
+unsigned int vpx_highbd_sad64x32_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad64x32_avg vpx_highbd_sad64x32_avg_c
+
+void vpx_highbd_sad64x32x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad64x32x4d vpx_highbd_sad64x32x4d_c
+
+unsigned int vpx_highbd_sad64x64_c(const uint8_t* src_ptr,
+                                   int src_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride);
+#define vpx_highbd_sad64x64 vpx_highbd_sad64x64_c
+
+unsigned int vpx_highbd_sad64x64_avg_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       const uint8_t* second_pred);
+#define vpx_highbd_sad64x64_avg vpx_highbd_sad64x64_avg_c
+
+void vpx_highbd_sad64x64x4d_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* const ref_array[],
+                              int ref_stride,
+                              uint32_t* sad_array);
+#define vpx_highbd_sad64x64x4d vpx_highbd_sad64x64x4d_c
+
+unsigned int vpx_highbd_sad8x16_c(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride);
+#define vpx_highbd_sad8x16 vpx_highbd_sad8x16_c
+
+unsigned int vpx_highbd_sad8x16_avg_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      const uint8_t* second_pred);
+#define vpx_highbd_sad8x16_avg vpx_highbd_sad8x16_avg_c
+
+void vpx_highbd_sad8x16x4d_c(const uint8_t* src_ptr,
+                             int src_stride,
+                             const uint8_t* const ref_array[],
+                             int ref_stride,
+                             uint32_t* sad_array);
+#define vpx_highbd_sad8x16x4d vpx_highbd_sad8x16x4d_c
+
+unsigned int vpx_highbd_sad8x4_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride);
+#define vpx_highbd_sad8x4 vpx_highbd_sad8x4_c
+
+unsigned int vpx_highbd_sad8x4_avg_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     const uint8_t* second_pred);
+#define vpx_highbd_sad8x4_avg vpx_highbd_sad8x4_avg_c
+
+void vpx_highbd_sad8x4x4d_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* const ref_array[],
+                            int ref_stride,
+                            uint32_t* sad_array);
+#define vpx_highbd_sad8x4x4d vpx_highbd_sad8x4x4d_c
+
+unsigned int vpx_highbd_sad8x8_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride);
+#define vpx_highbd_sad8x8 vpx_highbd_sad8x8_c
+
+unsigned int vpx_highbd_sad8x8_avg_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     const uint8_t* second_pred);
+#define vpx_highbd_sad8x8_avg vpx_highbd_sad8x8_avg_c
+
+void vpx_highbd_sad8x8x4d_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* const ref_array[],
+                            int ref_stride,
+                            uint32_t* sad_array);
+#define vpx_highbd_sad8x8x4d vpx_highbd_sad8x8x4d_c
+
+int vpx_highbd_satd_c(const tran_low_t* coeff, int length);
+#define vpx_highbd_satd vpx_highbd_satd_c
+
+void vpx_highbd_subtract_block_c(int rows,
+                                 int cols,
+                                 int16_t* diff_ptr,
+                                 ptrdiff_t diff_stride,
+                                 const uint8_t* src8_ptr,
+                                 ptrdiff_t src_stride,
+                                 const uint8_t* pred8_ptr,
+                                 ptrdiff_t pred_stride,
+                                 int bd);
+#define vpx_highbd_subtract_block vpx_highbd_subtract_block_c
+
+void vpx_highbd_tm_predictor_16x16_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_tm_predictor_16x16 vpx_highbd_tm_predictor_16x16_c
+
+void vpx_highbd_tm_predictor_32x32_c(uint16_t* dst,
+                                     ptrdiff_t stride,
+                                     const uint16_t* above,
+                                     const uint16_t* left,
+                                     int bd);
+#define vpx_highbd_tm_predictor_32x32 vpx_highbd_tm_predictor_32x32_c
+
+void vpx_highbd_tm_predictor_4x4_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define vpx_highbd_tm_predictor_4x4 vpx_highbd_tm_predictor_4x4_c
+
+void vpx_highbd_tm_predictor_8x8_c(uint16_t* dst,
+                                   ptrdiff_t stride,
+                                   const uint16_t* above,
+                                   const uint16_t* left,
+                                   int bd);
+#define vpx_highbd_tm_predictor_8x8 vpx_highbd_tm_predictor_8x8_c
+
+void vpx_highbd_v_predictor_16x16_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_v_predictor_16x16 vpx_highbd_v_predictor_16x16_c
+
+void vpx_highbd_v_predictor_32x32_c(uint16_t* dst,
+                                    ptrdiff_t stride,
+                                    const uint16_t* above,
+                                    const uint16_t* left,
+                                    int bd);
+#define vpx_highbd_v_predictor_32x32 vpx_highbd_v_predictor_32x32_c
+
+void vpx_highbd_v_predictor_4x4_c(uint16_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define vpx_highbd_v_predictor_4x4 vpx_highbd_v_predictor_4x4_c
+
+void vpx_highbd_v_predictor_8x8_c(uint16_t* dst,
+                                  ptrdiff_t stride,
+                                  const uint16_t* above,
+                                  const uint16_t* left,
+                                  int bd);
+#define vpx_highbd_v_predictor_8x8 vpx_highbd_v_predictor_8x8_c
+
+void vpx_idct16x16_10_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c
+
+void vpx_idct16x16_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c
+
+void vpx_idct16x16_256_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_c
+
+void vpx_idct16x16_38_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_38_add vpx_idct16x16_38_add_c
+
+void vpx_idct32x32_1024_add_c(const tran_low_t* input,
+                              uint8_t* dest,
+                              int stride);
+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_c
+
+void vpx_idct32x32_135_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct32x32_135_add vpx_idct32x32_135_add_c
+
+void vpx_idct32x32_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c
+
+void vpx_idct32x32_34_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c
+
+void vpx_idct4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_c
+
+void vpx_idct4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c
+
+void vpx_idct8x8_12_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c
+
+void vpx_idct8x8_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c
+
+void vpx_idct8x8_64_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_c
+
+int16_t vpx_int_pro_col_c(const uint8_t* ref, const int width);
+#define vpx_int_pro_col vpx_int_pro_col_c
+
+void vpx_int_pro_row_c(int16_t* hbuf,
+                       const uint8_t* ref,
+                       const int ref_stride,
+                       const int height);
+#define vpx_int_pro_row vpx_int_pro_row_c
+
+void vpx_iwht4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_c
+
+void vpx_iwht4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c
+
+void vpx_lpf_horizontal_16_c(uint8_t* s,
+                             int pitch,
+                             const uint8_t* blimit,
+                             const uint8_t* limit,
+                             const uint8_t* thresh);
+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c
+
+void vpx_lpf_horizontal_16_dual_c(uint8_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh);
+#define vpx_lpf_horizontal_16_dual vpx_lpf_horizontal_16_dual_c
+
+void vpx_lpf_horizontal_4_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c
+
+void vpx_lpf_horizontal_4_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c
+
+void vpx_lpf_horizontal_8_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c
+
+void vpx_lpf_horizontal_8_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c
+
+void vpx_lpf_vertical_16_c(uint8_t* s,
+                           int pitch,
+                           const uint8_t* blimit,
+                           const uint8_t* limit,
+                           const uint8_t* thresh);
+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c
+
+void vpx_lpf_vertical_16_dual_c(uint8_t* s,
+                                int pitch,
+                                const uint8_t* blimit,
+                                const uint8_t* limit,
+                                const uint8_t* thresh);
+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c
+
+void vpx_lpf_vertical_4_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c
+
+void vpx_lpf_vertical_4_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c
+
+void vpx_lpf_vertical_8_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c
+
+void vpx_lpf_vertical_8_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c
+
+void vpx_mbpost_proc_across_ip_c(unsigned char* src,
+                                 int pitch,
+                                 int rows,
+                                 int cols,
+                                 int flimit);
+#define vpx_mbpost_proc_across_ip vpx_mbpost_proc_across_ip_c
+
+void vpx_mbpost_proc_down_c(unsigned char* dst,
+                            int pitch,
+                            int rows,
+                            int cols,
+                            int flimit);
+#define vpx_mbpost_proc_down vpx_mbpost_proc_down_c
+
+void vpx_minmax_8x8_c(const uint8_t* s,
+                      int p,
+                      const uint8_t* d,
+                      int dp,
+                      int* min,
+                      int* max);
+#define vpx_minmax_8x8 vpx_minmax_8x8_c
+
+unsigned int vpx_mse16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride,
+                            unsigned int* sse);
+#define vpx_mse16x16 vpx_mse16x16_c
+
+unsigned int vpx_mse16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse16x8 vpx_mse16x8_c
+
+unsigned int vpx_mse8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride,
+                           unsigned int* sse);
+#define vpx_mse8x16 vpx_mse8x16_c
+
+unsigned int vpx_mse8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride,
+                          unsigned int* sse);
+#define vpx_mse8x8 vpx_mse8x8_c
+
+void vpx_plane_add_noise_c(uint8_t* start,
+                           const int8_t* noise,
+                           int blackclamp,
+                           int whiteclamp,
+                           int width,
+                           int height,
+                           int pitch);
+#define vpx_plane_add_noise vpx_plane_add_noise_c
+
+void vpx_post_proc_down_and_across_mb_row_c(unsigned char* src,
+                                            unsigned char* dst,
+                                            int src_pitch,
+                                            int dst_pitch,
+                                            int cols,
+                                            unsigned char* flimits,
+                                            int size);
+#define vpx_post_proc_down_and_across_mb_row \
+  vpx_post_proc_down_and_across_mb_row_c
+
+void vpx_quantize_b_c(const tran_low_t* coeff_ptr,
+                      intptr_t n_coeffs,
+                      int skip_block,
+                      const int16_t* zbin_ptr,
+                      const int16_t* round_ptr,
+                      const int16_t* quant_ptr,
+                      const int16_t* quant_shift_ptr,
+                      tran_low_t* qcoeff_ptr,
+                      tran_low_t* dqcoeff_ptr,
+                      const int16_t* dequant_ptr,
+                      uint16_t* eob_ptr,
+                      const int16_t* scan,
+                      const int16_t* iscan);
+#define vpx_quantize_b vpx_quantize_b_c
+
+void vpx_quantize_b_32x32_c(const tran_low_t* coeff_ptr,
+                            intptr_t n_coeffs,
+                            int skip_block,
+                            const int16_t* zbin_ptr,
+                            const int16_t* round_ptr,
+                            const int16_t* quant_ptr,
+                            const int16_t* quant_shift_ptr,
+                            tran_low_t* qcoeff_ptr,
+                            tran_low_t* dqcoeff_ptr,
+                            const int16_t* dequant_ptr,
+                            uint16_t* eob_ptr,
+                            const int16_t* scan,
+                            const int16_t* iscan);
+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_c
+
+unsigned int vpx_sad16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x16 vpx_sad16x16_c
+
+unsigned int vpx_sad16x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x16_avg vpx_sad16x16_avg_c
+
+void vpx_sad16x16x3_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x3 vpx_sad16x16x3_c
+
+void vpx_sad16x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x16x4d vpx_sad16x16x4d_c
+
+void vpx_sad16x16x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x8 vpx_sad16x16x8_c
+
+unsigned int vpx_sad16x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad16x32 vpx_sad16x32_c
+
+unsigned int vpx_sad16x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad16x32_avg vpx_sad16x32_avg_c
+
+void vpx_sad16x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad16x32x4d vpx_sad16x32x4d_c
+
+unsigned int vpx_sad16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad16x8 vpx_sad16x8_c
+
+unsigned int vpx_sad16x8_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad16x8_avg vpx_sad16x8_avg_c
+
+void vpx_sad16x8x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x3 vpx_sad16x8x3_c
+
+void vpx_sad16x8x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x8x4d vpx_sad16x8x4d_c
+
+void vpx_sad16x8x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x8 vpx_sad16x8x8_c
+
+unsigned int vpx_sad32x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x16 vpx_sad32x16_c
+
+unsigned int vpx_sad32x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x16_avg vpx_sad32x16_avg_c
+
+void vpx_sad32x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x16x4d vpx_sad32x16x4d_c
+
+unsigned int vpx_sad32x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x32 vpx_sad32x32_c
+
+unsigned int vpx_sad32x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x32_avg vpx_sad32x32_avg_c
+
+void vpx_sad32x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x32x4d vpx_sad32x32x4d_c
+
+void vpx_sad32x32x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad32x32x8 vpx_sad32x32x8_c
+
+unsigned int vpx_sad32x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad32x64 vpx_sad32x64_c
+
+unsigned int vpx_sad32x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad32x64_avg vpx_sad32x64_avg_c
+
+void vpx_sad32x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad32x64x4d vpx_sad32x64x4d_c
+
+unsigned int vpx_sad4x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x4 vpx_sad4x4_c
+
+unsigned int vpx_sad4x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x4_avg vpx_sad4x4_avg_c
+
+void vpx_sad4x4x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x3 vpx_sad4x4x3_c
+
+void vpx_sad4x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x4x4d vpx_sad4x4x4d_c
+
+void vpx_sad4x4x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x8 vpx_sad4x4x8_c
+
+unsigned int vpx_sad4x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x8 vpx_sad4x8_c
+
+unsigned int vpx_sad4x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x8_avg vpx_sad4x8_avg_c
+
+void vpx_sad4x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x8x4d vpx_sad4x8x4d_c
+
+unsigned int vpx_sad64x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x32 vpx_sad64x32_c
+
+unsigned int vpx_sad64x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x32_avg vpx_sad64x32_avg_c
+
+void vpx_sad64x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x32x4d vpx_sad64x32x4d_c
+
+unsigned int vpx_sad64x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad64x64 vpx_sad64x64_c
+
+unsigned int vpx_sad64x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+#define vpx_sad64x64_avg vpx_sad64x64_avg_c
+
+void vpx_sad64x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_array[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+#define vpx_sad64x64x4d vpx_sad64x64x4d_c
+
+unsigned int vpx_sad8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+#define vpx_sad8x16 vpx_sad8x16_c
+
+unsigned int vpx_sad8x16_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad8x16_avg vpx_sad8x16_avg_c
+
+void vpx_sad8x16x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x3 vpx_sad8x16x3_c
+
+void vpx_sad8x16x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_array[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad8x16x4d vpx_sad8x16x4d_c
+
+void vpx_sad8x16x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x8 vpx_sad8x16x8_c
+
+unsigned int vpx_sad8x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x4 vpx_sad8x4_c
+
+unsigned int vpx_sad8x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x4_avg vpx_sad8x4_avg_c
+
+void vpx_sad8x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x4x4d vpx_sad8x4x4d_c
+
+unsigned int vpx_sad8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad8x8 vpx_sad8x8_c
+
+unsigned int vpx_sad8x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x8_avg vpx_sad8x8_avg_c
+
+void vpx_sad8x8x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x3 vpx_sad8x8x3_c
+
+void vpx_sad8x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_array[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x8x4d vpx_sad8x8x4d_c
+
+void vpx_sad8x8x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x8 vpx_sad8x8x8_c
+
+int vpx_satd_c(const tran_low_t* coeff, int length);
+#define vpx_satd vpx_satd_c
+
+void vpx_scaled_2d_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_scaled_2d vpx_scaled_2d_c
+
+void vpx_scaled_avg_2d_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c
+
+void vpx_scaled_avg_horiz_c(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h);
+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c
+
+void vpx_scaled_avg_vert_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c
+
+void vpx_scaled_horiz_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_scaled_horiz vpx_scaled_horiz_c
+
+void vpx_scaled_vert_c(const uint8_t* src,
+                       ptrdiff_t src_stride,
+                       uint8_t* dst,
+                       ptrdiff_t dst_stride,
+                       const InterpKernel* filter,
+                       int x0_q4,
+                       int x_step_q4,
+                       int y0_q4,
+                       int y_step_q4,
+                       int w,
+                       int h);
+#define vpx_scaled_vert vpx_scaled_vert_c
+
+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t* src_ptr,
+                                           int src_stride,
+                                           int x_offset,
+                                           int y_offset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                          int src_stride,
+                                          int x_offset,
+                                          int y_offset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                         int src_stride,
+                                         int x_offset,
+                                         int y_offset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_c
+
+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c
+
+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c
+
+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c
+
+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c
+
+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c
+
+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c
+
+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c
+
+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c
+
+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                       int src_stride,
+                                       int x_offset,
+                                       int y_offset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c
+
+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                      int src_stride,
+                                      int x_offset,
+                                      int y_offset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c
+
+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c
+
+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                     int src_stride,
+                                     int x_offset,
+                                     int y_offset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_c
+
+void vpx_subtract_block_c(int rows,
+                          int cols,
+                          int16_t* diff_ptr,
+                          ptrdiff_t diff_stride,
+                          const uint8_t* src_ptr,
+                          ptrdiff_t src_stride,
+                          const uint8_t* pred_ptr,
+                          ptrdiff_t pred_stride);
+#define vpx_subtract_block vpx_subtract_block_c
+
+uint64_t vpx_sum_squares_2d_i16_c(const int16_t* src, int stride, int size);
+#define vpx_sum_squares_2d_i16 vpx_sum_squares_2d_i16_c
+
+void vpx_tm_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_c
+
+void vpx_tm_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_c
+
+void vpx_tm_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_c
+
+void vpx_tm_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_c
+
+void vpx_v_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_c
+
+void vpx_v_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_c
+
+void vpx_v_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c
+
+void vpx_v_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c
+
+unsigned int vpx_variance16x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x16 vpx_variance16x16_c
+
+unsigned int vpx_variance16x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance16x32 vpx_variance16x32_c
+
+unsigned int vpx_variance16x8_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance16x8 vpx_variance16x8_c
+
+unsigned int vpx_variance32x16_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x16 vpx_variance32x16_c
+
+unsigned int vpx_variance32x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x32 vpx_variance32x32_c
+
+unsigned int vpx_variance32x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance32x64 vpx_variance32x64_c
+
+unsigned int vpx_variance4x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x4 vpx_variance4x4_c
+
+unsigned int vpx_variance4x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance4x8 vpx_variance4x8_c
+
+unsigned int vpx_variance64x32_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x32 vpx_variance64x32_c
+
+unsigned int vpx_variance64x64_c(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance64x64 vpx_variance64x64_c
+
+unsigned int vpx_variance8x16_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+#define vpx_variance8x16 vpx_variance8x16_c
+
+unsigned int vpx_variance8x4_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x4 vpx_variance8x4_c
+
+unsigned int vpx_variance8x8_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+#define vpx_variance8x8 vpx_variance8x8_c
+
+void vpx_ve_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_ve_predictor_4x4 vpx_ve_predictor_4x4_c
+
+int vpx_vector_var_c(const int16_t* ref, const int16_t* src, const int bwl);
+#define vpx_vector_var vpx_vector_var_c
+
+void vpx_dsp_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff --git a/third_party/libvpx/source/config/linux/loong64/vpx_scale_rtcd.h b/third_party/libvpx/source/config/linux/loong64/vpx_scale_rtcd.h
new file mode 100644
index 0000000000..c5196db4dc
--- /dev/null
+++ b/third_party/libvpx/source/config/linux/loong64/vpx_scale_rtcd.h
@@ -0,0 +1,96 @@
+// This file is generated. Do not edit.
+#ifndef VPX_SCALE_RTCD_H_
+#define VPX_SCALE_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_horizontal_line_2_1_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c
+
+void vp8_horizontal_line_5_3_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_3_scale vp8_horizontal_line_5_3_scale_c
+
+void vp8_horizontal_line_5_4_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_4_scale vp8_horizontal_line_5_4_scale_c
+
+void vp8_vertical_band_2_1_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale vp8_vertical_band_2_1_scale_c
+
+void vp8_vertical_band_2_1_scale_i_c(unsigned char* source,
+                                     unsigned int src_pitch,
+                                     unsigned char* dest,
+                                     unsigned int dest_pitch,
+                                     unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale_i vp8_vertical_band_2_1_scale_i_c
+
+void vp8_vertical_band_5_3_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_3_scale vp8_vertical_band_5_3_scale_c
+
+void vp8_vertical_band_5_4_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_4_scale vp8_vertical_band_5_4_scale_c
+
+void vp8_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vp8_yv12_copy_frame vp8_yv12_copy_frame_c
+
+void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c
+
+void vpx_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_borders vpx_extend_frame_borders_c
+
+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c
+
+void vpx_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_frame vpx_yv12_copy_frame_c
+
+void vpx_yv12_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                       struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_y vpx_yv12_copy_y_c
+
+void vpx_scale_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+static void setup_rtcd_internal(void) {}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff --git a/third_party/lss/linux_syscall_support.h b/third_party/lss/linux_syscall_support.h
index 8d4e4d2a18..c4346105c8 100644
--- a/third_party/lss/linux_syscall_support.h
+++ b/third_party/lss/linux_syscall_support.h
@@ -88,7 +88,7 @@
  */
 #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) ||   \
      defined(__mips__) || defined(__PPC__) || defined(__ARM_EABI__) || \
-     defined(__aarch64__) || defined(__s390__)) || defined(__e2k__)  \
+     defined(__aarch64__) || defined(__s390__) || defined(__loongarch64)) || defined(__e2k__) \
   && (defined(__linux) || defined(__ANDROID__))
 
 #ifndef SYS_CPLUSPLUS
@@ -302,8 +302,8 @@ struct kernel_old_sigaction {
 } __attribute__((packed,aligned(4)));
 #elif (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
   #define kernel_old_sigaction kernel_sigaction
-#elif defined(__aarch64__)
-  // No kernel_old_sigaction defined for arm64.
+#elif defined(__aarch64__)|| defined(__loongarch64)
+  // No kernel_old_sigaction defined for arm64 and loongarch64.
 #endif
 
 /* Some kernel functions (e.g. sigaction() in 2.6.23) require that the
@@ -315,7 +315,7 @@ struct kernel_old_sigaction {
  * actual number of signals is obviously the same, but the constants
  * differ by one.
  */
-#ifdef __mips__
+#if defined(__mips__) || defined(__loongarch64)
 #define KERNEL_NSIG 128
 #else
 #define KERNEL_NSIG  64
@@ -542,7 +542,7 @@ struct kernel_stat {
   int                st_blocks;
   int                st_pad4[14];
 };
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
 struct kernel_stat {
   unsigned long      st_dev;
   unsigned long      st_ino;
@@ -648,7 +648,7 @@ struct kernel_statfs64 {
   unsigned long      f_spare[6];
 };
 #endif
-#elif defined(__s390__)
+#elif defined(__s390__) || defined(__loongarch64)
 /* See also arch/s390/include/asm/compat.h                                   */
 struct kernel_statfs64 {
   unsigned int       f_type;
@@ -712,7 +712,7 @@ struct kernel_statfs {
   uint64_t           f_frsize;
   uint64_t           f_spare[5];
 };
-#elif defined(__s390__)
+#elif defined(__s390__) || defined(__loongarch64)
 struct kernel_statfs {
   unsigned int       f_type;
   unsigned int       f_bsize;
@@ -1110,7 +1110,7 @@ struct kernel_statfs {
 #define __NR_getrandom          (__NR_SYSCALL_BASE + 384)
 #endif
 /* End of ARM 3/EABI definitions                                             */
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
 #ifndef __NR_setxattr
 #define __NR_setxattr             5
 #endif
@@ -1926,7 +1926,7 @@ struct kernel_statfs {
   #undef  LSS_RETURN
   #if (defined(__i386__) || defined(__x86_64__) || defined(__ARM_ARCH_3__) \
        || defined(__ARM_EABI__) || defined(__aarch64__) || defined(__s390__)) \
-       || defined(__e2k__)
+       || defined(__e2k__) || defined(__loongarch64)
   /* Failing system calls return a negative result in the range of
    * -1..-4095. These are "errno" values with the sign inverted.
    */
@@ -2879,6 +2879,134 @@ struct kernel_statfs {
       }
       LSS_RETURN(int, __res);
     }
+  #elif defined(__loongarch64)
+    /* Most definitions of _syscallX() neglect to mark "memory" as being
+     * clobbered. This causes problems with compilers, that do a better job
+     * at optimizing across __asm__ calls.
+     * So, we just have to redefine all of the _syscallX() macros.
+     */
+    #undef LSS_REG
+    #define LSS_REG(ar,a) register int64_t __a##ar __asm__("a"#ar) = (int64_t)a
+    // TODO(loonngson): Recheck LSS_SYSCALL_CLOBBERS for loongarch64
+    /* syscall is like subroutine calls, all caller-saved registers may be
+     * clobbered, we should add them to the |Clobbers| list.
+     * a0 is not included because it's in the output list.
+     */
+    #define LSS_SYSCALL_CLOBBERS "a1", "a2", "a3", "a4", "a5", "a6", "a7",    \
+                                 "t0", "t1", "t2", "t3", "t4", "t5", "t6",    \
+                                 "t7", "t8", "memory"
+    #undef  LSS_BODY
+    #define LSS_BODY(type,name,args...)                                       \
+          register int64_t __res_a0 __asm__("a0");                            \
+          int64_t __res;                                                      \
+          __asm__ __volatile__ ("li.w $a7, %1\n"                                \
+                                "syscall 0x0\n"                               \
+                                : "=r"(__res_a0)                              \
+                                : "i"(__NR_##name) , ## args                  \
+                                : LSS_SYSCALL_CLOBBERS);                      \
+          __res = __res_a0;                                                   \
+          LSS_RETURN(type, __res)
+    #undef _syscall0
+    #define _syscall0(type, name)                                             \
+      type LSS_NAME(name)(void) {                                             \
+        LSS_BODY(type, name);                                                 \
+      }
+    #undef _syscall1
+    #define _syscall1(type, name, type1, arg1)                                \
+      type LSS_NAME(name)(type1 arg1) {                                       \
+        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__a0));                    \
+      }
+    #undef _syscall2
+    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
+      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1));                           \
+      }
+    #undef _syscall3
+    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2));                \
+      }
+    #undef _syscall4
+    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4);                                                     \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3));     \
+      }
+    #undef _syscall5
+    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5)                                             \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5) {                                       \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4));                                      \
+      }
+    #undef _syscall6
+    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5,type6,arg6)                                  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5, type6 arg6) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4), "r"(__a5));                           \
+      }
+
+    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
+                                   int flags, void *arg, int *parent_tidptr,
+                                   void *newtls, int *child_tidptr) {
+      int64_t __res;
+      {
+        register uint64_t __flags __asm__("a0") = flags;
+        register void *__stack __asm__("a1") = child_stack;
+        register void *__ptid  __asm__("a2") = parent_tidptr;
+        register void *__tls   __asm__("a3") = newtls;
+        register int  *__ctid  __asm__("a4") = child_tidptr;
+        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
+                              * used by the child.
+                              */
+                             "addi.d  %2, %2, -16\n"
+                             "st.d    %1, %2, 8\n"
+                             "st.d    %4, %2, 0\n"
+
+                             /* %a0 = syscall(%a0 = flags,
+                              *               %a1 = child_stack,
+                              *               %a2 = parent_tidptr,
+                              *               %a3 = newtls,
+                              *               %a4 = child_tidptr)
+                              */
+                             "li.w      $a7, %8\n"
+                             "syscall    0x0\n"
+
+                             /* if (%a0 != 0)
+                              *   return %a0;
+                              */
+                             "bnez    $a0, 1f\n"
+
+                             /* In the child, now. Call "fn(arg)".
+                              */
+                             "ld.d    $a0, $sp, 0\n"
+                             "ld.d    $a1, $sp, 8\n"
+                             "addi.d  $sp, $sp, 16\n"
+                             "jirl    $ra, $a1, 0\n"
+
+                             /* Call _exit(%a0).
+                              */
+                             "li.w     $a7, %9\n"
+                             "syscall    0x0\n"
+                           "1:\n"
+                             : "=r" (__res)
+                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
+                               "r"(__ptid), "r"(__tls), "r"(__ctid),
+                               "i"(__NR_clone), "i"(__NR_exit)
+                             : LSS_SYSCALL_CLOBBERS);
+      }
+      LSS_RETURN(int, __res);
+    }
   #elif defined(__mips__)
     #undef LSS_REG
     #define LSS_REG(r,a) register unsigned long __r##r __asm__("$"#r) =       \
@@ -4484,7 +4612,7 @@ struct kernel_statfs {
       LSS_SC_BODY(4, int, 8, d, type, protocol, sv);
     }
   #endif
-  #if defined(__ARM_EABI__) || defined (__aarch64__)
+  #if defined(__ARM_EABI__) || defined (__aarch64__) || defined (__loongarch64)
     LSS_INLINE _syscall3(ssize_t, recvmsg, int, s, struct kernel_msghdr*, msg,
                          int, flags)
     LSS_INLINE _syscall3(ssize_t, sendmsg, int, s, const struct kernel_msghdr*,
@@ -4831,6 +4959,25 @@ struct kernel_statfs {
     LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
              "r"(__r4));
   }
+# elif defined(__loongarch64)
+  LSS_INLINE pid_t LSS_NAME(fork)(void) {
+    // No fork syscall on aarch64 - implement by means of the clone syscall.
+    // Note that this does not reset glibc's cached view of the PID/TID, so
+    // some glibc interfaces might go wrong in the forked subprocess.
+    int flags = SIGCHLD;
+    void *child_stack = NULL;
+    void *parent_tidptr = NULL;
+    void *newtls = NULL;
+    void *child_tidptr = NULL;
+
+    LSS_REG(0, flags);
+    LSS_REG(1, child_stack);
+    LSS_REG(2, parent_tidptr);
+    LSS_REG(3, newtls);
+    LSS_REG(4, child_tidptr);
+    LSS_BODY(pid_t, clone, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),
+             "r"(__a4));
+  }
 # elif defined(__x86_64__)
   LSS_INLINE pid_t LSS_NAME(fork)(void) {
     // Android disallows the fork syscall on x86_64 - implement by means of the
diff --git a/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h b/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
index fdc65ac47b..b6fb719d29 100644
--- a/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
+++ b/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator_constants.h
@@ -48,7 +48,7 @@ constexpr ALWAYS_INLINE int PageAllocationGranularityShift() {
   // compiled for 64kB are likely to work on 4kB systems, 64kB is a good choice
   // here.
   return 16;  // 64kB
-#elif defined(_MIPS_ARCH_LOONGSON)
+#elif defined(_MIPS_ARCH_LOONGSON) || defined(ARCH_CPU_LOONG64)
   return 14;  // 16kB
 #else
   return 12;  // 4kB
diff --git a/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc_constants.h b/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc_constants.h
index e3bcf5a993..ff8bdb1ea7 100644
--- a/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc_constants.h
+++ b/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc_constants.h
@@ -39,7 +39,7 @@ static const size_t kBucketShift = (kAllocationGranularity == 8) ? 3 : 2;
 // other constant values, we pack _all_ `PartitionRootGeneric::Alloc` sizes
 // perfectly up against the end of a system page.
 
-#if defined(_MIPS_ARCH_LOONGSON)
+#if defined(_MIPS_ARCH_LOONGSON) || defined(ARCH_CPU_LOONG64)
 PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR ALWAYS_INLINE int
 PartitionPageShift() {
   return 16;  // 64 KiB
diff --git a/third_party/pffft/BUILD.gn b/third_party/pffft/BUILD.gn
index 0a1cf7a1f5..928b2127d8 100644
--- a/third_party/pffft/BUILD.gn
+++ b/third_party/pffft/BUILD.gn
@@ -19,7 +19,7 @@ config("common_config") {
   # PFFFT doesn't support SIMD on some cpus, so build a scalar version.
   if ((current_cpu == "arm" && !arm_use_neon) || current_cpu == "mipsel" ||
       current_cpu == "mips64el" || current_cpu == "ppc64" ||
-      current_cpu == "s390x") {
+      current_cpu == "s390x" || current_cpu == "loong64") {
     defines = [ "PFFFT_SIMD_DISABLE" ]
   }
 }
diff --git a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
index 80bcf41136..20a0f0deaf 100644
--- a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
+++ b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
@@ -151,6 +151,8 @@ swiftshader_llvm_source_set("swiftshader_llvm") {
     deps += [ ":swiftshader_llvm_mips" ]
   } else if (current_cpu == "ppc64") {
     deps += [ ":swiftshader_llvm_ppc" ]
+  } else if (current_cpu == "loong64") {
+    # TODO: Add support.
   } else if (current_cpu == "x86" || current_cpu == "x64") {
     deps += [ ":swiftshader_llvm_x86" ]
   } else {
diff --git a/third_party/swiftshader/third_party/marl/BUILD.gn b/third_party/swiftshader/third_party/marl/BUILD.gn
index e1e29b1d5d..643e42d59e 100644
--- a/third_party/swiftshader/third_party/marl/BUILD.gn
+++ b/third_party/swiftshader/third_party/marl/BUILD.gn
@@ -92,6 +92,12 @@ swiftshader_source_set("Marl") {
         "src/osfiber_asm_x86.h",
         "src/osfiber_asm_x86.S",
       ]
+    } else if (current_cpu == "loong64") {
+      sources += [
+        "src/osfiber_loong64.c",
+        "src/osfiber_asm_loong64.h",
+        "src/osfiber_asm_loong64.S",
+      ]
     } else {
       assert(false, "Unhandled value for current-cpu=" + current_cpu)
     }
diff --git a/third_party/swiftshader/third_party/marl/CMakeLists.txt b/third_party/swiftshader/third_party/marl/CMakeLists.txt
index 015732dd4f..ddc85475b1 100644
--- a/third_party/swiftshader/third_party/marl/CMakeLists.txt
+++ b/third_party/swiftshader/third_party/marl/CMakeLists.txt
@@ -159,10 +159,12 @@ if(NOT MSVC)
         ${MARL_SRC_DIR}/osfiber_asm_aarch64.S
         ${MARL_SRC_DIR}/osfiber_asm_arm.S
         ${MARL_SRC_DIR}/osfiber_asm_mips64.S
+        ${MARL_SRC_DIR}/osfiber_asm_loong64.S
         ${MARL_SRC_DIR}/osfiber_asm_ppc64.S
         ${MARL_SRC_DIR}/osfiber_asm_x64.S
         ${MARL_SRC_DIR}/osfiber_asm_x86.S
         ${MARL_SRC_DIR}/osfiber_mips64.c
+        ${MARL_SRC_DIR}/osfiber_loong64.c
         ${MARL_SRC_DIR}/osfiber_ppc64.c
         ${MARL_SRC_DIR}/osfiber_x64.c
         ${MARL_SRC_DIR}/osfiber_x86.c
diff --git a/third_party/swiftshader/third_party/marl/README.md b/third_party/swiftshader/third_party/marl/README.md
index 1c1778bc4c..48207078d5 100644
--- a/third_party/swiftshader/third_party/marl/README.md
+++ b/third_party/swiftshader/third_party/marl/README.md
@@ -8,7 +8,7 @@ Marl is a C++ 11 library that provides a fluent interface for running tasks acro
 
 Marl uses a combination of fibers and threads to allow efficient execution of tasks that can block, while keeping a fixed number of hardware threads.
 
-Marl supports Windows, macOS, Linux, FreeBSD, Fuchsia, Android and iOS (arm, aarch64, mips64, ppc64, x86 and x64).
+Marl supports Windows, macOS, Linux, FreeBSD, Fuchsia, Android and iOS (arm, aarch64, mips64, ppc64, loong64, x86 and x64).
 
 Marl has no dependencies on other libraries (with an exception on googletest for building the optional unit tests).
 
diff --git a/third_party/swiftshader/third_party/marl/src/osfiber_asm.h b/third_party/swiftshader/third_party/marl/src/osfiber_asm.h
index fe8679a9be..84e25e891f 100644
--- a/third_party/swiftshader/third_party/marl/src/osfiber_asm.h
+++ b/third_party/swiftshader/third_party/marl/src/osfiber_asm.h
@@ -34,6 +34,8 @@
 #include "osfiber_asm_ppc64.h"
 #elif defined(__mips__) && _MIPS_SIM == _ABI64
 #include "osfiber_asm_mips64.h"
+#elif defined(__loongarch64)
+#include "osfiber_asm_loong64.h"
 #else
 #error "Unsupported target"
 #endif
diff --git a/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.S b/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.S
new file mode 100644
index 0000000000..3eafc6524a
--- /dev/null
+++ b/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.S
@@ -0,0 +1,86 @@
+// Copyright 2021 The Marl Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#if defined(__loongarch64)
+
+#define MARL_BUILD_ASM 1
+#include "osfiber_asm_loong64.h"
+
+// void marl_fiber_swap(marl_fiber_context* from, const marl_fiber_context* to)
+// a0: from
+// a1: to
+.text
+.global marl_fiber_swap
+.align 4
+marl_fiber_swap:
+
+    // Save context 'from'
+
+    // Store callee-preserved registers
+    st.d  s0, MARL_REG_s0(a0)
+    st.d  s1, MARL_REG_s1(a0)
+    st.d  s2, MARL_REG_s2(a0)
+    st.d  s3, MARL_REG_s3(a0)
+    st.d  s4, MARL_REG_s4(a0)
+    st.d  s5, MARL_REG_s5(a0)
+    st.d  s6, MARL_REG_s6(a0)
+    st.d  s7, MARL_REG_s7(a0)
+    st.d  s8, MARL_REG_s8(a0)
+
+    fst.d  fs0, MARL_REG_fs0(a0)
+    fst.d  fs1, MARL_REG_fs1(a0)
+    fst.d  fs2, MARL_REG_fs2(a0)
+    fst.d  fs3, MARL_REG_fs3(a0)
+    fst.d  fs4, MARL_REG_fs4(a0)
+    fst.d  fs5, MARL_REG_fs5(a0)
+    fst.d  fs6, MARL_REG_fs6(a0)
+    fst.d  fs7, MARL_REG_fs7(a0)
+
+    st.d  sp, MARL_REG_sp(a0)
+    // On RISC-V ra is caller-saved
+    // but we need ra to jump to the trampoline
+    st.d  ra, MARL_REG_ra(a0)
+
+    move  t0, a1 // Store a1 in temporary register
+
+    // Recover callee-preserved registers
+    ld.d  s0, MARL_REG_s0(t0)
+    ld.d  s1, MARL_REG_s1(t0)
+    ld.d  s2, MARL_REG_s2(t0)
+    ld.d  s3, MARL_REG_s3(t0)
+    ld.d  s4, MARL_REG_s4(t0)
+    ld.d  s5, MARL_REG_s5(t0)
+    ld.d  s6, MARL_REG_s6(t0)
+    ld.d  s7, MARL_REG_s7(t0)
+    ld.d  s8, MARL_REG_s8(t0)
+
+    fld.d  fs0, MARL_REG_fs0(t0)
+    fld.d  fs1, MARL_REG_fs1(t0)
+    fld.d  fs2, MARL_REG_fs2(t0)
+    fld.d  fs3, MARL_REG_fs3(t0)
+    fld.d  fs4, MARL_REG_fs4(t0)
+    fld.d  fs5, MARL_REG_fs5(t0)
+    fld.d  fs6, MARL_REG_fs6(t0)
+    fld.d  fs7, MARL_REG_fs7(t0)
+
+    ld.d  sp, MARL_REG_sp(t0)
+    ld.d  ra, MARL_REG_ra(t0)
+
+    // Recover arguments
+    ld.d  a0, MARL_REG_a0(t0)
+    ld.d  a1, MARL_REG_a1(t0)
+
+    jr	ra // Jump to the trampoline
+
+#endif // defined(__loongarch64)
diff --git a/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.h b/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.h
new file mode 100644
index 0000000000..a37dad3ff5
--- /dev/null
+++ b/third_party/swiftshader/third_party/marl/src/osfiber_asm_loong64.h
@@ -0,0 +1,117 @@
+// Copyright 2021 The Marl Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+
+#define MARL_REG_a0 0x00
+#define MARL_REG_a1 0x08
+#define MARL_REG_s0 0x10
+#define MARL_REG_s1 0x18
+#define MARL_REG_s2 0x20
+#define MARL_REG_s3 0x28
+#define MARL_REG_s4 0x30
+#define MARL_REG_s5 0x38
+#define MARL_REG_s6 0x40
+#define MARL_REG_s7 0x48
+#define MARL_REG_s8 0x50
+#define MARL_REG_fs0 0x58
+#define MARL_REG_fs1 0x60
+#define MARL_REG_fs2 0x68
+#define MARL_REG_fs3 0x70
+#define MARL_REG_fs4 0x78
+#define MARL_REG_fs5 0x80
+#define MARL_REG_fs6 0x88
+#define MARL_REG_fs7 0x90
+#define MARL_REG_sp 0x98
+#define MARL_REG_ra 0xa0
+
+#ifndef MARL_BUILD_ASM
+
+#include <stdint.h>
+
+struct marl_fiber_context {
+  // parameter registers (First two)
+  uintptr_t a0;
+  uintptr_t a1;
+
+  // callee-saved registers
+  uintptr_t s0;
+  uintptr_t s1;
+  uintptr_t s2;
+  uintptr_t s3;
+  uintptr_t s4;
+  uintptr_t s5;
+  uintptr_t s6;
+  uintptr_t s7;
+  uintptr_t s8;
+
+  uintptr_t fs0;
+  uintptr_t fs1;
+  uintptr_t fs2;
+  uintptr_t fs3;
+  uintptr_t fs4;
+  uintptr_t fs5;
+  uintptr_t fs6;
+  uintptr_t fs7;
+
+  uintptr_t sp;
+  uintptr_t ra;
+};
+
+#ifdef __cplusplus
+#include <cstddef>
+static_assert(offsetof(marl_fiber_context, a0) == MARL_REG_a0,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, a1) == MARL_REG_a1,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s0) == MARL_REG_s0,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s1) == MARL_REG_s1,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s2) == MARL_REG_s2,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s3) == MARL_REG_s3,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s4) == MARL_REG_s4,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s5) == MARL_REG_s5,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s6) == MARL_REG_s6,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s7) == MARL_REG_s7,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, s8) == MARL_REG_s8,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs0) == MARL_REG_fs0,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs1) == MARL_REG_fs1,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs2) == MARL_REG_fs2,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs3) == MARL_REG_fs3,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs4) == MARL_REG_fs4,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs5) == MARL_REG_fs5,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs6) == MARL_REG_fs6,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, fs7) == MARL_REG_fs7,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, sp) == MARL_REG_sp,
+              "Bad register offset");
+static_assert(offsetof(marl_fiber_context, ra) == MARL_REG_ra,
+              "Bad register offset");
+#endif  // __cplusplus
+
+#endif  // MARL_BUILD_ASM
diff --git a/third_party/swiftshader/third_party/marl/src/osfiber_loong64.c b/third_party/swiftshader/third_party/marl/src/osfiber_loong64.c
new file mode 100644
index 0000000000..284bf41a4e
--- /dev/null
+++ b/third_party/swiftshader/third_party/marl/src/osfiber_loong64.c
@@ -0,0 +1,39 @@
+// Copyright 2021 The Marl Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#if defined(__loongarch64)
+
+#include "osfiber_asm_loong64.h"
+
+#include "marl/export.h"
+
+MARL_EXPORT
+void marl_fiber_trampoline(void (*target)(void*), void* arg) {
+  target(arg);
+}
+
+MARL_EXPORT
+void marl_fiber_set_target(struct marl_fiber_context* ctx,
+                           void* stack,
+                           uint32_t stack_size,
+                           void (*target)(void*),
+                           void* arg) {
+  uintptr_t* stack_top = (uintptr_t*)((uint8_t*)(stack) + stack_size);
+  ctx->ra = (uintptr_t)&marl_fiber_trampoline;
+  ctx->a0 = (uintptr_t)target;
+  ctx->a1 = (uintptr_t)arg;
+  ctx->sp = ((uintptr_t)stack_top) & ~(uintptr_t)15;
+}
+
+#endif  // defined(__loongarch64)
diff --git a/third_party/tcmalloc/chromium/src/base/basictypes.h b/third_party/tcmalloc/chromium/src/base/basictypes.h
index 3bf59f4e5f..53265a1a75 100644
--- a/third_party/tcmalloc/chromium/src/base/basictypes.h
+++ b/third_party/tcmalloc/chromium/src/base/basictypes.h
@@ -384,6 +384,8 @@ class AssignAttributeStartEnd {
     // implementation specific, Cortex-A53 and 57 should have 64 bytes
 # elif (defined(__s390__))
 #   define CACHELINE_ALIGNED __attribute__((aligned(256)))
+# elif (defined(__loongarch64))
+#   define CACHELINE_ALIGNED __attribute__((aligned(128)))
 # else
 #   error Could not determine cache line length - unknown architecture
 # endif
diff --git a/third_party/tcmalloc/chromium/src/base/linux_syscall_support.h b/third_party/tcmalloc/chromium/src/base/linux_syscall_support.h
index 1743bc9ce2..8846715fe1 100644
--- a/third_party/tcmalloc/chromium/src/base/linux_syscall_support.h
+++ b/third_party/tcmalloc/chromium/src/base/linux_syscall_support.h
@@ -136,7 +136,7 @@
  */
 #if (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
      defined(__mips__) || defined(__PPC__) || \
-     defined(__aarch64__) || defined(__s390__)) \
+     defined(__aarch64__) || defined(__s390__) || defined(__loongarch64)) \
   && (defined(__linux))
 
 #ifndef SYS_CPLUSPLUS
@@ -264,7 +264,7 @@ struct kernel_old_sigaction {
 } __attribute__((packed,aligned(4)));
 #elif (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32)
   #define kernel_old_sigaction kernel_sigaction
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
   // No kernel_old_sigaction defined for arm64.
 #endif
 
@@ -277,7 +277,7 @@ struct kernel_old_sigaction {
  * actual number of signals is obviously the same, but the constants
  * differ by one.
  */
-#ifdef __mips__
+#if defined(__mips__) || defined(__loongarch64)
 #define KERNEL_NSIG 128
 #else
 #define KERNEL_NSIG  64
@@ -474,7 +474,7 @@ struct kernel_stat {
   int                st_blocks;
   int                st_pad4[14];
 };
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
 struct kernel_stat {
   unsigned long      st_dev;
   unsigned long      st_ino;
@@ -750,7 +750,7 @@ struct kernel_stat {
 #define __NR_getcpu             302
 #endif
 /* End of powerpc defininitions                                              */
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch64)
 #ifndef __NR_fstatat
 #define __NR_fstatat             79
 #endif
@@ -1001,7 +1001,7 @@ struct kernel_stat {
 
   #undef  LSS_RETURN
   #if (defined(__i386__) || defined(__x86_64__) || defined(__arm__) ||        \
-       defined(__aarch64__) || defined(__s390__))
+       defined(__aarch64__) || defined(__s390__) || defined(__loongarch64))
   /* Failing system calls return a negative result in the range of
    * -1..-4095. These are "errno" values with the sign inverted.
    */
@@ -2323,6 +2323,141 @@ struct kernel_stat {
       }
       LSS_RETURN(int, __res);
     }
+  #elif defined(__loongarch64)
+    #undef LSS_REG
+    #define LSS_REG(ar,a) register long __a##ar __asm__("a"#ar) = (long)a
+    #undef  LSS_BODY
+    #define LSS_BODY(type,name,args...)                                         \
+          register long __res_a0 __asm__("a0");                                 \
+          long __res;                                                           \
+          __asm__ __volatile__ ("li $a7, %1\n"                                  \
+                                "syscall 0x0\n"                                 \
+                                : "=r"(__res_a0)                                \
+                                : "i"(__NR_##name) , ## args                    \
+                                : "a7", "memory");                              \
+          __res = __res_a0;                                                     \
+          LSS_RETURN(type, __res)
+    #undef _syscall0
+    #define _syscall0(type, name)                                               \
+      type LSS_NAME(name)(void) {                                               \
+        LSS_BODY(type, name);                                                   \
+      }
+    #undef _syscall1
+    #define _syscall1(type, name, type1, arg1)                                  \
+      type LSS_NAME(name)(type1 arg1) {                                         \
+        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__a0));                      \
+      }
+    #undef _syscall2
+    #define _syscall2_long(type, name, syscall, type1, arg1, type2, arg2)       \
+      type LSS_NAME(name)(type1 arg1, type2 arg2) {                             \
+        LSS_REG(0, arg1); LSS_REG(1, arg2);                                     \
+        LSS_BODY(type, syscall, "r"(__a0), "r"(__a1));                          \
+      }
+    #define _syscall2(type, name, type1, arg1, type2, arg2)                     \
+            _syscall2_long(type, name, name, type1, arg1, type2, arg2)
+    #undef _syscall3
+    #define _syscall3_long(type, name, syscall, type1, arg1, type2, arg2,       \
+                           type3, arg3)                                         \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {                 \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                   \
+        LSS_BODY(type, syscall, "r"(__a0), "r"(__a1), "r"(__a2));               \
+      }
+    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)        \
+            _syscall3_long(type, name, name, type1, arg1, type2, arg2,          \
+                           type3, arg3)
+    #undef _syscall4
+    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)    \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {     \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                   \
+        LSS_REG(3, arg4);                                                       \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3));       \
+      }
+    #undef _syscall5
+    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,    \
+                      type5,arg5)                                               \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,       \
+                          type5 arg5) {                                         \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                   \
+        LSS_REG(3, arg4); LSS_REG(4, arg5);                                     \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),        \
+                             "r"(__a4));                                        \
+      }
+    #undef _syscall6
+    #define _syscall6_long(type,name,syscall,type1,arg1,type2,arg2,type3,arg3,  \
+                           type4,arg4,type5,arg5,type6,arg6)                    \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,       \
+                          type5 arg5, type6 arg6) {                             \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                   \
+        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                   \
+        LSS_BODY(type, syscall, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),     \
+                             "r"(__a4), "r"(__a5));                             \
+      }
+    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,    \
+                      type5,arg5,type6,arg6)                                    \
+            _syscall6_long(type,name,name,type1,arg1,type2,arg2,type3,arg3,     \
+                           type4,arg4,type5,arg5,type6,arg6)
+    /* clone function adapted from glibc 2.18 clone.S                       */
+    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
+                                   int flags, void *arg, int *parent_tidptr,
+                                   void *newtls, int *child_tidptr) {
+      long __res;
+      {
+        register int (*__fn)(void *)  __asm__("a0") = fn;
+        register void *__stack __asm__("a1") = child_stack;
+        register int   __flags __asm__("a2") = flags;
+        register void *__arg   __asm__("a3") = arg;
+        register int  *__ptid  __asm__("a4") = parent_tidptr;
+        register void *__tls   __asm__("a5") = newtls;
+        register int  *__ctid  __asm__("a6") = child_tidptr;
+        __asm__ __volatile__(/* if (fn == NULL || child_stack == NULL)
+                              *   return -EINVAL;
+                              */
+                             "beqz    $a0,1f\n"
+                             "beqz    $a1,1f\n"
+
+                             /* Push "arg" and "fn" onto the stack that will be
+                              * used by the child.
+                              */
+                             "addi.d  $a1, $a1, -16\n"
+                             "st.d    $a0, $a1, 8\n"
+                             "st.d    $a3, $a1, 0\n"
+
+                             "mov $a0, $a2\n" /* flags  */
+                             "mov $a2, $a4\n" /* ptid  */
+                             "mov $a3, $a5\n" /* tls */
+                             "mov $a4, $a6\n" /* ctid */
+                             "mov $a7, %9\n" /* clone */
+
+                             "syscall 0x0\n"
+
+                             /* if (%a0 != 0)
+                              *   return %a0;
+                              */
+                             "bnez $a0, 2f\n"
+
+                             /* In the child, now. Call "fn(arg)".
+                              */
+                             "ld.d    $a0, $sp, 0\n"
+                             "ld.d    $a1, $sp, 8\n"
+                             "addi.d  $sp, $sp, 16\n"
+                             "jirl    $ra, $a1, 0\n"
+
+                             /* Call _exit(%a0).
+                              */
+                             "li  $a7, %10\n"
+                             "syscall 0x0\n"
+                           "1:\n"
+                             "li  $a7, %1\n"
+                           "2:\n"
+                             : "=r" (__res)
+                             : "i"(-EINVAL),
+                               "r"(__fn), "r"(__stack), "r"(__flags), "r"(__arg),
+                               "r"(__ptid), "r"(__tls), "r"(__ctid),
+                               "i"(__NR_clone), "i"(__NR_exit)
+                             : "ra", "memory");
+      }
+      LSS_RETURN(int, __res);
+    }
   #elif defined(__s390__)
     #undef  LSS_REG
     #define LSS_REG(r, a) register unsigned long __r##r __asm__("r"#r) = (unsigned long) a
@@ -2548,7 +2683,7 @@ struct kernel_stat {
     LSS_INLINE _syscall3(long, getcpu, unsigned *, cpu,
                          unsigned *, node, void *, unused);
   #endif
-  #if defined(__x86_64__) || defined(__aarch64__) || \
+  #if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch64) || \
      (defined(__mips__) && _MIPS_SIM != _MIPS_SIM_ABI32)
     LSS_INLINE _syscall3(int, socket,             int,   d,
                          int,                     t, int,       p)
@@ -2581,7 +2716,7 @@ struct kernel_stat {
       return LSS_NAME(rt_sigprocmask)(how, set, oldset, (KERNEL_NSIG+7)/8);
     }
   #endif
-  #if (defined(__aarch64__)) || \
+  #if (defined(__aarch64__)) || defined(__loongarch64) || \
       (defined(__mips__) \
        && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32))
     LSS_INLINE int LSS_NAME(sigaction)(int signum,
diff --git a/third_party/tcmalloc/chromium/src/base/linuxthreads.h b/third_party/tcmalloc/chromium/src/base/linuxthreads.h
index 09ce45fc13..5e3e9effdc 100644
--- a/third_party/tcmalloc/chromium/src/base/linuxthreads.h
+++ b/third_party/tcmalloc/chromium/src/base/linuxthreads.h
@@ -42,7 +42,7 @@
  */
 #if (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
      defined(__mips__) || defined(__PPC__) || defined(__aarch64__) ||       \
-     defined(__s390__)) && defined(__linux)
+     defined(__s390__) || defined(__loongarch64)) && defined(__linux)
 
 /* Define the THREADS symbol to make sure that there is exactly one core dumper
  * built into the library.
diff --git a/third_party/tcmalloc/chromium/src/common.h b/third_party/tcmalloc/chromium/src/common.h
index 7ad83d3a75..5d9d4bb29d 100644
--- a/third_party/tcmalloc/chromium/src/common.h
+++ b/third_party/tcmalloc/chromium/src/common.h
@@ -137,7 +137,7 @@ static const int kMaxDynamicFreeListLength = 8192;
 
 static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;
 
-#if __aarch64__ || __x86_64__ || _M_AMD64 || _M_ARM64
+#if __aarch64__ || __loongarch64 || __x86_64__ || _M_AMD64 || _M_ARM64
 // All current x86_64 processors only look at the lower 48 bits in
 // virtual to physical address translation. The top 16 are all same as
 // bit 47. And bit 47 value 1 reserved for kernel-space addresses in
diff --git a/third_party/tcmalloc/chromium/src/malloc_hook_mmap_linux.h b/third_party/tcmalloc/chromium/src/malloc_hook_mmap_linux.h
index 17415aaf53..9fe17c24fe 100644
--- a/third_party/tcmalloc/chromium/src/malloc_hook_mmap_linux.h
+++ b/third_party/tcmalloc/chromium/src/malloc_hook_mmap_linux.h
@@ -56,7 +56,7 @@
     || defined(__PPC64__) \
     || defined(__aarch64__) \
     || (defined(_MIPS_SIM) && (_MIPS_SIM == _ABI64 || _MIPS_SIM == _ABIN32)) \
-    || defined(__s390__)
+    || defined(__s390__) || defined(__loongarch64)
 
 static inline void* do_mmap64(void *start, size_t length,
                               int prot, int flags,
diff --git a/third_party/tcmalloc/chromium/src/tcmalloc.cc b/third_party/tcmalloc/chromium/src/tcmalloc.cc
index 559082a906..bb728ed583 100644
--- a/third_party/tcmalloc/chromium/src/tcmalloc.cc
+++ b/third_party/tcmalloc/chromium/src/tcmalloc.cc
@@ -179,7 +179,8 @@ DECLARE_double(tcmalloc_release_rate);
 // jump. I am not able to reproduce that anymore.
 #if !defined(__i386__) && !defined(__x86_64__) && \
     !defined(__ppc__) && !defined(__PPC__) && \
-    !defined(__aarch64__) && !defined(__mips__) && !defined(__arm__)
+    !defined(__aarch64__) && !defined(__mips__) && !defined(__arm__) && \
+    !defined(__loongarch64)
 #undef TCMALLOC_NO_ALIASES
 #define TCMALLOC_NO_ALIASES
 #endif
diff --git a/third_party/tcmalloc/vendor/src/malloc_hook_mmap_linux.h b/third_party/tcmalloc/vendor/src/malloc_hook_mmap_linux.h
index 2f6116fa45..2c2bdb20cc 100755
--- a/third_party/tcmalloc/vendor/src/malloc_hook_mmap_linux.h
+++ b/third_party/tcmalloc/vendor/src/malloc_hook_mmap_linux.h
@@ -56,7 +56,7 @@
     || defined(__PPC64__) \
     || defined(__aarch64__) \
     || (defined(_MIPS_SIM) && (_MIPS_SIM == _ABI64 || _MIPS_SIM == _ABIN32)) \
-    || defined(__s390__)
+    || defined(__s390__) || define(__loongarch64)
 
 static inline void* do_mmap64(void *start, size_t length,
                               int prot, int flags,
diff --git a/third_party/webrtc/modules/desktop_capture/differ_block.cc b/third_party/webrtc/modules/desktop_capture/differ_block.cc
index 4f0c5430c9..7d62f7d6a9 100644
--- a/third_party/webrtc/modules/desktop_capture/differ_block.cc
+++ b/third_party/webrtc/modules/desktop_capture/differ_block.cc
@@ -30,8 +30,8 @@ bool VectorDifference(const uint8_t* image1, const uint8_t* image2) {
   static bool (*diff_proc)(const uint8_t*, const uint8_t*) = nullptr;
 
   if (!diff_proc) {
-#if defined(WEBRTC_ARCH_ARM_FAMILY) || defined(WEBRTC_ARCH_MIPS_FAMILY)
-    // For ARM and MIPS processors, always use C version.
+#if defined(WEBRTC_ARCH_ARM_FAMILY) || defined(WEBRTC_ARCH_MIPS_FAMILY) || defined(WEBRTC_ARCH_LOONG_FAMILY)
+    // For ARM, MIPS and LoongArch processors, always use C version.
     // TODO(hclam): Implement a NEON version.
     diff_proc = &VectorDifference_C;
 #else
diff --git a/third_party/webrtc/rtc_base/system/arch.h b/third_party/webrtc/rtc_base/system/arch.h
index be2367b85f..c31ae35c45 100644
--- a/third_party/webrtc/rtc_base/system/arch.h
+++ b/third_party/webrtc/rtc_base/system/arch.h
@@ -73,6 +73,10 @@
 #elif defined(__riscv) && __riscv_xlen == 32
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
+#elif defined(__loongarch64)
+#define WEBRTC_ARCH_LOONG_FAMILY
+#define WEBRTC_ARCH_64_BITS
+#define WEBRTC_ARCH_LITTLE_ENDIAN
 #elif defined(__pnacl__)
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
diff --git a/ui/gfx/linux/drm_util_linux.cc b/ui/gfx/linux/drm_util_linux.cc
index d279ef4341..684fe309be 100644
--- a/ui/gfx/linux/drm_util_linux.cc
+++ b/ui/gfx/linux/drm_util_linux.cc
@@ -8,6 +8,13 @@
 
 #include "base/notreached.h"
 
+#if defined(__loongarch64)
+// libdrm-dev
+#ifndef DRM_FORMAT_P010
+#define DRM_FORMAT_P010 fourcc_code('P', '0', '1', '0')
+#endif
+#endif
+
 namespace ui {
 
 int GetFourCCFormatFromBufferFormat(gfx::BufferFormat format) {
-- 
2.25.1

